<div class="task-page" id="task17App">
  <h2 class="task-page__title">Задание №17: Пунктуация</h2>
  
  <!-- Плавающая панель инструментов выделения -->
  <div id="task17-floating-toolbar" class="task17-floating-toolbar">
    <!-- Кнопки будут добавлены динамически -->
  </div>
  
  <div id="task17Container">
    <div style="padding: 20px;">
      <p>Загрузка заданий...</p>
    </div>
  </div>
</div>

<style>
  /* Стили для отображения объяснения с подчеркиваниями */
  .task-page .span-participle,
  .task-page .span-gerund {
    position: relative;
  }
  
  .task-page .span-participle {
    text-decoration: underline;
    text-decoration-style: wavy;
    text-decoration-color: rgba(168, 85, 247, 0.8);
  }
  
  /* Стили для кликабельных цифр в задании №17 */
  .task17-digit {
    cursor: pointer;
    padding: 1px 4px;
    margin: 0 1px;
    border-radius: 4px;
    transition: all 0.2s;
    display: inline-block;
    position: relative;
  }
  
  .task17-digit:hover:not(.selected) {
    background-color: rgba(0, 240, 255, 0.2);
    box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
  }
  
  .task17-digit.selected {
    background-color: var(--neon-cyan);
    color: var(--bg-primary);
    font-weight: bold;
  }

  /* Стили для кликабельных пробелов в режиме без цифр */
  .task17-space {
    cursor: pointer !important;
    display: inline !important; /* Используем inline для нормального распределения */
    padding: 0 !important;
    margin: 0 !important;
    border-radius: 3px;
    transition: all 0.2s ease;
    position: relative;
    user-select: none !important;
    -webkit-user-select: none !important;
    pointer-events: auto !important;
    background-color: transparent !important;
    vertical-align: baseline;
    border: none !important;
    z-index: 10;
  }

  .task17-space:hover {
    background-color: rgba(0, 240, 255, 0.25) !important;
    box-shadow: 0 0 10px rgba(0, 240, 255, 0.5) !important;
    outline: 1px solid rgba(0, 240, 255, 0.7) !important;
    outline-offset: -1px;
    /* Не меняем padding и margin, чтобы не было дрожания */
  }

  .task17-space:active {
    background-color: rgba(0, 240, 255, 0.35) !important;
  }

  .task17-space-with-comma:hover {
    background-color: rgba(0, 240, 255, 0.4) !important;
    box-shadow: 0 0 12px rgba(0, 240, 255, 0.7) !important;
  }
</style>

<!-- React через CDN -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="/js/text-selection-toolbar.js"></script>

<script type="text/babel">
  const { useState, useEffect, useRef } = React;

  // Общая функция для парсинга текста с метками (1), (2)...
  function parseTextWithDigits(text) {
    const parts = [];
    const regex = /\((\d+)\)/g;
    let lastIndex = 0;
    let match;

    while ((match = regex.exec(text)) !== null) {
      if (match.index > lastIndex) {
        parts.push({ text: text.substring(lastIndex, match.index), digit: null });
      }
      const digitNum = parseInt(match[1], 10);
      parts.push({ text: match[0], digit: digitNum });
      lastIndex = match.index + match[0].length;
    }

    if (lastIndex < text.length) {
      parts.push({ text: text.substring(lastIndex), digit: null });
    }

    return parts;
  }

  // Функция для парсинга текста с пробелами (для режима без цифр)
  // НОВАЯ ЛОГИКА: использует порядковые индексы пробелов (0, 1, 2, 3...) вместо позиций в тексте
  // Это делает индексы независимыми от пробелов и лишних запятых
  function parseTextWithSpaces(text, correctCommaPositions = null) {
    const parts = [];
    
    if (!text || text.length === 0) {
      return parts;
    }
    
    // Нормализуем текст перед парсингом (убираем множественные пробелы)
    const normalizedText = text.replace(/\s+/g, ' ').trim();
    
    // Преобразуем correctCommaPositions в Set для быстрой проверки
    // НОВАЯ ЛОГИКА: correctCommaPositions содержит индексы пробелов (0, 1, 2...), а не позиции в тексте
    // Это делает индексы независимыми от пробелов и лишних запятых
    const correctCommasSet = correctCommaPositions ? new Set(correctCommaPositions.map(p => Number(p))) : null;
    
    // Разбиваем текст на слова и пробелы, используя порядковые индексы пробелов
    // ВАЖНО: проходим по каждому символу и гарантируем, что все символы попадут в parts
    let currentOffset = 0;
    let spaceIndex = 0; // Порядковый номер пробела (0, 1, 2, 3...)
    
    // Обрабатываем случай, когда текст начинается с пробела
    if (normalizedText.length > 0 && normalizedText[0] === ' ') {
      parts.push({ 
        text: ' ', 
        isClickable: true,
        spaceIndex: spaceIndex, // Используем порядковый индекс вместо позиции
        showCorrectComma: correctCommasSet && correctCommasSet.has(spaceIndex)
      });
      currentOffset = 1;
      spaceIndex++;
    }
    
    for (let i = currentOffset; i < normalizedText.length; i++) {
      if (normalizedText[i] === ' ') {
        // Добавляем текст до пробела (если есть)
        if (i > currentOffset) {
          const textPart = normalizedText.substring(currentOffset, i);
          // ВАЖНО: добавляем только непустые части
          if (textPart.length > 0) {
            parts.push({ 
              text: textPart, 
              isClickable: false,
              spaceIndex: null
            });
          }
        }
        
        // Проверяем, нужно ли показать правильную запятую на этом пробеле
        const shouldShowCorrectComma = correctCommasSet && correctCommasSet.has(spaceIndex);
        
        // Пробел - кликабельный элемент с порядковым индексом
        parts.push({ 
          text: ' ', 
          isClickable: true,
          spaceIndex: spaceIndex, // Используем порядковый индекс вместо позиции
          showCorrectComma: shouldShowCorrectComma
        });
        currentOffset = i + 1;
        spaceIndex++;
      }
    }
    
    // ВАЖНО: добавляем оставшийся текст после последнего пробела
    if (currentOffset < normalizedText.length) {
      const textPart = normalizedText.substring(currentOffset);
      // Добавляем только непустые части
      if (textPart.length > 0) {
        parts.push({ 
          text: textPart, 
          isClickable: false,
          spaceIndex: null
        });
      }
    }
    
    // Проверка: убеждаемся, что весь текст покрыт частями
    const totalLength = parts.reduce((sum, part) => {
      const partLength = part.text ? part.text.length : 0;
      return sum + partLength;
    }, 0);
    
    // Восстанавливаем текст из parts для проверки
    const reconstructedText = parts.map(p => p.text || '').join('');
    
    if (totalLength !== normalizedText.length || reconstructedText !== normalizedText) {
      console.error('[parseTextWithSpaces] КРИТИЧЕСКАЯ ОШИБКА: ТЕКСТ НЕ СОВПАДАЕТ!', {
        totalLength,
        normalizedTextLength: normalizedText.length,
        difference: normalizedText.length - totalLength,
        reconstructedText: reconstructedText,
        textsMatch: reconstructedText === normalizedText,
        parts: parts.map((p, idx) => ({ 
          idx,
          text: p.text || '', 
          length: p.text?.length || 0,
          isClickable: p.isClickable,
          spaceIndex: p.spaceIndex
        })),
        normalizedText: normalizedText,
        normalizedTextChars: normalizedText.split('').map((c, i) => ({ i, char: c }))
      });
      
      // Пытаемся исправить: если текст не совпадает, возвращаем простой вариант
      // где каждый символ - отдельная часть (на случай критической ошибки)
      if (reconstructedText !== normalizedText) {
        console.warn('[parseTextWithSpaces] Пытаемся восстановить через простой парсинг');
        const simpleParts = [];
        let simpleSpaceIndex = 0;
        for (let i = 0; i < normalizedText.length; i++) {
          if (normalizedText[i] === ' ') {
            simpleParts.push({
              text: ' ',
              isClickable: true,
              spaceIndex: simpleSpaceIndex,
              showCorrectComma: correctCommasSet && correctCommasSet.has(simpleSpaceIndex)
            });
            simpleSpaceIndex++;
          } else {
            // Объединяем последовательные не-пробелы в одну часть
            let wordStart = i;
            while (i < normalizedText.length && normalizedText[i] !== ' ') {
              i++;
            }
            i--; // Откатываем на один символ назад
            const word = normalizedText.substring(wordStart, i + 1);
            if (word.length > 0) {
              simpleParts.push({
                text: word,
                isClickable: false,
                spaceIndex: null
              });
            }
          }
        }
        return simpleParts;
      }
    }
    
    return parts;
  }

  // Компонент для одного задания
  function Task17Item({ task, index, showDigits }) {
    const [currentMode, setCurrentMode] = useState('digits');
    const [taskData, setTaskData] = useState(null);
    const [selectedDigits, setSelectedDigits] = useState(new Set());
    const [commaPositions, setCommaPositions] = useState(new Set()); // Позиции запятых в commaless_text
    const [answerInput, setAnswerInput] = useState('');
    const [checkResult, setCheckResult] = useState(null);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    const [isLiked, setIsLiked] = useState(false);
    const [showSolution, setShowSolution] = useState(false);
    const [correctDigits, setCorrectDigits] = useState(new Set());
    const [correctCommaPositions, setCorrectCommaPositions] = useState(new Set()); // Правильные позиции запятых
    const [extraCommaPositions, setExtraCommaPositions] = useState(new Set()); // Лишние позиции запятых
    const inputRef = useRef(null);

    // Обновляем режим при изменении showDigits
    useEffect(() => {
      setCurrentMode(showDigits ? 'digits' : 'commas');
      setCommaPositions(new Set()); // Сбрасываем позиции запятых при смене режима
      setSelectedDigits(new Set()); // Сбрасываем выбранные цифры
      setCorrectCommaPositions(new Set()); // Сбрасываем правильные позиции
      setExtraCommaPositions(new Set()); // Сбрасываем лишние позиции
      setAnswerInput('');
    }, [showDigits]);

    // Загружаем задание
    useEffect(() => {
      const loadTask = async () => {
        try {
          setLoading(true);
          setCorrectDigits(new Set()); // Сбрасываем правильные цифры при загрузке
          setCorrectCommaPositions(new Set()); // Сбрасываем правильные позиции запятых
          setExtraCommaPositions(new Set()); // Сбрасываем лишние позиции запятых
          setCheckResult(null); // Сбрасываем результат проверки при загрузке нового задания
          const response = await fetch(`/api/task17/${task.id}/play?mode=${currentMode}`);
          if (!response.ok) throw new Error('Не удалось загрузить задание');
          const data = await response.json();
          
          // Нормализуем текст на клиенте (на всякий случай)
          if (data.text) {
            const originalLength = data.text.length;
            data.text = data.text.replace(/\s+/g, ' ').trim();
            const normalizedLength = data.text.length;
            console.log('[task17.ejs] Нормализация текста:', {
              originalLength,
              normalizedLength,
              textPreview: data.text.substring(0, 50)
            });
          }
          
          setTaskData(data);
          setError(null);
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Ошибка загрузки');
        } finally {
          setLoading(false);
        }
      };
      loadTask();
    }, [task.id, currentMode]);

    // Применяем цвета при показе решения
    useEffect(() => {
      if (showSolution && taskData && taskData.explanation && taskData.explanation.explanation_md) {
        setTimeout(() => {
          const explanationDiv = document.getElementById(`task17-explanation-${task.id}`);
          if (explanationDiv && typeof applyColorsInExplanation === 'function') {
            applyColorsInExplanation();
          }
        }, 300);
      }
    }, [showSolution, taskData, task.id]);

    const handleDigitClick = (digit) => {
      setSelectedDigits(prevSelected => {
        const newSet = new Set(prevSelected);
        if (newSet.has(digit)) {
          newSet.delete(digit);
        } else {
          newSet.add(digit);
        }
        return newSet;
      });
    };

    const handleSpaceClick = (offset) => {
      setCommaPositions(prevPositions => {
        const newSet = new Set(prevPositions);
        if (newSet.has(offset)) {
          newSet.delete(offset);
        } else {
          newSet.add(offset);
        }
        return newSet;
      });
    };

    useEffect(() => {
      if (currentMode === 'digits') {
        const sortedDigits = Array.from(selectedDigits).sort((a, b) => a - b);
        setAnswerInput(sortedDigits.join(''));
      } else {
        const sortedPositions = Array.from(commaPositions).sort((a, b) => a - b);
        setAnswerInput(sortedPositions.join(', '));
      }
    }, [selectedDigits, commaPositions, currentMode]);

    const handleInputChange = (e) => {
      const value = e.target.value;
      setAnswerInput(value);
      const digits = value.split('').map(char => parseInt(char, 10)).filter(n => !isNaN(n) && n > 0);
      setSelectedDigits(new Set(digits));
    };

    const handleCheck = async () => {
      if (!taskData) return;
      
      let payload = { mode: currentMode, spans: [] };
      
      if (currentMode === 'digits') {
        const currentDigits = Array.from(selectedDigits).sort((a, b) => a - b);
        if (currentDigits.length === 0) {
          alert('Введите ответ, выбрав цифры в тексте или введя их вручную');
          if (inputRef.current) {
            inputRef.current.focus();
          }
          return;
        }
        payload.digits = currentDigits;
      } else {
        const currentCommaPositions = Array.from(commaPositions).sort((a, b) => a - b);
        // НОВАЯ ЛОГИКА: разрешаем отправку пустого ответа - после этого покажутся правильные запятые
        // НОВАЯ ЛОГИКА: отправляем индексы пробелов (0, 1, 2...), а не позиции в тексте
        // Это делает индексы независимыми от пробелов и лишних запятых
        payload.comma_positions = currentCommaPositions; // Может быть пустым массивом
      }

      try {
        setLoading(true);
        const response = await fetch(`/api/task17/${task.id}/check`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) throw new Error('Ошибка проверки');
        const result = await response.json();
        setCheckResult(result);
        
        // Обрабатываем результат в зависимости от режима
        if (currentMode === 'digits') {
          // Режим цифр - сохраняем правильные цифры для подсветки
          if (result.correctAnswer && result.digits && !result.digits.isCorrect) {
            setCorrectDigits(new Set(result.correctAnswer));
          } else {
            setCorrectDigits(new Set());
          }
          // Сбрасываем позиции запятых в режиме цифр
          setCorrectCommaPositions(new Set());
          setExtraCommaPositions(new Set());
        } else {
          // Режим запятых - сохраняем правильные и лишние индексы пробелов
          // НОВАЯ ЛОГИКА: correctAnswer и extra содержат индексы пробелов (0, 1, 2...), а не позиции
          console.log('[task17.ejs] Обработка результата. currentMode:', currentMode);
          console.log('[task17.ejs] result.commas:', result.commas);
          console.log('[task17.ejs] result.correctAnswer:', result.correctAnswer);
          if (result.commas) {
            // Сохраняем правильные индексы пробелов (показываем ВСЕГДА после проверки)
            if (result.correctAnswer && Array.isArray(result.correctAnswer)) {
              // Преобразуем в числа для корректного сравнения
              // correctAnswer содержит индексы пробелов (0, 1, 2...)
              const correctIndices = result.correctAnswer.map(p => Number(p));
              console.log('[task17.ejs] Сохраняем правильные индексы пробелов:', correctIndices);
              console.log('[task17.ejs] correctIndices.length:', correctIndices.length);
              console.log('[task17.ejs] correctIndices:', JSON.stringify(correctIndices));
              setCorrectCommaPositions(new Set(correctIndices));
              // Проверяем, что Set правильно создан
              const testSet = new Set(correctIndices);
              console.log('[task17.ejs] Создан Set с размером:', testSet.size);
              console.log('[task17.ejs] Set содержит:', Array.from(testSet));
            } else {
              console.log('[task17.ejs] correctAnswer не найден или не массив:', result.correctAnswer);
              console.log('[task17.ejs] Тип result.correctAnswer:', typeof result.correctAnswer);
              setCorrectCommaPositions(new Set());
            }
            // Сохраняем лишние индексы пробелов
            if (result.commas.extra && Array.isArray(result.commas.extra)) {
              // extra содержит индексы пробелов (0, 1, 2...)
              const extraIndices = result.commas.extra.map(p => Number(p));
              setExtraCommaPositions(new Set(extraIndices));
            } else {
              setExtraCommaPositions(new Set());
            }
          } else {
            setCorrectCommaPositions(new Set());
            setExtraCommaPositions(new Set());
          }
          // Сбрасываем цифры в режиме запятых
          setCorrectDigits(new Set());
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Ошибка проверки');
      } finally {
        setLoading(false);
      }
    };

    if (loading && !taskData) {
      return (
        <div className="task-card">
          <div className="task-content">
            <p>Загрузка задания {index + 1}...</p>
          </div>
        </div>
      );
    }

    if (error) {
      return (
        <div className="task-card">
          <div className="task-content">
            <p style={{color: 'red'}}>Ошибка: {error}</p>
          </div>
        </div>
      );
    }

    if (!taskData) {
      return null;
    }

    return (
      <div className="task-card">
        <div className="task-meta">
          <span className="task-meta__number">№ {index + 1}</span>
          {task.source && <span className="task-meta__source">{task.source}</span>}
        </div>
        
        <div className="task-content">
          <div className="task-prompt" style={{position: 'relative'}}>
            <div 
              className="task17-text-editable"
              id={`task17-text-${task.id}`}
              style={{
                padding: '16px',
                border: '1px solid var(--glass-border)',
                borderRadius: '8px',
                background: 'var(--bg-secondary)',
                position: 'relative'
              }}
              contentEditable={false}
              suppressContentEditableWarning={true}
              onCopy={(e) => {
                // Перехватываем событие копирования и заменяем текст на исходный с цифрами
                e.preventDefault();
                // В режиме digits taskData.text уже содержит цифры
                // В режиме commas нужно использовать исходный source_text из задания
                let originalText = taskData.text || '';
                if (currentMode === 'commas' && taskData.source_text) {
                  // Используем исходный текст с цифрами из задания
                  originalText = taskData.source_text;
                }
                if (originalText && e.clipboardData) {
                  e.clipboardData.setData('text/plain', originalText);
                }
              }}
            >
              <div style={{
                paddingBottom: '12px',
                marginBottom: '12px',
                borderBottom: '1px solid var(--glass-border)',
                fontSize: '16px',
                lineHeight: '1.6',
                color: 'var(--text-primary)',
                fontWeight: '500'
              }}>
                {currentMode === 'digits' 
                  ? 'Укажите цифру(-ы), на месте которой(-ых) должна(-ы) стоять запятая(-ые).'
                  : 'Нажмите на пробелы в тексте, где должны стоять запятые.'}
              </div>
              {currentMode === 'digits' ? (
                parseTextWithDigits(taskData.text).map((part, idx) => {
                  if (part.digit !== null) {
                    const isSelected = selectedDigits.has(part.digit);
                    const isCorrect = correctDigits.has(part.digit);
                    return (
                      <span
                        key={`digit-${task.id}-${part.digit}-${idx}`}
                        className={`task17-digit ${isSelected ? 'selected' : ''} ${isCorrect ? 'correct-highlight' : ''}`}
                        data-digit={part.digit}
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          handleDigitClick(part.digit);
                        }}
                        title={`Кликните, чтобы ${isSelected ? 'убрать' : 'добавить'} цифру ${part.digit} в ответ`}
                        style={{
                          userSelect: 'none',
                          WebkitUserSelect: 'none',
                          cursor: 'pointer',
                          contentEditable: 'false',
                          ...(isCorrect && {
                            backgroundColor: 'rgba(34, 197, 94, 0.3)',
                            border: '2px solid rgba(34, 197, 94, 0.8)',
                            padding: '2px 4px'
                          })
                        }}
                        contentEditable={false}
                        suppressContentEditableWarning={true}
                      >
                        {part.text}
                      </span>
                    );
                  }
                  // Текстовые части для режима digits отображаем как есть
                  // ВАЖНО: проверяем, что part.text существует
                  if (!part.text) {
                    console.warn('[task17.ejs] Пустая текстовая часть (digits):', part, 'idx:', idx);
                    return null;
                  }
                  return <span key={`text-${task.id}-${idx}`}>{part.text}</span>;
                })
              ) : (
                (() => {
                  // НОВАЯ ЛОГИКА: correctCommaPositions содержит индексы пробелов (0, 1, 2...), а не позиции
                  const correctIndicesArray = checkResult && correctCommaPositions.size > 0
                    ? Array.from(correctCommaPositions) 
                    : null;
                  console.log('[task17.ejs] Передаем в parseTextWithSpaces correctIndicesArray (индексы пробелов):', correctIndicesArray);
                  console.log('[task17.ejs] correctCommaPositions.size:', correctCommaPositions.size);
                  console.log('[task17.ejs] checkResult:', checkResult);
                  console.log('[task17.ejs] taskData.text длина:', taskData.text?.length);
                  console.log('[task17.ejs] taskData.text превью:', taskData.text?.substring(0, 100));
                  // Нормализуем текст так же, как на сервере
                  const normalizedClientText = taskData.text?.replace(/\s+/g, ' ').trim() || '';
                  console.log('[task17.ejs] Нормализованный текст на клиенте, длина:', normalizedClientText.length);
                  console.log('[task17.ejs] Количество пробелов в нормализованном тексте:', (normalizedClientText.match(/\s/g) || []).length);
                  const parts = parseTextWithSpaces(taskData.text, correctIndicesArray);
                  console.log('[task17.ejs] parseTextWithSpaces вернул parts:', parts.length);
                  const totalPartsLength = parts.reduce((sum, p) => sum + (p.text?.length || 0), 0);
                  console.log('[task17.ejs] Общая длина всех parts:', totalPartsLength, 'длина текста:', taskData.text?.length);
                  return parts;
                })().map((part, idx) => {
                  if (part.isClickable && part.spaceIndex !== null && part.spaceIndex !== undefined) {
                    const spaceIndex = Number(part.spaceIndex); // Порядковый индекс пробела (0, 1, 2...)
                    // Проверяем с учетом преобразования типов
                    const hasComma = commaPositions.has(spaceIndex);
                    // Проверяем правильность и лишние позиции (используем явное сравнение чисел)
                    const isCorrect = correctCommaPositions.has(spaceIndex);
                    const isExtra = extraCommaPositions.has(spaceIndex);
                    
                    // Отладка для первых нескольких позиций и правильных позиций
                    if (checkResult && (idx < 10 || isCorrect || hasComma || correctCommaPositions.has(spaceIndex))) {
                      console.log(`[task17.ejs] Индекс пробела ${spaceIndex}: hasComma=${hasComma}, isCorrect=${isCorrect}`);
                      console.log(`[task17.ejs] correctCommaPositions.size:`, correctCommaPositions.size);
                      console.log(`[task17.ejs] correctCommaPositions содержит ${spaceIndex}?`, correctCommaPositions.has(spaceIndex));
                      console.log(`[task17.ejs] Все correctCommaPositions:`, Array.from(correctCommaPositions));
                      console.log(`[task17.ejs] Тип spaceIndex:`, typeof spaceIndex, 'значение:', spaceIndex);
                    }
                    // Определяем стиль в зависимости от статуса позиции
                    let bgColor = 'transparent';
                    let textColor = 'inherit';
                    let fontWeight = 'normal';
                    // Показываем запятую если: выбрана пользователем ИЛИ правильная позиция после проверки
                    let displayComma = hasComma || (checkResult && isCorrect);
                    
                    if (checkResult) {
                      // После проверки показываем правильные и неправильные позиции
                      // Показываем ВСЕ правильные запятые после проверки
                      if (hasComma && isExtra) {
                        // Неправильная позиция - красная
                        bgColor = 'rgba(239, 68, 68, 0.3)';
                        textColor = '#ef4444';
                        fontWeight = 'bold';
                        displayComma = true;
                      } else if (isCorrect) {
                        // Правильная позиция (выбранная или нет) - зеленая
                        // Показываем ВСЕ правильные запятые после проверки
                        bgColor = 'rgba(34, 197, 94, 0.3)';
                        textColor = '#22c55e';
                        fontWeight = 'bold';
                        displayComma = true;
                      } else if (hasComma) {
                        // Выбрана, но не является ни правильной, ни лишней (не должно происходить, но на всякий случай)
                        bgColor = 'rgba(0, 240, 255, 0.3)';
                        textColor = 'var(--neon-cyan)';
                        fontWeight = 'bold';
                        displayComma = true;
                      }
                    } else {
                      // До проверки - обычная синяя подсветка
                      if (hasComma) {
                        bgColor = 'rgba(0, 240, 255, 0.3)';
                        textColor = 'var(--neon-cyan)';
                        fontWeight = 'bold';
                        displayComma = true;
                      }
                    }
                    
                    return (
                      <span
                        key={`space-${task.id}-${spaceIndex}-${idx}`}
                        className={`task17-space ${hasComma ? 'task17-space-with-comma' : ''} ${isCorrect ? 'task17-space-correct' : ''} ${isExtra ? 'task17-space-extra' : ''}`}
                        data-space-index={spaceIndex}
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          handleSpaceClick(spaceIndex);
                        }}
                        title="Кликните, чтобы поставить запятую"
                        style={{
                          backgroundColor: bgColor,
                          color: textColor,
                          fontWeight: fontWeight
                        }}
                      >
                        {displayComma ? ',' : ' '}
                      </span>
                    );
                  }
                  // Текстовые части отображаем как есть, без добавления запятых
                  // ВАЖНО: проверяем, что part существует и part.text определен
                  if (!part) {
                    console.error('[task17.ejs] Отсутствует part (commas):', 'idx:', idx);
                    return null;
                  }
                  // ВАЖНО: part.text может быть пустой строкой (хотя не должно), но мы все равно отображаем
                  const textToDisplay = part.text !== undefined && part.text !== null ? part.text : '';
                  if (textToDisplay === '' && idx > 0) {
                    // Пустая текстовая часть в середине - это подозрительно, но не критично
                    console.warn('[task17.ejs] Пустая текстовая часть (commas):', part, 'idx:', idx);
                  }
                  return <span key={`text-${task.id}-${idx}`}>{textToDisplay}</span>;
                })
              )}
            </div>
          </div>

          <div className="task-controls">
            {currentMode === 'digits' && (
              <input
                ref={inputRef}
                className="task-input"
                type="text"
                value={answerInput}
                onChange={handleInputChange}
                placeholder="Введите свой ответ"
                inputMode="numeric"
                onKeyPress={(e) => {
                  if (e.key === 'Enter') {
                    handleCheck();
                  }
                }}
              />
            )}
            <button
              className="task-send"
              onClick={handleCheck}
              disabled={loading}
            >
              <span>{loading ? 'Проверка...' : 'Отправить'}</span>
            </button>
            <button
              className="task-solution"
              onClick={() => setShowSolution(!showSolution)}
            >
              <span>Решение</span>
              <img src={showSolution ? "/images/eye on.svg" : "/images/eye off.svg"} alt="Глаз" width="16" height="16"/>
            </button>
            <button 
              className="task-like"
              onClick={() => setIsLiked(!isLiked)}
            >
              <img 
                src={isLiked ? "/images/heart on.svg" : "/images/heart off.svg"} 
                alt="Лайк" 
                width="16" 
                height="16"
              />
            </button>
          </div>

          {showSolution && taskData && taskData.explanation && (
            <div id={`task17-solution-block-${task.id}`} style={{marginTop: '24px'}}>
              {taskData.explanation.answer_text && (
                <div style={{marginBottom: '12px'}} className="solution-answer">
                  <strong>Ответ:</strong> {taskData.explanation.answer_text}
                </div>
              )}
              {taskData.explanation.explanation_md && (
                <div>
                  <h4 style={{marginTop: 0, marginBottom: '12px'}}>Объяснение:</h4>
                  <div
                    id={`task17-explanation-${task.id}`}
                    dangerouslySetInnerHTML={{
                      __html: taskData.explanation.explanation_md.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    }}
                    className="editor-content task17-explanation-content"
                    style={{
                      position: 'relative',
                      fontSize: '18px',
                      lineHeight: '1.8',
                      padding: '16px',
                      minHeight: '100px'
                    }}
                  />
                </div>
              )}
            </div>
          )}

          {checkResult && (
            <div className="task-solution-block" style={{marginTop: '24px'}}>
              <h3 style={{marginTop: 0, marginBottom: '16px'}}>Результат проверки</h3>
              
              {((currentMode === 'digits' && checkResult.digits && checkResult.digits.isCorrect) ||
                (currentMode === 'commas' && checkResult.commas && checkResult.commas.isCorrect)) ? (
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '12px',
                  padding: '16px',
                  background: 'rgba(34, 197, 94, 0.1)',
                  border: '2px solid rgba(34, 197, 94, 0.5)',
                  marginBottom: '16px'
                }}>
                  <div style={{
                    fontSize: '32px',
                    color: '#22c55e',
                    lineHeight: '1'
                  }}>
                    ✓
                  </div>
                  <div style={{
                    fontSize: '18px',
                    fontWeight: 'bold',
                    color: '#22c55e'
                  }}>
                    Все верно!
                  </div>
                </div>
              ) : (
                <div style={{marginBottom: '16px'}}>
                  <div style={{
                    fontWeight: 'bold',
                    color: '#f6b462',
                    marginBottom: '12px',
                    fontSize: '16px'
                  }}>
                    Ответ неверный
                  </div>
                  {checkResult.correctAnswer && (
                    <div style={{
                      padding: '12px',
                      background: 'rgba(239, 68, 68, 0.1)',
                      border: '1px solid rgba(239, 68, 68, 0.3)',
                      marginBottom: '12px'
                    }}>
                      <div style={{
                        color: 'var(--text-secondary)',
                        marginBottom: '4px',
                        fontSize: '14px'
                      }}>
                        Правильный ответ:
                      </div>
                      <div style={{
                        fontSize: '18px',
                        fontWeight: 'bold',
                        color: '#22c55e'
                      }}>
                        {checkResult.correctAnswer.join(', ')}
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    );
  }

  // Компонент для списка всех заданий
  function Task17List() {
    const [allTasks, setAllTasks] = useState([]);
    const [loading, setLoading] = useState(true);
    const [showDigits, setShowDigits] = useState(true);
    const [isSettingsExpanded, setIsSettingsExpanded] = useState(false);

    useEffect(() => {
      const loadAllTasks = async () => {
        try {
          const response = await fetch('/api/task17');
          if (!response.ok) throw new Error('Не удалось загрузить список заданий');
          const tasks = await response.json();
          setAllTasks(tasks);
        } catch (err) {
          console.error('Ошибка загрузки списка заданий:', err);
        } finally {
          setLoading(false);
        }
      };
      loadAllTasks();
    }, []);

    // Применяем скрытие цифр ко всем заданиям
    useEffect(() => {
      const allTextEditors = document.querySelectorAll('.task17-text-editable');
      allTextEditors.forEach(editor => {
        const digits = editor.querySelectorAll('.task17-digit');
        digits.forEach(digit => {
          digit.style.display = showDigits ? '' : 'none';
        });
      });
    }, [showDigits]);

    if (loading) {
      return (
        <div style={{padding: '20px'}}>
          <p>Загрузка заданий...</p>
        </div>
      );
    }

    if (allTasks.length === 0) {
      return (
        <div style={{padding: '20px'}}>
          <p>Заданий №17 пока нет.</p>
        </div>
      );
    }

    return (
      <div className="task17-wrapper">
        <div style={{flex: 1, maxWidth: '800px'}}>
          {allTasks.map((task, index) => (
            <Task17Item key={task.id} task={task} index={index} showDigits={showDigits} />
          ))}
        </div>
        {/* Правая панель с переключателями */}
        <div 
          className="task17-control-panel"
                style={{
            width: isSettingsExpanded ? 'auto' : '40px',
            minWidth: isSettingsExpanded ? '240px' : '40px',
            height: isSettingsExpanded ? 'auto' : '40px',
            padding: isSettingsExpanded ? '12px' : '0',
            borderRadius: '8px',
            background: 'var(--bg-tertiary)',
            border: '1px solid var(--glass-border)',
                  transition: 'all 0.3s ease',
            overflow: 'hidden',
            display: 'flex',
            flexDirection: isSettingsExpanded ? 'row' : 'column',
            alignItems: isSettingsExpanded ? 'center' : 'stretch',
            gap: isSettingsExpanded ? '12px' : '0'
                }}
              >
                <div
            onClick={() => setIsSettingsExpanded(!isSettingsExpanded)}
                  style={{
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              userSelect: 'none',
              width: '40px',
              height: '40px',
              minWidth: '40px',
              borderRadius: '4px',
              transition: 'background-color 0.2s ease',
              flexShrink: 0
            }}
            onMouseEnter={(e) => e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.05)'}
            onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
            title="Настройки отображения"
          >
            <svg 
              width="20" 
              height="20" 
              viewBox="0 0 24 24" 
              fill="none" 
              xmlns="http://www.w3.org/2000/svg"
              style={{
                transform: isSettingsExpanded ? 'rotate(90deg)' : 'rotate(0deg)',
                transition: 'transform 0.3s ease',
                color: 'var(--text-primary)'
              }}
            >
              <path 
                d="M12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15Z" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round"
              />
              <path 
                d="M19.4 15C19.2669 15.3016 19.2272 15.6362 19.286 15.9606C19.3448 16.285 19.4995 16.5843 19.73 16.82L19.79 16.88C19.976 17.0657 20.1235 17.2863 20.2241 17.5291C20.3248 17.7719 20.3766 18.0322 20.3766 18.295C20.3766 18.5578 20.3248 18.8181 20.2241 19.0609C20.1235 19.3037 19.976 19.5243 19.79 19.71C19.6043 19.896 19.3837 20.0435 19.1409 20.1441C18.8981 20.2448 18.6378 20.2966 18.375 20.2966C18.1122 20.2966 17.8519 20.2448 17.6091 20.1441C17.3663 20.0435 17.1457 19.896 16.96 19.71L16.9 19.65C16.6643 19.4195 16.365 19.2648 16.0406 19.206C15.7162 19.1472 15.3816 19.1869 15.08 19.32C14.7842 19.4468 14.532 19.6572 14.3543 19.9255C14.1766 20.1938 14.0813 20.5082 14.08 20.83V21C14.08 21.5304 13.8693 22.0391 13.4942 22.4142C13.1191 22.7893 12.6104 23 12.08 23C11.5496 23 11.0409 22.7893 10.6658 22.4142C10.2907 22.0391 10.08 21.5304 10.08 21V20.91C10.0723 20.579 9.96512 20.258 9.77251 19.9887C9.5799 19.7194 9.31074 19.5143 9 19.4C8.69838 19.2669 8.36381 19.2272 8.03941 19.286C7.71502 19.3448 7.41568 19.4995 7.18 19.73L7.12 19.79C6.93425 19.976 6.71368 20.1235 6.47088 20.2241C6.22808 20.3248 5.96783 20.3766 5.705 20.3766C5.44217 20.3766 5.18192 20.3248 4.93912 20.2241C4.69632 20.1235 4.47575 19.976 4.29 19.79C4.10405 19.6043 3.95653 19.3837 3.85588 19.1409C3.75523 18.8981 3.70343 18.6378 3.70343 18.375C3.70343 18.1122 3.75523 17.8519 3.85588 17.6091C3.95653 17.3663 4.10405 17.1457 4.29 16.96L4.35 16.9C4.58054 16.6643 4.73519 16.365 4.794 16.0406C4.85282 15.7162 4.81312 15.3816 4.68 15.08C4.55324 14.7842 4.34276 14.532 4.07447 14.3543C3.80618 14.1766 3.49179 14.0813 3.17 14.08H3C2.46957 14.08 1.96086 13.8693 1.58579 13.4942C1.21071 13.1191 1 12.6104 1 12.08C1 11.5496 1.21071 11.0409 1.58579 10.6658C1.96086 10.2907 2.46957 10.08 3 10.08H3.09C3.42099 10.0723 3.742 9.96512 4.0113 9.77251C4.28059 9.5799 4.48572 9.31074 4.6 9C4.73312 8.69838 4.77282 8.36381 4.714 8.03941C4.65519 7.71502 4.50054 7.41568 4.27 7.18L4.21 7.12C4.02405 6.93425 3.87653 6.71368 3.77588 6.47088C3.67523 6.22808 3.62343 5.96783 3.62343 5.705C3.62343 5.44217 3.67523 5.18192 3.77588 4.93912C3.87653 4.69632 4.02405 4.47575 4.21 4.29C4.39575 4.10405 4.61632 3.95653 4.85912 3.85588C5.10192 3.75523 5.36217 3.70343 5.625 3.70343C5.88783 3.70343 6.14808 3.75523 6.39088 3.85588C6.63368 3.95653 6.85425 4.10405 7.04 4.29L7.1 4.35C7.33568 4.58054 7.63502 4.73519 7.95941 4.794C8.28381 4.85282 8.61838 4.81312 8.92 4.68H9C9.29577 4.55324 9.54802 4.34276 9.72569 4.07447C9.90337 3.80618 9.99872 3.49179 10 3.17V3C10 2.46957 10.2107 1.96086 10.5858 1.58579C10.9609 1.21071 11.4696 1 12 1C12.5304 1 13.0391 1.21071 13.4142 1.58579C13.7893 1.96086 14 2.46957 14 3V3.09C14.0013 3.41179 14.0966 3.72618 14.2743 3.99447C14.452 4.26276 14.7042 4.47324 15 4.6C15.3016 4.73312 15.6362 4.77282 15.9606 4.714C16.285 4.65519 16.5843 4.50054 16.82 4.27L16.88 4.21C17.0657 4.02405 17.2863 3.87653 17.5291 3.77588C17.7719 3.67523 18.0322 3.62343 18.295 3.62343C18.5578 3.62343 18.8181 3.67523 19.0609 3.77588C19.3037 3.87653 19.5243 4.02405 19.71 4.21C19.896 4.39575 20.0435 4.61632 20.1441 4.85912C20.2448 5.10192 20.2966 5.36217 20.2966 5.625C20.2966 5.88783 20.2448 6.14808 20.1441 6.39088C20.0435 6.63368 19.896 6.85425 19.71 7.04L19.65 7.1C19.4195 7.33568 19.2648 7.63502 19.206 7.95941C19.1472 8.28381 19.1869 8.61838 19.32 8.92V9C19.4468 9.29577 19.6572 9.54802 19.9255 9.72569C20.1938 9.90337 20.5082 9.99872 20.83 10H21C21.5304 10 22.0391 10.2107 22.4142 10.5858C22.7893 10.9609 23 11.4696 23 12C23 12.5304 22.7893 13.0391 22.4142 13.4142C22.0391 13.7893 21.5304 14 21 14H20.91C20.5882 14.0013 20.2738 14.0966 20.0055 14.2743C19.7372 14.452 19.5268 14.7042 19.4 15Z" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round"
              />
            </svg>
              </div>
          
          {isSettingsExpanded && (
            <div style={{
              display: 'flex', 
              flexDirection: 'column', 
              gap: '12px',
              animation: 'slideDown 0.3s ease',
              overflow: 'hidden',
              flex: 1,
              minWidth: 0
            }}>
            <label style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              cursor: 'pointer',
              color: 'var(--text-primary)',
                fontSize: '14px',
                gap: '12px',
                padding: '4px 0'
            }}>
                <span style={{ flex: 1, minWidth: 0 }}>Показывать цифры</span>
              <div
                  onClick={(e) => {
                    e.stopPropagation();
                    setShowDigits(!showDigits);
                  }}
                style={{
                  width: '48px',
                  height: '24px',
                    background: showDigits ? 'var(--neon-cyan)' : 'var(--text-disabled)',
                  position: 'relative',
                  cursor: 'pointer',
                  transition: 'all 0.3s ease',
                    boxShadow: showDigits ? '0 0 10px rgba(0, 240, 255, 0.5)' : 'none',
                    borderRadius: '12px',
                    flexShrink: 0
                }}
              >
                <div
                  style={{
                    width: '20px',
                    height: '20px',
                    borderRadius: '50%',
                    background: '#fff',
                    position: 'absolute',
                    top: '2px',
                      left: showDigits ? '26px' : '2px',
                    transition: 'all 0.3s ease',
                    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)'
                  }}
                />
              </div>
            </label>
          </div>
          )}
        </div>
      </div>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('task17Container'));
  root.render(<Task17List />);
</script>

<script>
  // Инициализация панели инструментов для выделений
  // Палитра цветов для главных слов (глобальная константа)
  const COLOR_PALETTE = [
    { bg: 'rgba(59, 130, 246, 0.3)', border: 'rgba(59, 130, 246, 0.8)', text: 'rgba(59, 130, 246, 1)' }, // Синий
    { bg: 'rgba(34, 197, 94, 0.3)', border: 'rgba(34, 197, 94, 0.8)', text: 'rgba(34, 197, 94, 1)' }, // Зеленый
    { bg: 'rgba(236, 72, 153, 0.3)', border: 'rgba(236, 72, 153, 0.8)', text: 'rgba(236, 72, 153, 1)' }, // Розовый
    { bg: 'rgba(251, 191, 36, 0.3)', border: 'rgba(251, 191, 36, 0.8)', text: 'rgba(251, 191, 36, 1)' }, // Желтый
    { bg: 'rgba(168, 85, 247, 0.3)', border: 'rgba(168, 85, 247, 0.8)', text: 'rgba(168, 85, 247, 1)' }, // Фиолетовый
    { bg: 'rgba(239, 68, 68, 0.3)', border: 'rgba(239, 68, 68, 0.8)', text: 'rgba(239, 68, 68, 1)' }, // Красный
    { bg: 'rgba(14, 165, 233, 0.3)', border: 'rgba(14, 165, 233, 0.8)', text: 'rgba(14, 165, 233, 1)' }, // Голубой
    { bg: 'rgba(245, 158, 11, 0.3)', border: 'rgba(245, 158, 11, 0.8)', text: 'rgba(245, 158, 11, 1)' }, // Оранжевый
  ];

  // Выносим функцию applySpanClass в глобальную область для использования в плавающей панели
  function applySpanClass(className) {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;

      const range = selection.getRangeAt(0);
      const parent = range.commonAncestorContainer.nodeType === 3 
        ? range.commonAncestorContainer.parentElement 
        : range.commonAncestorContainer;

      let editor = parent;
      while (editor && !editor.classList.contains('task17-text-editable')) {
        editor = editor.parentElement;
      }

      if (!editor) {
        alert('Поместите курсор в текст задания');
        return;
      }

      const selectedText = selection.toString().trim();
      if (!selectedText) {
        alert('Выделите текст для отметки');
        return;
      }

      try {
        // Функция для расширения range до ближайших пробелов
        function expandRangeToSpaces(range) {
          const expandedRange = range.cloneRange();
          
          // Расширяем начало влево до пробела
          let startContainer = expandedRange.startContainer;
          let startOffset = expandedRange.startOffset;
          
          // Если начало в текстовом узле
          if (startContainer.nodeType === Node.TEXT_NODE) {
            const text = startContainer.textContent;
            let newOffset = startOffset;
            // Ищем пробел слева, но начинаем после него (не включая пробел)
            while (newOffset > 0 && text[newOffset - 1] !== ' ') {
              newOffset--;
            }
            // Если нашли пробел, начинаем после него (newOffset уже указывает на позицию после пробела)
            // Если не нашли пробел, newOffset = 0, что тоже правильно
            expandedRange.setStart(startContainer, newOffset);
          } else {
            // Если начало в элементе, ищем первый текстовый узел внутри
            const walker = document.createTreeWalker(
              startContainer,
              NodeFilter.SHOW_TEXT,
              null
            );
            const firstTextNode = walker.nextNode();
            if (firstTextNode) {
              const text = firstTextNode.textContent;
              let spacePos = text.lastIndexOf(' ');
              if (spacePos >= 0) {
                expandedRange.setStart(firstTextNode, spacePos + 1);
              } else {
                expandedRange.setStart(firstTextNode, 0);
              }
            }
          }
          
          // Расширяем конец вправо до пробела (не включая пробел)
          let endContainer = expandedRange.endContainer;
          let endOffset = expandedRange.endOffset;
          
          // Если конец в текстовом узле
          if (endContainer.nodeType === Node.TEXT_NODE) {
            const text = endContainer.textContent;
            let newOffset = endOffset;
            // Ищем пробел справа, но не включаем его
            while (newOffset < text.length && text[newOffset] !== ' ') {
              newOffset++;
            }
            // НЕ включаем пробел - останавливаемся перед ним
            expandedRange.setEnd(endContainer, newOffset);
          } else {
            // Если конец в элементе, ищем последний текстовый узел внутри
            const walker = document.createTreeWalker(
              endContainer,
              NodeFilter.SHOW_TEXT,
              null
            );
            let lastTextNode = null;
            let node;
            while (node = walker.nextNode()) {
              lastTextNode = node;
            }
            if (lastTextNode) {
              const text = lastTextNode.textContent;
              let spacePos = text.indexOf(' ');
              if (spacePos >= 0) {
                // НЕ включаем пробел - останавливаемся перед ним
                expandedRange.setEnd(lastTextNode, spacePos);
              } else {
                expandedRange.setEnd(lastTextNode, text.length);
              }
            }
          }
          
          // Если range пересекает несколько узлов, расширяем границы
          // Расширяем начало, проходя по предыдущим узлам
          while (true) {
            const startContainer = expandedRange.startContainer;
            const startOffset = expandedRange.startOffset;
            
            if (startContainer.nodeType === Node.TEXT_NODE && startOffset === 0) {
              // Дошли до начала текстового узла, проверяем предыдущий узел
              const prevNode = startContainer.previousSibling;
              if (prevNode && prevNode.nodeType === Node.TEXT_NODE) {
                const text = prevNode.textContent;
                const spacePos = text.lastIndexOf(' ');
                if (spacePos >= 0) {
                  expandedRange.setStart(prevNode, spacePos + 1);
                  continue;
                } else {
                  expandedRange.setStart(prevNode, 0);
                  continue;
                }
              }
            }
            break;
          }
          
          // Расширяем конец, проходя по следующим узлам
          while (true) {
            const endContainer = expandedRange.endContainer;
            const endOffset = expandedRange.endOffset;
            
            if (endContainer.nodeType === Node.TEXT_NODE && 
                endOffset >= endContainer.textContent.length) {
              // Дошли до конца текстового узла, проверяем следующий узел
              const nextNode = endContainer.nextSibling;
              if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
                const text = nextNode.textContent;
                const spacePos = text.indexOf(' ');
                if (spacePos >= 0) {
                  // НЕ включаем пробел - останавливаемся перед ним
                  expandedRange.setEnd(nextNode, spacePos);
                  continue;
                } else {
                  expandedRange.setEnd(nextNode, text.length);
                  continue;
                }
              }
            }
            break;
          }
          
          return expandedRange;
        }

        // Расширяем range до ближайших пробелов (не включая пробелы) для всех типов
        let expandedRange;
        try {
          expandedRange = expandRangeToSpaces(range);
        } catch (e) {
          // Если не удалось расширить, используем исходный range
          expandedRange = range.cloneRange();
        }
        
        // Проверяем, что есть выделение
        const expandedText = expandedRange.toString();
        if (!expandedText || expandedText.trim() === '') {
          // Если расширенное выделение пустое, пробуем использовать исходный range
          const originalText = range.toString().trim();
          if (!originalText) {
            alert('Не удалось расширить выделение');
            return;
          }
          // Используем исходный range без расширения
          expandedRange = range.cloneRange();
        }

        // Проверяем ограничения на вложенные обороты и замену выделений
        // Разрешенные комбинации: причастный в деепричастном, деепричастный в причастном, 
        // причастный в причастном, деепричастный в деепричастном
        const underlineClasses = ['span-participle', 'span-gerund', 'span-subject', 'span-predicate'];
        const isUnderlineClass = underlineClasses.includes(className);
        
        if (isUnderlineClass) {
          // Проверяем, находится ли выделение полностью внутри существующего span с подчеркиванием
          const startContainer = expandedRange.startContainer;
          const endContainer = expandedRange.endContainer;
          
          // Ищем ближайший родительский span с подчеркиванием для начала
          let startParent = startContainer.nodeType === 1 ? startContainer : startContainer.parentElement;
          let parentUnderlineSpan = null;
          while (startParent && startParent !== editor) {
            if (startParent.classList) {
              for (const cls of underlineClasses) {
                if (startParent.classList.contains(cls)) {
                  parentUnderlineSpan = startParent;
                  break;
                }
              }
              if (parentUnderlineSpan) break;
            }
            startParent = startParent.parentElement;
          }
          
          // Если выделение находится внутри существующего span с подчеркиванием
          if (parentUnderlineSpan) {
            // Проверяем, является ли выделение строго вложенным (не совпадает с родителем)
            // Если выделение совпадает с родителем или покрывает его полностью - заменяем
            const parentText = parentUnderlineSpan.textContent.trim();
            const rangeText = expandedRange.toString().trim();
            
            // Проверяем, совпадают ли границы выделения с границами родительского span
            const spanRange = document.createRange();
            spanRange.selectNodeContents(parentUnderlineSpan);
            
            // Если тексты совпадают или выделение покрывает весь родительский span - заменяем
            const isExactMatch = expandedRange.compareBoundaryPoints(Range.START_TO_START, spanRange) === 0 &&
                                 expandedRange.compareBoundaryPoints(Range.END_TO_END, spanRange) === 0;
            const isAlmostMatch = rangeText === parentText || 
                                  (rangeText.length >= parentText.length * 0.95 && rangeText.length <= parentText.length * 1.05);
            
            if (isExactMatch || isAlmostMatch) {
              // Заменяем старое выделение на новое
              const grandParent = parentUnderlineSpan.parentNode;
              if (grandParent) {
                // Удаляем старый span
                while (parentUnderlineSpan.firstChild) {
                  grandParent.insertBefore(parentUnderlineSpan.firstChild, parentUnderlineSpan);
                }
                grandParent.removeChild(parentUnderlineSpan);
              }
              
              // Продолжаем создание нового span (код ниже)
            } else {
              // Это вложенное выделение (меньше родителя), проверяем правила
              const parentClass = parentUnderlineSpan.classList.contains('span-participle') ? 'span-participle' :
                                 parentUnderlineSpan.classList.contains('span-gerund') ? 'span-gerund' :
                                 parentUnderlineSpan.classList.contains('span-subject') ? 'span-subject' :
                                 parentUnderlineSpan.classList.contains('span-predicate') ? 'span-predicate' : null;
              
              // Проверяем, разрешена ли эта комбинация
              const allowedCombinations = {
                'span-participle': ['span-gerund', 'span-participle'], // причастный может содержать деепричастный или причастный
                'span-gerund': ['span-participle', 'span-gerund'] // деепричастный может содержать причастный или деепричастный
              };
              
              // Если родитель - причастный или деепричастный, проверяем разрешенные комбинации
              if (parentClass === 'span-participle' || parentClass === 'span-gerund') {
                if (!allowedCombinations[parentClass].includes(className)) {
                  alert('Невозможно создать вложенный оборот: разрешены только комбинации причастный/деепричастный внутри причастного/деепричастного');
                  selection.removeAllRanges();
                  return;
                }
              } else {
                // Если родитель - подлежащее или сказуемое, вложенные обороты не разрешены
                alert('Невозможно создать вложенный оборот внутри подлежащего или сказуемого');
                selection.removeAllRanges();
                return;
              }
            }
          } else {
            // Если выделение не внутри существующего span, проверяем, содержит ли оно span с подчеркиванием
            // Проверяем, пересекается ли выделение с существующим span
            const tempRange = expandedRange.cloneRange();
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(tempRange.cloneContents());
            const existingSpans = tempDiv.querySelectorAll('.span-participle, .span-gerund, .span-subject, .span-predicate');
            
            // Если внутри выделения есть span с подчеркиванием - заменяем его
            if (existingSpans.length > 0) {
              // Находим span, который полностью находится внутри выделения
              // Проверяем все span в редакторе, которые пересекаются с выделением
              const allUnderlineSpans = editor.querySelectorAll('.span-participle, .span-gerund, .span-subject, .span-predicate');
              for (const realSpan of allUnderlineSpans) {
                // Проверяем, находится ли span полностью внутри выделения
                const spanRange = document.createRange();
                spanRange.selectNodeContents(realSpan);
                
                // Проверяем, что начало и конец span находятся внутри expandedRange
                if (expandedRange.compareBoundaryPoints(Range.START_TO_START, spanRange) <= 0 &&
                    expandedRange.compareBoundaryPoints(Range.END_TO_END, spanRange) >= 0) {
                  // Span полностью внутри выделения - заменяем его
                  const grandParent = realSpan.parentNode;
                  if (grandParent) {
                    while (realSpan.firstChild) {
                      grandParent.insertBefore(realSpan.firstChild, realSpan);
                    }
                    grandParent.removeChild(realSpan);
                  }
                  break;
                }
              }
              // Продолжаем создание нового span (код ниже)
            }
          }
        }

        // Проверяем, есть ли уже span с подчеркиванием внутри выделения
        // Если есть и мы создаем главное слово, нужно правильно обернуть, сохранив подчеркивание
        let existingUnderlinedSpan = null;
        if (className === 'span-main-word') {
          // Проверяем, есть ли внутри выделения span с подчеркиванием
          const tempRange = expandedRange.cloneRange();
          const tempDiv = document.createElement('div');
          tempDiv.appendChild(tempRange.cloneContents());
          existingUnderlinedSpan = tempDiv.querySelector('.span-participle, .span-gerund, .span-subject, .span-predicate');
        }

        const span = document.createElement('span');
        span.className = className;

        if (className === 'span-main-word') {
          // Находим следующий свободный цвет
          const usedColors = new Set();
          const textEditor = editor.closest('.task17-text-editable') || document.querySelector('.task17-text-editable');
          if (textEditor) {
            textEditor.querySelectorAll('.span-main-word[data-color-id]').forEach(el => {
              const id = el.getAttribute('data-color-id');
              if (id !== null && id !== '') {
                usedColors.add(parseInt(id));
              }
            });
          }
          
          let freeIndex = 0;
          while (usedColors.has(freeIndex) && freeIndex < COLOR_PALETTE.length) {
            freeIndex++;
          }
          
          const color = COLOR_PALETTE[freeIndex % COLOR_PALETTE.length];
          span.setAttribute('data-color-id', freeIndex);
          span.style.backgroundColor = color.bg;
          // Используем обычный border для обводки главного слова
          span.style.border = `2px solid ${color.border}`;
          span.style.borderStyle = 'solid';
          span.style.borderWidth = '2px';
          span.style.borderColor = color.border;
          // Не устанавливаем text-decoration: none - подчеркивание сохранится автоматически при оборачивании
        }

        // Пытаемся использовать surroundContents для сохранения пробелов и подчеркивания
        try {
          // Проверяем, что range не пустой и валидный
          if (expandedRange.collapsed || !expandedRange.toString().trim()) {
            alert('Не удалось создать выделение: пустое выделение');
            selection.removeAllRanges();
            return;
          }
          expandedRange.surroundContents(span);
        } catch (e) {
          // Если surroundContents не работает (range пересекает границы элементов),
          // используем extractContents с сохранением структуры
          try {
          const contents = expandedRange.extractContents();
            if (!contents || contents.childNodes.length === 0) {
              alert('Не удалось создать выделение: пустое содержимое');
              selection.removeAllRanges();
              return;
            }
          span.appendChild(contents);
          expandedRange.insertNode(span);
          } catch (extractError) {
            console.error('Ошибка при создании выделения:', extractError);
            alert('Не удалось создать выделение. Попробуйте выделить текст заново.');
            selection.removeAllRanges();
            return;
          }
        }
        
        // Сразу после оборачивания восстанавливаем подчеркивание для элементов внутри
        if (className === 'span-main-word') {
          // Убеждаемся, что цвет сохранился после вставки в DOM
          requestAnimationFrame(() => {
            const colorId = span.getAttribute('data-color-id');
            if (colorId !== null && colorId !== '') {
              const colorIndex = parseInt(colorId);
              const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
              span.style.backgroundColor = color.bg;
              // Используем обычный border для обводки главного слова
              span.style.border = `2px solid ${color.border}`;
              span.style.borderStyle = 'solid';
              span.style.borderWidth = '2px';
              span.style.borderColor = color.border;
            }
          });
          // Находим все элементы с подчеркиванием внутри только что созданного span
          const underlinedSpans = span.querySelectorAll('.span-participle, .span-gerund, .span-subject, .span-predicate');
          underlinedSpans.forEach(underlinedSpan => {
            if (underlinedSpan.classList.contains('span-subject')) {
              // Для подлежащего - сплошное подчеркивание
              underlinedSpan.style.textDecoration = 'underline';
              underlinedSpan.style.textDecorationStyle = 'solid';
              underlinedSpan.style.textDecorationThickness = '2px';
              underlinedSpan.style.textDecorationColor = 'rgba(255, 255, 255, 0.9)';
              underlinedSpan.style.textUnderlineOffset = '2px';
            } else if (underlinedSpan.classList.contains('span-predicate')) {
              // Для сказуемого - двойное подчеркивание
              underlinedSpan.style.textDecoration = 'underline';
              underlinedSpan.style.textDecorationStyle = 'double';
              underlinedSpan.style.textDecorationThickness = '2px';
              underlinedSpan.style.textDecorationColor = 'rgba(255, 255, 255, 0.9)';
              underlinedSpan.style.textUnderlineOffset = '2px';
            } else if (underlinedSpan.classList.contains('span-participle')) {
              // Для причастного оборота - волнистое подчеркивание
              underlinedSpan.style.textDecoration = 'underline';
              underlinedSpan.style.textDecorationStyle = 'wavy';
              underlinedSpan.style.textDecorationThickness = '2px';
              underlinedSpan.style.textDecorationColor = 'rgba(255, 255, 255, 0.9)';
              underlinedSpan.style.textUnderlineOffset = '2px';
            } else if (underlinedSpan.classList.contains('span-gerund')) {
              // Для деепричастного оборота - устанавливаем z-index для видимости
              underlinedSpan.style.position = 'relative';
              underlinedSpan.style.zIndex = '1';
            }
            // Для деепричастного оборота background-image должен сохраниться автоматически из CSS
          });
        }
        
        selection.removeAllRanges();
        
        // Дополнительная проверка после вставки в DOM на случай, если что-то потерялось
        if (className === 'span-main-word') {
          const colorId = span.getAttribute('data-color-id');
          // Используем requestAnimationFrame для гарантии, что DOM обновлен
          requestAnimationFrame(() => {
            // Находим span-main-word в DOM по data-color-id
            const mainWordSpan = editor.querySelector('.span-main-word[data-color-id="' + colorId + '"]');
            if (mainWordSpan) {
              // Принудительно восстанавливаем подчеркивание для всех элементов с подчеркиванием
              const underlinedSpans = mainWordSpan.querySelectorAll('.span-participle, .span-gerund, .span-subject, .span-predicate');
              underlinedSpans.forEach(underlinedSpan => {
                if (underlinedSpan.classList.contains('span-subject')) {
                  // Для подлежащего - сплошное подчеркивание
                  underlinedSpan.style.textDecoration = 'underline';
                  underlinedSpan.style.textDecorationStyle = 'solid';
                  underlinedSpan.style.textDecorationThickness = '2px';
                  underlinedSpan.style.textDecorationColor = 'rgba(255, 255, 255, 0.9)';
                  underlinedSpan.style.textUnderlineOffset = '6px'; // Увеличено для видимости поверх border
                  underlinedSpan.style.position = 'relative';
                  underlinedSpan.style.zIndex = '1';
                } else if (underlinedSpan.classList.contains('span-predicate')) {
                  // Для сказуемого - двойное подчеркивание
                  underlinedSpan.style.textDecoration = 'underline';
                  underlinedSpan.style.textDecorationStyle = 'double';
                  underlinedSpan.style.textDecorationThickness = '2px';
                  underlinedSpan.style.textDecorationColor = 'rgba(255, 255, 255, 0.9)';
                  underlinedSpan.style.textUnderlineOffset = '6px'; // Увеличено для видимости поверх border
                  underlinedSpan.style.position = 'relative';
                  underlinedSpan.style.zIndex = '1';
                } else if (underlinedSpan.classList.contains('span-participle')) {
                  // Для причастного оборота - волнистое подчеркивание
                  underlinedSpan.style.textDecoration = 'underline';
                  underlinedSpan.style.textDecorationStyle = 'wavy';
                  underlinedSpan.style.textDecorationThickness = '2px';
                  underlinedSpan.style.textDecorationColor = 'rgba(255, 255, 255, 0.9)';
                  underlinedSpan.style.textUnderlineOffset = '6px'; // Увеличено для видимости поверх border
                  underlinedSpan.style.position = 'relative';
                  underlinedSpan.style.zIndex = '1';
                } else if (underlinedSpan.classList.contains('span-gerund')) {
                  // Для деепричастного оборота - устанавливаем z-index для видимости
                  underlinedSpan.style.position = 'relative';
                  underlinedSpan.style.zIndex = '1';
                }
                // Для деепричастного оборота background-image должен сохраниться автоматически из CSS
              });
            }
          });
        }
      } catch (err) {
        console.error('Ошибка при применении стиля:', err);
      }
    }

  // Выносим функцию удаления в глобальную область
  function removeMark() {
    const selection = window.getSelection();
    if (!selection.rangeCount) {
      alert('Выделите текст для удаления отметки');
      return;
    }

    const range = selection.getRangeAt(0);
    const parent = range.commonAncestorContainer.nodeType === 3 
      ? range.commonAncestorContainer.parentElement 
      : range.commonAncestorContainer;

    if (parent && (parent.classList.contains('span-participle') || 
                   parent.classList.contains('span-gerund') || 
                   parent.classList.contains('span-main-word') ||
                   parent.classList.contains('span-subject') ||
                   parent.classList.contains('span-predicate'))) {
      const grandParent = parent.parentNode;
      if (grandParent) {
      const textNode = document.createTextNode(parent.textContent);
        grandParent.replaceChild(textNode, parent);
      selection.removeAllRanges();
      } else {
        alert('Ошибка: не удалось найти родительский элемент');
      }
    } else {
      alert('Выделите текст с отметкой для удаления');
    }
  }

  setTimeout(() => {
    initFloatingToolbar();
  }, 500);

  // Инициализация плавающей панели инструментов через переиспользуемый модуль
  let textSelectionToolbar = null;
  let floatingToolbar = null; // Сохраняем для обратной совместимости
  
  function initFloatingToolbar() {
    // Используем переиспользуемый модуль
    textSelectionToolbar = new TextSelectionToolbar({
      containerId: 'task17-floating-toolbar',
      editorSelector: '.task17-text-editable',
      ignoreSelectors: ['.task17-digit'],
      defaultButtons: true,
      onButtonClick: (buttonConfig, savedRange, selection) => {
        // Используем глобальную функцию applySpanClass
        if (buttonConfig.class && typeof window.applySpanClass === 'function') {
          window.applySpanClass(buttonConfig.class);
        }
      },
      onRemoveClick: (savedRange, selection) => {
        // Используем глобальную функцию removeMark
        if (typeof window.removeMark === 'function') {
          window.removeMark();
        }
      }
    });
    
    floatingToolbar = document.getElementById('task17-floating-toolbar');
    if (!floatingToolbar) return;
    
    // Сохраняем старую функцию showToolbar для обратной совместимости
    const showToolbar = (range) => {
      if (!textSelectionToolbar) return;
      
      // Проверяем, является ли выделение главным словом (специфичная логика для task17)
      const isMainWord = range.commonAncestorContainer.nodeType === 1 
        ? range.commonAncestorContainer.classList.contains('span-main-word')
        : range.commonAncestorContainer.parentElement?.classList.contains('span-main-word');
      
      const mainWordElement = isMainWord 
        ? (range.commonAncestorContainer.nodeType === 1 
            ? range.commonAncestorContainer 
            : range.commonAncestorContainer.parentElement)
        : null;
      
      // Показываем панель через модуль
      textSelectionToolbar.show(range, {
        showRemoveButton: true
      });
    };
    
    // Делаем функцию доступной глобально для обратной совместимости
    window.showToolbar = showToolbar;
    
    // Настраиваем автоматический показ панели (модуль сам обработает mouseup)
    // Но нам нужно добавить специфичную логику для кликов на уже выделенные элементы
    textSelectionToolbar.setupAutoShow();

    // Обработчик клика на уже выделенные элементы - показывает панель
    function setupClickOnMarks() {
      document.querySelectorAll('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word').forEach(mark => {
        if (mark.dataset.clickSetup) return; // Уже настроено
        mark.dataset.clickSetup = 'true';
        
        // Используем click, но проверяем, не выделяется ли текст
        mark.addEventListener('click', function(e) {
          // Если режим связывания активен и клик по обороту - не показываем панель (обработает initMainWordColorSelection)
          if (typeof isLinkingMode !== 'undefined' && isLinkingMode && 
              (this.classList.contains('span-participle') || this.classList.contains('span-gerund'))) {
            // Не блокируем событие, чтобы initMainWordColorSelection мог обработать связывание
            return;
          }
          
          // Проверяем, есть ли выделение текста - если есть, значит пользователь выделял, а не кликал
          const selection = window.getSelection();
          if (selection.toString().trim().length > 0 && !selection.isCollapsed) {
            // Есть выделение - это не простой клик, не показываем панель
            return;
          }
          
          // Проверяем, не кликнули ли мы на вложенный элемент внутри другого выделенного элемента
          // Если клик был на вложенном элементе, не обрабатываем клик на внешнем
          const clickedElement = e.target.closest('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word');
          if (clickedElement && clickedElement !== this) {
            // Клик был на вложенном элементе, не обрабатываем внешний
            return;
          }
          
          // Если клик по главному слову
          if (this.classList.contains('span-main-word')) {
            // Если режим связывания уже активен для этого слова - второй клик показывает панель
            if (typeof isLinkingMode !== 'undefined' && isLinkingMode && selectedMainWord === this) {
            e.preventDefault();
            e.stopPropagation();
            
            // Создаем range для выделенного элемента
            const range = document.createRange();
            range.selectNodeContents(this);
            
            // Показываем панель над этим элементом
            showToolbar(range);
              return;
            }
            
            // Если режим связывания не активен - первый клик открывает режим связывания
            e.preventDefault();
            e.stopPropagation();
            
            // Закрываем панель, если она открыта
            const toolbar = document.getElementById('task17-floating-toolbar');
            if (toolbar) {
              toolbar.classList.remove('show');
            }
            
            // Включаем режим связывания
            if (typeof window.activateLinkingMode === 'function') {
              window.activateLinkingMode(this);
            } else if (typeof activateLinkingMode === 'function') {
              activateLinkingMode(this);
            }
            return;
          }
          
          // Для остальных элементов - показываем панель
          e.preventDefault();
          e.stopPropagation();
          
          // Создаем range для выделенного элемента (только для этого элемента, не для родительских)
          const range = document.createRange();
          range.selectNodeContents(this);
          
          // Показываем панель над этим элементом - вызываем функцию showToolbar
          showToolbar(range);
        }, true); // Используем capture phase, чтобы сработать раньше других обработчиков
      });
    }

    // Наблюдаем за появлением новых выделений
    const markClickObserver = new MutationObserver(() => {
      setupClickOnMarks();
    });

    markClickObserver.observe(document.body, {
      childList: true,
      subtree: true
    });

    // Устанавливаем для существующих элементов
    setupClickOnMarks();

    // Скрываем панель при клике вне выделения и панели
    document.addEventListener('mousedown', (e) => {
      // Не скрываем панель, если клик по выделенному элементу или панели
      if (e.target.closest('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word')) {
        return;
      }
      
      if (floatingToolbar && !floatingToolbar.contains(e.target)) {
        // Небольшая задержка, чтобы дать время onclick сработать
        setTimeout(() => {
          if (floatingToolbar && !floatingToolbar.contains(document.activeElement)) {
            floatingToolbar.classList.remove('show');
          }
        }, 200); // Увеличиваем задержку, чтобы дать время обработчику клика сработать
      }
    });
  }

  // Функция для применения цветов в объяснении
  function applyColorsInExplanation() {
    // Применяем цвет к элементу
    function applyColor(element, color) {
      element.style.backgroundColor = color.bg;
      element.style.borderColor = color.border;
      if (element.classList.contains('span-main-word')) {
        element.style.borderWidth = '2px';
        element.style.borderStyle = 'solid';
      } else {
        // Для оборотов - только фон, текст остается белым
        element.style.color = 'var(--text-primary)';
      }
    }
    
    // Находим все объяснения на странице
    const allExplanations = document.querySelectorAll('.task17-explanation-content');
    
    allExplanations.forEach(explanationDiv => {
      // Находим все главные слова с data-color-id
      const mainWords = explanationDiv.querySelectorAll('.span-main-word[data-color-id]');
      
      mainWords.forEach((mainWord) => {
        const colorId = mainWord.getAttribute('data-color-id');
        if (!colorId || colorId === '') return;
        
        const colorIndex = parseInt(colorId);
        const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
        
        // Применяем цвет к главному слову
        applyColor(mainWord, color);
        
        // Применяем цвет ко всем связанным оборотам
        const linkedTurns = explanationDiv.querySelectorAll(`[data-linked-to="${colorId}"]`);
        linkedTurns.forEach(turn => {
          applyColor(turn, color);
        });
      });
    });
  }
  
  // Делаем функцию доступной глобально
  window.applyColorsInExplanation = applyColorsInExplanation;

  // Глобальные переменные для режима связывания
  let selectedMainWord = null;
  let isLinkingMode = false;

  // Функционал для выбора цвета главного слова и связывания с оборотами
  function initMainWordColorSelection() {
    // Используем глобальную константу COLOR_PALETTE

    // Применяем цвет к элементу
    function applyColor(element, color) {
      element.style.backgroundColor = color.bg;
      if (element.classList.contains('span-main-word')) {
        // Используем обычный border для обводки главного слова
        element.style.border = `2px solid ${color.border}`;
        element.style.borderStyle = 'solid';
        element.style.borderWidth = '2px';
        element.style.borderColor = color.border;
      } else {
        // Для оборотов - только фон, без обводки, текст остается белым
        element.style.color = 'var(--text-primary)'; // Оставляем белый цвет текста
        element.style.borderWidth = '0';
        element.style.borderStyle = 'none';
      }
    }

    // Удаляем цвет с элемента
    function removeColor(element) {
      element.style.backgroundColor = '';
      element.style.color = '';
      if (element.classList.contains('span-main-word')) {
        element.style.border = '';
        element.style.borderStyle = '';
        element.style.borderWidth = '';
        element.style.borderColor = '';
        element.style.outline = '';
      }
    }

    // Получаем цвет для главного слова
    function getColorForMainWord(mainWord) {
      const colorId = mainWord.getAttribute('data-color-id');
      if (colorId !== null && colorId !== '') {
        const index = parseInt(colorId);
        return { index: index, color: COLOR_PALETTE[index % COLOR_PALETTE.length] };
      }
      // Если цвета нет, находим следующий свободный
      const usedColors = new Set();
      document.querySelectorAll('.task17-text-editable .span-main-word[data-color-id]').forEach(el => {
        const id = el.getAttribute('data-color-id');
        if (id !== null && id !== '') {
          usedColors.add(parseInt(id));
        }
      });
      
      let freeIndex = 0;
      while (usedColors.has(freeIndex) && freeIndex < COLOR_PALETTE.length) {
        freeIndex++;
      }
      
      return { index: freeIndex, color: COLOR_PALETTE[freeIndex % COLOR_PALETTE.length] };
    }

    // Назначаем цвет главному слову автоматически
    function assignColorToMainWord(mainWord) {
      // Получаем или назначаем цвет
      const colorData = getColorForMainWord(mainWord);
      
      // Применяем цвет к главному слову
      mainWord.setAttribute('data-color-id', colorData.index);
      applyColor(mainWord, colorData.color);
    }
    
    // Активируем режим связывания для главного слова
    function activateLinkingMode(mainWord) {
      // Убеждаемся, что у главного слова есть цвет
      let colorId = mainWord.getAttribute('data-color-id');
      if (!colorId || colorId === '') {
        assignColorToMainWord(mainWord);
        colorId = mainWord.getAttribute('data-color-id');
      } else {
        // ВСЕГДА восстанавливаем цвет явно, чтобы гарантировать его наличие
        const colorIndex = parseInt(colorId);
        const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
        applyColor(mainWord, color);
      }
      
      // Если уже был активен режим для другого слова - отменяем его
      if (isLinkingMode && selectedMainWord && selectedMainWord !== mainWord) {
        if (typeof window.cancelLinkingMode === 'function') {
          window.cancelLinkingMode();
        }
      }
      
      // Включаем режим связывания
      selectedMainWord = mainWord;
      isLinkingMode = true;
      mainWord.style.outline = '3px solid rgba(236, 72, 153, 0.8)';
      mainWord.style.outlineOffset = '2px';
      
      // Настраиваем подсветку оборотов при наведении
      setTimeout(() => {
        if (typeof window.setupLinkingModeHover === 'function') {
          window.setupLinkingModeHover();
        }
      }, 100);
    }

    // Связываем оборот с главным словом
    function linkTurnToMainWord(mainWord, turn) {
      const colorId = mainWord.getAttribute('data-color-id');
      if (!colorId || colorId === '') return;

      const colorIndex = parseInt(colorId);
      const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];

      // Применяем цвет к обороту
      applyColor(turn, color);
      turn.setAttribute('data-linked-to', colorId);
      
      // Визуальная обратная связь - кратковременная анимация
      turn.style.transform = 'scale(1.05)';
      turn.style.transition = 'transform 0.2s ease';
      setTimeout(() => {
        turn.style.transform = '';
      }, 200);
      
      // Дополнительно восстанавливаем цвет через requestAnimationFrame для гарантии сохранения
      requestAnimationFrame(() => {
        if (turn.getAttribute('data-linked-to') === colorId) {
          applyColor(turn, color);
        }
      });
      
      // Автоматически выключаем режим связывания после назначения зависимого оборота
      if (typeof window.cancelLinkingMode === 'function') {
        window.cancelLinkingMode();
      }
    }
    
    // Показываем подсказку режима связывания
    function showLinkingModeHint() {
      // Удаляем предыдущую подсказку, если есть
      const existingHint = document.getElementById('linking-mode-hint');
      if (existingHint) {
        existingHint.remove();
      }
      
      const hint = document.createElement('div');
      hint.id = 'linking-mode-hint';
      hint.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-tertiary);
        border: 2px solid rgba(236, 72, 153, 0.8);
        border-radius: 8px;
        padding: 12px 20px;
        color: var(--text-primary);
        font-size: 14px;
        z-index: 10001;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 20px rgba(236, 72, 153, 0.3);
        display: flex;
        align-items: center;
        gap: 12px;
        animation: slideDown 0.3s ease;
      `;
      hint.innerHTML = `
        <span>Режим связывания: кликните на оборот для связи с главным словом</span>
        <button id="cancel-linking-btn" style="
          background: rgba(239, 68, 68, 0.3);
          border: 1px solid rgba(239, 68, 68, 0.8);
          color: var(--text-primary);
          padding: 4px 12px;
          border-radius: 4px;
          cursor: pointer;
          font-size: 12px;
        ">Отмена (ESC)</button>
      `;
      document.body.appendChild(hint);
      
      // Обработчик кнопки отмены
      const cancelBtn = hint.querySelector('#cancel-linking-btn');
      cancelBtn.onclick = () => {
        cancelLinkingMode();
      };
    }
    
    // Отменяем режим связывания
    function cancelLinkingMode() {
      if (selectedMainWord) {
        // Сохраняем ссылку на главное слово для восстановления цвета
        const mainWordRef = selectedMainWord;
        const colorId = mainWordRef.getAttribute('data-color-id');
        
        // Убираем только outline (розовую обводку режима связывания)
        selectedMainWord.style.outline = '';
        selectedMainWord.style.outlineOffset = '';
        
        // ВСЕГДА восстанавливаем цвет и обводку главного слова явно
        if (colorId && colorId !== '') {
          const colorIndex = parseInt(colorId);
          const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
          // Применяем цвет заново, чтобы гарантировать его сохранение
          applyColor(mainWordRef, color);
          
          // Дополнительно восстанавливаем через requestAnimationFrame для гарантии
          requestAnimationFrame(() => {
            if (mainWordRef.getAttribute('data-color-id') === colorId) {
              applyColor(mainWordRef, color);
            }
          });
        }
        
        selectedMainWord = null;
      }
      isLinkingMode = false;
      
      // Убираем подсветку с оборотов
      removeLinkingModeHover();
    }

    // Обработчик клика на главное слово для режима связывания
    document.addEventListener('click', (e) => {
      // Если режим связывания активен и клик по обороту
      if (isLinkingMode && selectedMainWord) {
        const turn = e.target.closest('.span-participle, .span-gerund');
        if (turn) {
          e.preventDefault();
          e.stopPropagation();
          linkTurnToMainWord(selectedMainWord, turn);
          // Режим автоматически выключится в linkTurnToMainWord
          return;
        }
      }

      // Проверяем, что клик по главному слову
      const mainWord = e.target.closest('.span-main-word');
      if (mainWord) {
        // Проверяем, есть ли выделение текста - если есть, не обрабатываем
        const selection = window.getSelection();
        if (selection.toString().trim().length > 0 && !selection.isCollapsed) {
          return;
        }
        
        // Если режим связывания активен и клик по другому главному слову - переключаем режим
        if (isLinkingMode && selectedMainWord && mainWord !== selectedMainWord) {
          e.preventDefault();
          e.stopPropagation();
          if (typeof window.activateLinkingMode === 'function') {
            window.activateLinkingMode(mainWord);
          } else if (typeof activateLinkingMode === 'function') {
            activateLinkingMode(mainWord);
          }
          return;
        }
        
        // Если клик по тому же главному слову в режиме связывания - показываем панель
        // (это обрабатывается в setupClickOnMarks, но на всякий случай проверяем здесь тоже)
        if (isLinkingMode && selectedMainWord === mainWord) {
          // Не блокируем событие, чтобы setupClickOnMarks мог обработать показ панели
          return;
        }
      }
      
      // Если режим связывания активен и клик вне элементов - не отменяем (позволяем связать несколько оборотов)
      // Отмена только через ESC или кнопку
    }, false); // Используем bubble phase
    
    // Обработчик ESC для отмены режима связывания
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && isLinkingMode) {
        if (typeof window.cancelLinkingMode === 'function') {
          window.cancelLinkingMode();
        }
      }
    });
    
    // Подсветка оборотов при наведении в режиме связывания
    let hoverHandlers = new WeakMap();
    function setupLinkingModeHover() {
      if (!isLinkingMode || !selectedMainWord) return;
      
      const colorId = selectedMainWord.getAttribute('data-color-id');
      if (!colorId) return;
      
      const colorIndex = parseInt(colorId);
      const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
      
      document.querySelectorAll('.span-participle, .span-gerund').forEach(turn => {
        // Пропускаем уже связанные обороты
        if (turn.getAttribute('data-linked-to') === colorId) {
          return;
        }
        
        // Удаляем старые обработчики, если есть
        const existingHandlers = hoverHandlers.get(turn);
        if (existingHandlers) {
          turn.removeEventListener('mouseenter', existingHandlers.enter);
          turn.removeEventListener('mouseleave', existingHandlers.leave);
        }
        
        turn.style.cursor = 'pointer';
        turn.style.transition = 'all 0.2s ease';
        
        const enterHandler = function() {
          if (isLinkingMode && this.getAttribute('data-linked-to') !== colorId) {
            this.style.backgroundColor = color.bg;
            this.style.opacity = '0.8';
          }
        };
        
        const leaveHandler = function() {
          if (this.getAttribute('data-linked-to') !== colorId) {
            this.style.backgroundColor = '';
            this.style.opacity = '';
          }
        };
        
        turn.addEventListener('mouseenter', enterHandler);
        turn.addEventListener('mouseleave', leaveHandler);
        
        // Сохраняем обработчики для последующего удаления
        hoverHandlers.set(turn, { enter: enterHandler, leave: leaveHandler });
      });
    }
    
    // Удаляем обработчики при выходе из режима связывания
    function removeLinkingModeHover() {
      document.querySelectorAll('.span-participle, .span-gerund').forEach(turn => {
        const handlers = hoverHandlers.get(turn);
        if (handlers) {
          turn.removeEventListener('mouseenter', handlers.enter);
          turn.removeEventListener('mouseleave', handlers.leave);
          hoverHandlers.delete(turn);
        }
        turn.style.cursor = '';
        turn.style.opacity = '';
        
        // НЕ удаляем цвет у уже связанных оборотов (которые имеют data-linked-to)
        // Удаляем только временную подсветку при наведении
        const linkedTo = turn.getAttribute('data-linked-to');
        if (!linkedTo || linkedTo === '') {
          // Если оборот не связан, убираем временную подсветку
          turn.style.backgroundColor = '';
        } else {
          // Если оборот связан, восстанавливаем его цвет из главного слова
          const colorId = linkedTo;
          const colorIndex = parseInt(colorId);
          const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
          applyColor(turn, color);
        }
      });
    }
    
    // Делаем функции доступными глобально
    window.showLinkingModeHint = showLinkingModeHint;
    window.cancelLinkingMode = cancelLinkingMode;
    window.setupLinkingModeHover = setupLinkingModeHover;
    window.removeLinkingModeHover = removeLinkingModeHover;
    window.activateLinkingMode = activateLinkingMode;
  }

  // Устанавливаем подсветку при наведении в тон цвета главного слова
  function setupMainWordHoverGlow() {
    const processedElements = new WeakSet();

    function setupGlowForElement(mainWord) {
      if (processedElements.has(mainWord)) return;
      processedElements.add(mainWord);

      // Получаем цвет из CSS переменной (теперь используется для псевдоэлемента)
      let borderColor = null;
      const cssVar = getComputedStyle(mainWord).getPropertyValue('--main-word-border-color').trim();
      if (cssVar && cssVar !== 'transparent') {
        borderColor = cssVar;
      }
      
      // Для обратной совместимости проверяем outline, borderColor и boxShadow
      if (!borderColor) {
        const outline = mainWord.style.outline;
        if (outline) {
          const match = outline.match(/rgba?\([^)]+\)/);
          if (match) {
            borderColor = match[0];
          }
        }
      }
      if (!borderColor) {
        borderColor = mainWord.style.borderColor;
      }
      if (!borderColor) {
        const boxShadow = mainWord.style.boxShadow;
        if (boxShadow && boxShadow.includes('inset')) {
          const match = boxShadow.match(/rgba?\([^)]+\)/);
          if (match) {
            borderColor = match[0];
          }
        }
      }
      
      if (borderColor) {
        // Преобразуем цвет в rgba для свечения
        let glowColor = borderColor;
        if (glowColor.startsWith('rgb(')) {
          glowColor = glowColor.replace('rgb(', 'rgba(').replace(')', ', 0.6)');
        } else if (glowColor.startsWith('rgba(')) {
          glowColor = glowColor.replace(/,\s*[\d.]+\)$/, ', 0.6)');
        }

        let glowColorInner = borderColor;
        if (glowColorInner.startsWith('rgb(')) {
          glowColorInner = glowColorInner.replace('rgb(', 'rgba(').replace(')', ', 0.4)');
        } else if (glowColorInner.startsWith('rgba(')) {
          glowColorInner = glowColorInner.replace(/,\s*[\d.]+\)$/, ', 0.4)');
        }

        mainWord.addEventListener('mouseenter', function() {
          // Сохраняем текущий outline и добавляем свечение через box-shadow
          const currentOutline = this.style.outline || '';
          this.style.boxShadow = `0 0 12px ${glowColor}, 0 0 6px ${glowColorInner}`;
        });
        mainWord.addEventListener('mouseleave', function() {
          // Убираем свечение, outline остается
          this.style.boxShadow = '';
        });
      }
    }

    const observer = new MutationObserver(() => {
      document.querySelectorAll('.span-main-word').forEach(setupGlowForElement);
    });

    // Наблюдаем за изменениями в DOM
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['style', 'data-color-id']
    });

    // Устанавливаем для существующих элементов
    setTimeout(() => {
      document.querySelectorAll('.span-main-word').forEach(setupGlowForElement);
    }, 100);
  }

  // Функционал для удаления выделений (отключен)
  /* function initMarkRemoval() {
    let deleteButton = null;
    let currentMark = null;

    // Создаем кнопку удаления
    function createDeleteButton() {
      if (deleteButton) return deleteButton;
      
      deleteButton = document.createElement('button');
      deleteButton.innerHTML = '🗑';
      deleteButton.className = 'task17-delete-mark-btn';
      deleteButton.style.cssText = `
        position: absolute;
        display: none;
        padding: 6px;
        font-size: 14px;
        border-radius: 6px;
        border: 1px solid rgba(239, 68, 68, 0.5);
        background: rgba(239, 68, 68, 0.2);
        color: #f87171;
        cursor: pointer;
        z-index: 10002;
        transition: all 0.2s;
        box-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
      `;
      deleteButton.onmouseenter = () => {
        deleteButton.style.background = 'rgba(239, 68, 68, 0.3)';
        deleteButton.style.borderColor = '#f87171';
      };
      deleteButton.onmouseleave = () => {
        deleteButton.style.background = 'rgba(239, 68, 68, 0.2)';
        deleteButton.style.borderColor = 'rgba(239, 68, 68, 0.5)';
      };
      deleteButton.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (currentMark && currentMark.parentNode) {
          // Удаляем выделение
          const textNode = document.createTextNode(currentMark.textContent);
          currentMark.parentNode.replaceChild(textNode, currentMark);
          hideDeleteButton();
        }
      };
      document.body.appendChild(deleteButton);
      return deleteButton;
    }

    // Показываем кнопку удаления
    function showDeleteButton(mark, event) {
      const button = createDeleteButton();
      currentMark = mark;
      
      const rect = mark.getBoundingClientRect();
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

      button.style.top = (rect.top + scrollTop - 35) + 'px';
      button.style.left = (rect.left + scrollLeft + rect.width / 2 - 15) + 'px';
      button.style.display = 'block';
      
      // Добавляем обработчики для кнопки, чтобы она не скрывалась при наведении
      button.addEventListener('mouseenter', () => {
        // Кнопка остается видимой
      });
      button.addEventListener('mouseleave', () => {
        hideDeleteButton();
      });
    }

    // Скрываем кнопку удаления
    function hideDeleteButton() {
      if (deleteButton && !deleteButton.matches(':hover')) {
        deleteButton.style.display = 'none';
        currentMark = null;
      }
    }

    // Устанавливаем обработчики наведения для всех выделений
    function setupHoverForMarks() {
      document.querySelectorAll('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word').forEach(mark => {
        if (mark.dataset.hoverSetup) return; // Уже настроено
        mark.dataset.hoverSetup = 'true';
        
        mark.addEventListener('mouseenter', (e) => {
          // Если наведение на главное слово и режим связывания активен - не показываем корзину
          if (mark.classList.contains('span-main-word') && isLinkingMode) {
            return;
          }
          showDeleteButton(mark, e);
        });
        
        mark.addEventListener('mouseleave', (e) => {
          // Небольшая задержка, чтобы можно было навести на кнопку
          setTimeout(() => {
            if (!deleteButton || (!deleteButton.matches(':hover') && e.relatedTarget !== deleteButton)) {
              hideDeleteButton();
            }
          }, 100);
        });
      });
    }

    // Наблюдаем за появлением новых выделений
    const markObserver = new MutationObserver(() => {
      setupHoverForMarks();
    });

    markObserver.observe(document.body, {
      childList: true,
      subtree: true
    });

    // Устанавливаем для существующих элементов
    setupHoverForMarks();

    // Скрываем кнопку при клике вне выделения
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word, .task17-delete-mark-btn')) {
        hideDeleteButton();
      }
    });

    // Скрываем кнопку при скролле
    window.addEventListener('scroll', hideDeleteButton);
  } */

  // Инициализируем после загрузки
  setTimeout(() => {
    initMainWordColorSelection();
    setupMainWordHoverGlow();
  }, 500);
</script>


