<div class="task-page" id="task17App">
  <h2 class="task-page__title">Задание №17: Пунктуация</h2>
  
  <!-- Панель инструментов слева для выделений в предложении (sticky) -->
  <div id="task17-toolbar-left" class="task17-student-toolbar-left" style="
    position: fixed;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 200px;
    padding: 16px;
    background: var(--bg-tertiary);
    border-radius: var(--radius-lg);
    border: 1px solid var(--glass-border);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    display: block;
  ">
    <div style="margin-bottom: 12px; color: var(--text-primary); font-weight: 600; font-size: 14px;">
      Инструменты выделения
    </div>
    
    <div style="display: flex; flex-direction: column; gap: 8px;">
      <button type="button" class="btn btn-sm" id="task17-mark-participle-text" style="width: 100%; justify-content: flex-start;">
        <span style="text-decoration: underline wavy;">Причастный</span>
      </button>
      <button type="button" class="btn btn-sm" id="task17-mark-gerund-text" style="width: 100%; justify-content: flex-start;">
        Деепричастный
      </button>
      <button type="button" class="btn btn-sm" id="task17-mark-main-word-text" style="width: 100%; justify-content: flex-start; border: 1px solid rgba(236, 72, 153, 0.5);">
        Главное слово
      </button>
      <button type="button" class="btn btn-sm btn-secondary" id="task17-remove-mark-text" style="width: 100%; justify-content: flex-start;">
        Убрать выделение
      </button>
    </div>
    
    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--glass-border); font-size: 11px; color: var(--text-secondary); line-height: 1.6;">
      <div style="margin-bottom: 6px;"><span class="span-participle" style="display: inline-block;">Причастный</span></div>
      <div style="margin-bottom: 6px;"><span class="span-gerund" style="display: inline-block; position: relative; padding-bottom: 2px;">Деепричастный</span></div>
      <div><span class="span-main-word" style="display: inline-block; position: relative;">Главное слово</span></div>
    </div>
  </div>
  
  <!-- Плавающая панель инструментов выделения -->
  <div id="task17-floating-toolbar" class="task17-floating-toolbar">
    <!-- Кнопки будут добавлены динамически -->
  </div>
  
  <div id="task17Container">
    <div style="padding: 20px;">
      <p>Загрузка заданий...</p>
    </div>
  </div>
</div>

<style>
  /* Стили для отображения объяснения с подчеркиваниями */
  .task-page .span-participle,
  .task-page .span-gerund {
    position: relative;
  }
  
  .task-page .span-participle {
    text-decoration: underline;
    text-decoration-style: wavy;
    text-decoration-color: rgba(168, 85, 247, 0.8);
  }
  
  /* Стили для кликабельных цифр в задании №17 */
  .task17-digit {
    cursor: pointer;
    padding: 1px 4px;
    margin: 0 1px;
    border-radius: 4px;
    transition: all 0.2s;
    display: inline-block;
    position: relative;
  }
  
  .task17-digit:hover:not(.selected) {
    background-color: rgba(0, 240, 255, 0.2);
    box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
  }
  
  .task17-digit.selected {
    background-color: var(--neon-cyan);
    color: var(--bg-primary);
    font-weight: bold;
  }

  /* Стили для кликабельных пробелов в режиме без цифр */
  .task17-space {
    cursor: pointer !important;
    display: inline !important; /* Используем inline для нормального распределения */
    padding: 0 !important;
    margin: 0 !important;
    border-radius: 3px;
    transition: all 0.2s ease;
    position: relative;
    user-select: none !important;
    -webkit-user-select: none !important;
    pointer-events: auto !important;
    background-color: transparent !important;
    vertical-align: baseline;
    border: none !important;
    z-index: 10;
  }

  .task17-space:hover {
    background-color: rgba(0, 240, 255, 0.25) !important;
    box-shadow: 0 0 10px rgba(0, 240, 255, 0.5) !important;
    outline: 1px solid rgba(0, 240, 255, 0.7) !important;
    outline-offset: -1px;
    /* Не меняем padding и margin, чтобы не было дрожания */
  }

  .task17-space:active {
    background-color: rgba(0, 240, 255, 0.35) !important;
  }

  .task17-space-with-comma:hover {
    background-color: rgba(0, 240, 255, 0.4) !important;
    box-shadow: 0 0 12px rgba(0, 240, 255, 0.7) !important;
  }
</style>

<!-- React через CDN -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">
  const { useState, useEffect, useRef } = React;

  // Общая функция для парсинга текста с метками (1), (2)...
  function parseTextWithDigits(text) {
    const parts = [];
    const regex = /\((\d+)\)/g;
    let lastIndex = 0;
    let match;

    while ((match = regex.exec(text)) !== null) {
      if (match.index > lastIndex) {
        parts.push({ text: text.substring(lastIndex, match.index), digit: null });
      }
      const digitNum = parseInt(match[1], 10);
      parts.push({ text: match[0], digit: digitNum });
      lastIndex = match.index + match[0].length;
    }

    if (lastIndex < text.length) {
      parts.push({ text: text.substring(lastIndex), digit: null });
    }

    return parts;
  }

  // Функция для парсинга текста с пробелами (для режима без цифр)
  // НОВАЯ ЛОГИКА: использует порядковые индексы пробелов (0, 1, 2, 3...) вместо позиций в тексте
  // Это делает индексы независимыми от пробелов и лишних запятых
  function parseTextWithSpaces(text, correctCommaPositions = null) {
    const parts = [];
    
    if (!text || text.length === 0) {
      return parts;
    }
    
    // Нормализуем текст перед парсингом (убираем множественные пробелы)
    const normalizedText = text.replace(/\s+/g, ' ').trim();
    
    // Преобразуем correctCommaPositions в Set для быстрой проверки
    // НОВАЯ ЛОГИКА: correctCommaPositions содержит индексы пробелов (0, 1, 2...), а не позиции в тексте
    // Это делает индексы независимыми от пробелов и лишних запятых
    const correctCommasSet = correctCommaPositions ? new Set(correctCommaPositions.map(p => Number(p))) : null;
    
    // Разбиваем текст на слова и пробелы, используя порядковые индексы пробелов
    // ВАЖНО: проходим по каждому символу и гарантируем, что все символы попадут в parts
    let currentOffset = 0;
    let spaceIndex = 0; // Порядковый номер пробела (0, 1, 2, 3...)
    
    // Обрабатываем случай, когда текст начинается с пробела
    if (normalizedText.length > 0 && normalizedText[0] === ' ') {
      parts.push({ 
        text: ' ', 
        isClickable: true,
        spaceIndex: spaceIndex, // Используем порядковый индекс вместо позиции
        showCorrectComma: correctCommasSet && correctCommasSet.has(spaceIndex)
      });
      currentOffset = 1;
      spaceIndex++;
    }
    
    for (let i = currentOffset; i < normalizedText.length; i++) {
      if (normalizedText[i] === ' ') {
        // Добавляем текст до пробела (если есть)
        if (i > currentOffset) {
          const textPart = normalizedText.substring(currentOffset, i);
          // ВАЖНО: добавляем только непустые части
          if (textPart.length > 0) {
            parts.push({ 
              text: textPart, 
              isClickable: false,
              spaceIndex: null
            });
          }
        }
        
        // Проверяем, нужно ли показать правильную запятую на этом пробеле
        const shouldShowCorrectComma = correctCommasSet && correctCommasSet.has(spaceIndex);
        
        // Пробел - кликабельный элемент с порядковым индексом
        parts.push({ 
          text: ' ', 
          isClickable: true,
          spaceIndex: spaceIndex, // Используем порядковый индекс вместо позиции
          showCorrectComma: shouldShowCorrectComma
        });
        currentOffset = i + 1;
        spaceIndex++;
      }
    }
    
    // ВАЖНО: добавляем оставшийся текст после последнего пробела
    if (currentOffset < normalizedText.length) {
      const textPart = normalizedText.substring(currentOffset);
      // Добавляем только непустые части
      if (textPart.length > 0) {
        parts.push({ 
          text: textPart, 
          isClickable: false,
          spaceIndex: null
        });
      }
    }
    
    // Проверка: убеждаемся, что весь текст покрыт частями
    const totalLength = parts.reduce((sum, part) => {
      const partLength = part.text ? part.text.length : 0;
      return sum + partLength;
    }, 0);
    
    // Восстанавливаем текст из parts для проверки
    const reconstructedText = parts.map(p => p.text || '').join('');
    
    if (totalLength !== normalizedText.length || reconstructedText !== normalizedText) {
      console.error('[parseTextWithSpaces] КРИТИЧЕСКАЯ ОШИБКА: ТЕКСТ НЕ СОВПАДАЕТ!', {
        totalLength,
        normalizedTextLength: normalizedText.length,
        difference: normalizedText.length - totalLength,
        reconstructedText: reconstructedText,
        textsMatch: reconstructedText === normalizedText,
        parts: parts.map((p, idx) => ({ 
          idx,
          text: p.text || '', 
          length: p.text?.length || 0,
          isClickable: p.isClickable,
          spaceIndex: p.spaceIndex
        })),
        normalizedText: normalizedText,
        normalizedTextChars: normalizedText.split('').map((c, i) => ({ i, char: c }))
      });
      
      // Пытаемся исправить: если текст не совпадает, возвращаем простой вариант
      // где каждый символ - отдельная часть (на случай критической ошибки)
      if (reconstructedText !== normalizedText) {
        console.warn('[parseTextWithSpaces] Пытаемся восстановить через простой парсинг');
        const simpleParts = [];
        let simpleSpaceIndex = 0;
        for (let i = 0; i < normalizedText.length; i++) {
          if (normalizedText[i] === ' ') {
            simpleParts.push({
              text: ' ',
              isClickable: true,
              spaceIndex: simpleSpaceIndex,
              showCorrectComma: correctCommasSet && correctCommasSet.has(simpleSpaceIndex)
            });
            simpleSpaceIndex++;
          } else {
            // Объединяем последовательные не-пробелы в одну часть
            let wordStart = i;
            while (i < normalizedText.length && normalizedText[i] !== ' ') {
              i++;
            }
            i--; // Откатываем на один символ назад
            const word = normalizedText.substring(wordStart, i + 1);
            if (word.length > 0) {
              simpleParts.push({
                text: word,
                isClickable: false,
                spaceIndex: null
              });
            }
          }
        }
        return simpleParts;
      }
    }
    
    return parts;
  }

  // Компонент для одного задания
  function Task17Item({ task, index, showDigits }) {
    const [currentMode, setCurrentMode] = useState('digits');
    const [taskData, setTaskData] = useState(null);
    const [selectedDigits, setSelectedDigits] = useState(new Set());
    const [commaPositions, setCommaPositions] = useState(new Set()); // Позиции запятых в commaless_text
    const [answerInput, setAnswerInput] = useState('');
    const [checkResult, setCheckResult] = useState(null);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    const [isLiked, setIsLiked] = useState(false);
    const [showSolution, setShowSolution] = useState(false);
    const [correctDigits, setCorrectDigits] = useState(new Set());
    const [correctCommaPositions, setCorrectCommaPositions] = useState(new Set()); // Правильные позиции запятых
    const [extraCommaPositions, setExtraCommaPositions] = useState(new Set()); // Лишние позиции запятых
    const inputRef = useRef(null);

    // Обновляем режим при изменении showDigits
    useEffect(() => {
      setCurrentMode(showDigits ? 'digits' : 'commas');
      setCommaPositions(new Set()); // Сбрасываем позиции запятых при смене режима
      setSelectedDigits(new Set()); // Сбрасываем выбранные цифры
      setCorrectCommaPositions(new Set()); // Сбрасываем правильные позиции
      setExtraCommaPositions(new Set()); // Сбрасываем лишние позиции
      setAnswerInput('');
    }, [showDigits]);

    // Загружаем задание
    useEffect(() => {
      const loadTask = async () => {
        try {
          setLoading(true);
          setCorrectDigits(new Set()); // Сбрасываем правильные цифры при загрузке
          setCorrectCommaPositions(new Set()); // Сбрасываем правильные позиции запятых
          setExtraCommaPositions(new Set()); // Сбрасываем лишние позиции запятых
          setCheckResult(null); // Сбрасываем результат проверки при загрузке нового задания
          const response = await fetch(`/api/task17/${task.id}/play?mode=${currentMode}`);
          if (!response.ok) throw new Error('Не удалось загрузить задание');
          const data = await response.json();
          
          // Нормализуем текст на клиенте (на всякий случай)
          if (data.text) {
            const originalLength = data.text.length;
            data.text = data.text.replace(/\s+/g, ' ').trim();
            const normalizedLength = data.text.length;
            console.log('[task17.ejs] Нормализация текста:', {
              originalLength,
              normalizedLength,
              textPreview: data.text.substring(0, 50)
            });
          }
          
          setTaskData(data);
          setError(null);
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Ошибка загрузки');
        } finally {
          setLoading(false);
        }
      };
      loadTask();
    }, [task.id, currentMode]);

    // Применяем цвета при показе решения
    useEffect(() => {
      if (showSolution && taskData && taskData.explanation && taskData.explanation.explanation_md) {
        setTimeout(() => {
          const explanationDiv = document.getElementById(`task17-explanation-${task.id}`);
          if (explanationDiv && typeof applyColorsInExplanation === 'function') {
            applyColorsInExplanation();
          }
        }, 300);
      }
    }, [showSolution, taskData, task.id]);

    const handleDigitClick = (digit) => {
      setSelectedDigits(prevSelected => {
        const newSet = new Set(prevSelected);
        if (newSet.has(digit)) {
          newSet.delete(digit);
        } else {
          newSet.add(digit);
        }
        return newSet;
      });
    };

    const handleSpaceClick = (offset) => {
      setCommaPositions(prevPositions => {
        const newSet = new Set(prevPositions);
        if (newSet.has(offset)) {
          newSet.delete(offset);
        } else {
          newSet.add(offset);
        }
        return newSet;
      });
    };

    useEffect(() => {
      if (currentMode === 'digits') {
        const sortedDigits = Array.from(selectedDigits).sort((a, b) => a - b);
        setAnswerInput(sortedDigits.join(''));
      } else {
        const sortedPositions = Array.from(commaPositions).sort((a, b) => a - b);
        setAnswerInput(sortedPositions.join(', '));
      }
    }, [selectedDigits, commaPositions, currentMode]);

    const handleInputChange = (e) => {
      const value = e.target.value;
      setAnswerInput(value);
      const digits = value.split('').map(char => parseInt(char, 10)).filter(n => !isNaN(n) && n > 0);
      setSelectedDigits(new Set(digits));
    };

    const handleCheck = async () => {
      if (!taskData) return;
      
      let payload = { mode: currentMode, spans: [] };
      
      if (currentMode === 'digits') {
        const currentDigits = Array.from(selectedDigits).sort((a, b) => a - b);
        if (currentDigits.length === 0) {
          alert('Введите ответ, выбрав цифры в тексте или введя их вручную');
          if (inputRef.current) {
            inputRef.current.focus();
          }
          return;
        }
        payload.digits = currentDigits;
      } else {
        const currentCommaPositions = Array.from(commaPositions).sort((a, b) => a - b);
        // НОВАЯ ЛОГИКА: разрешаем отправку пустого ответа - после этого покажутся правильные запятые
        // НОВАЯ ЛОГИКА: отправляем индексы пробелов (0, 1, 2...), а не позиции в тексте
        // Это делает индексы независимыми от пробелов и лишних запятых
        payload.comma_positions = currentCommaPositions; // Может быть пустым массивом
      }

      try {
        setLoading(true);
        const response = await fetch(`/api/task17/${task.id}/check`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) throw new Error('Ошибка проверки');
        const result = await response.json();
        setCheckResult(result);
        
        // Обрабатываем результат в зависимости от режима
        if (currentMode === 'digits') {
          // Режим цифр - сохраняем правильные цифры для подсветки
          if (result.correctAnswer && result.digits && !result.digits.isCorrect) {
            setCorrectDigits(new Set(result.correctAnswer));
          } else {
            setCorrectDigits(new Set());
          }
          // Сбрасываем позиции запятых в режиме цифр
          setCorrectCommaPositions(new Set());
          setExtraCommaPositions(new Set());
        } else {
          // Режим запятых - сохраняем правильные и лишние индексы пробелов
          // НОВАЯ ЛОГИКА: correctAnswer и extra содержат индексы пробелов (0, 1, 2...), а не позиции
          console.log('[task17.ejs] Обработка результата. currentMode:', currentMode);
          console.log('[task17.ejs] result.commas:', result.commas);
          console.log('[task17.ejs] result.correctAnswer:', result.correctAnswer);
          if (result.commas) {
            // Сохраняем правильные индексы пробелов (показываем ВСЕГДА после проверки)
            if (result.correctAnswer && Array.isArray(result.correctAnswer)) {
              // Преобразуем в числа для корректного сравнения
              // correctAnswer содержит индексы пробелов (0, 1, 2...)
              const correctIndices = result.correctAnswer.map(p => Number(p));
              console.log('[task17.ejs] Сохраняем правильные индексы пробелов:', correctIndices);
              console.log('[task17.ejs] correctIndices.length:', correctIndices.length);
              console.log('[task17.ejs] correctIndices:', JSON.stringify(correctIndices));
              setCorrectCommaPositions(new Set(correctIndices));
              // Проверяем, что Set правильно создан
              const testSet = new Set(correctIndices);
              console.log('[task17.ejs] Создан Set с размером:', testSet.size);
              console.log('[task17.ejs] Set содержит:', Array.from(testSet));
            } else {
              console.log('[task17.ejs] correctAnswer не найден или не массив:', result.correctAnswer);
              console.log('[task17.ejs] Тип result.correctAnswer:', typeof result.correctAnswer);
              setCorrectCommaPositions(new Set());
            }
            // Сохраняем лишние индексы пробелов
            if (result.commas.extra && Array.isArray(result.commas.extra)) {
              // extra содержит индексы пробелов (0, 1, 2...)
              const extraIndices = result.commas.extra.map(p => Number(p));
              setExtraCommaPositions(new Set(extraIndices));
            } else {
              setExtraCommaPositions(new Set());
            }
          } else {
            setCorrectCommaPositions(new Set());
            setExtraCommaPositions(new Set());
          }
          // Сбрасываем цифры в режиме запятых
          setCorrectDigits(new Set());
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Ошибка проверки');
      } finally {
        setLoading(false);
      }
    };

    if (loading && !taskData) {
      return (
        <div className="task-card">
          <div className="task-content">
            <p>Загрузка задания {index + 1}...</p>
          </div>
        </div>
      );
    }

    if (error) {
      return (
        <div className="task-card">
          <div className="task-content">
            <p style={{color: 'red'}}>Ошибка: {error}</p>
          </div>
        </div>
      );
    }

    if (!taskData) {
      return null;
    }

    return (
      <div className="task-card">
        <div className="task-meta">
          <span className="task-meta__number">№ {index + 1}</span>
          {task.source && <span className="task-meta__source">{task.source}</span>}
        </div>
        
        <div className="task-content">
          <div className="task-prompt" style={{position: 'relative'}}>
            <div 
              className="task17-text-editable"
              id={`task17-text-${task.id}`}
              style={{
                padding: '16px',
                border: '1px solid var(--glass-border)',
                borderRadius: '8px',
                background: 'var(--bg-secondary)',
                position: 'relative'
              }}
              contentEditable={false}
              suppressContentEditableWarning={true}
              onCopy={(e) => {
                // Перехватываем событие копирования и заменяем текст на исходный с цифрами
                e.preventDefault();
                // В режиме digits taskData.text уже содержит цифры
                // В режиме commas нужно использовать исходный source_text из задания
                let originalText = taskData.text || '';
                if (currentMode === 'commas' && taskData.source_text) {
                  // Используем исходный текст с цифрами из задания
                  originalText = taskData.source_text;
                }
                if (originalText && e.clipboardData) {
                  e.clipboardData.setData('text/plain', originalText);
                }
              }}
            >
              <div style={{
                paddingBottom: '12px',
                marginBottom: '12px',
                borderBottom: '1px solid var(--glass-border)',
                fontSize: '16px',
                lineHeight: '1.6',
                color: 'var(--text-primary)',
                fontWeight: '500'
              }}>
                {currentMode === 'digits' 
                  ? 'Укажите цифру(-ы), на месте которой(-ых) должна(-ы) стоять запятая(-ые).'
                  : 'Нажмите на пробелы в тексте, где должны стоять запятые.'}
              </div>
              {currentMode === 'digits' ? (
                parseTextWithDigits(taskData.text).map((part, idx) => {
                  if (part.digit !== null) {
                    const isSelected = selectedDigits.has(part.digit);
                    const isCorrect = correctDigits.has(part.digit);
                    return (
                      <span
                        key={`digit-${task.id}-${part.digit}-${idx}`}
                        className={`task17-digit ${isSelected ? 'selected' : ''} ${isCorrect ? 'correct-highlight' : ''}`}
                        data-digit={part.digit}
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          handleDigitClick(part.digit);
                        }}
                        title={`Кликните, чтобы ${isSelected ? 'убрать' : 'добавить'} цифру ${part.digit} в ответ`}
                        style={{
                          userSelect: 'none',
                          WebkitUserSelect: 'none',
                          cursor: 'pointer',
                          contentEditable: 'false',
                          ...(isCorrect && {
                            backgroundColor: 'rgba(34, 197, 94, 0.3)',
                            border: '2px solid rgba(34, 197, 94, 0.8)',
                            padding: '2px 4px'
                          })
                        }}
                        contentEditable={false}
                        suppressContentEditableWarning={true}
                      >
                        {part.text}
                      </span>
                    );
                  }
                  // Текстовые части для режима digits отображаем как есть
                  // ВАЖНО: проверяем, что part.text существует
                  if (!part.text) {
                    console.warn('[task17.ejs] Пустая текстовая часть (digits):', part, 'idx:', idx);
                    return null;
                  }
                  return <span key={`text-${task.id}-${idx}`}>{part.text}</span>;
                })
              ) : (
                (() => {
                  // НОВАЯ ЛОГИКА: correctCommaPositions содержит индексы пробелов (0, 1, 2...), а не позиции
                  const correctIndicesArray = checkResult && correctCommaPositions.size > 0
                    ? Array.from(correctCommaPositions) 
                    : null;
                  console.log('[task17.ejs] Передаем в parseTextWithSpaces correctIndicesArray (индексы пробелов):', correctIndicesArray);
                  console.log('[task17.ejs] correctCommaPositions.size:', correctCommaPositions.size);
                  console.log('[task17.ejs] checkResult:', checkResult);
                  console.log('[task17.ejs] taskData.text длина:', taskData.text?.length);
                  console.log('[task17.ejs] taskData.text превью:', taskData.text?.substring(0, 100));
                  // Нормализуем текст так же, как на сервере
                  const normalizedClientText = taskData.text?.replace(/\s+/g, ' ').trim() || '';
                  console.log('[task17.ejs] Нормализованный текст на клиенте, длина:', normalizedClientText.length);
                  console.log('[task17.ejs] Количество пробелов в нормализованном тексте:', (normalizedClientText.match(/\s/g) || []).length);
                  const parts = parseTextWithSpaces(taskData.text, correctIndicesArray);
                  console.log('[task17.ejs] parseTextWithSpaces вернул parts:', parts.length);
                  const totalPartsLength = parts.reduce((sum, p) => sum + (p.text?.length || 0), 0);
                  console.log('[task17.ejs] Общая длина всех parts:', totalPartsLength, 'длина текста:', taskData.text?.length);
                  return parts;
                })().map((part, idx) => {
                  if (part.isClickable && part.spaceIndex !== null && part.spaceIndex !== undefined) {
                    const spaceIndex = Number(part.spaceIndex); // Порядковый индекс пробела (0, 1, 2...)
                    // Проверяем с учетом преобразования типов
                    const hasComma = commaPositions.has(spaceIndex);
                    // Проверяем правильность и лишние позиции (используем явное сравнение чисел)
                    const isCorrect = correctCommaPositions.has(spaceIndex);
                    const isExtra = extraCommaPositions.has(spaceIndex);
                    
                    // Отладка для первых нескольких позиций и правильных позиций
                    if (checkResult && (idx < 10 || isCorrect || hasComma || correctCommaPositions.has(spaceIndex))) {
                      console.log(`[task17.ejs] Индекс пробела ${spaceIndex}: hasComma=${hasComma}, isCorrect=${isCorrect}`);
                      console.log(`[task17.ejs] correctCommaPositions.size:`, correctCommaPositions.size);
                      console.log(`[task17.ejs] correctCommaPositions содержит ${spaceIndex}?`, correctCommaPositions.has(spaceIndex));
                      console.log(`[task17.ejs] Все correctCommaPositions:`, Array.from(correctCommaPositions));
                      console.log(`[task17.ejs] Тип spaceIndex:`, typeof spaceIndex, 'значение:', spaceIndex);
                    }
                    // Определяем стиль в зависимости от статуса позиции
                    let bgColor = 'transparent';
                    let textColor = 'inherit';
                    let fontWeight = 'normal';
                    // Показываем запятую если: выбрана пользователем ИЛИ правильная позиция после проверки
                    let displayComma = hasComma || (checkResult && isCorrect);
                    
                    if (checkResult) {
                      // После проверки показываем правильные и неправильные позиции
                      // Показываем ВСЕ правильные запятые после проверки
                      if (hasComma && isExtra) {
                        // Неправильная позиция - красная
                        bgColor = 'rgba(239, 68, 68, 0.3)';
                        textColor = '#ef4444';
                        fontWeight = 'bold';
                        displayComma = true;
                      } else if (isCorrect) {
                        // Правильная позиция (выбранная или нет) - зеленая
                        // Показываем ВСЕ правильные запятые после проверки
                        bgColor = 'rgba(34, 197, 94, 0.3)';
                        textColor = '#22c55e';
                        fontWeight = 'bold';
                        displayComma = true;
                      } else if (hasComma) {
                        // Выбрана, но не является ни правильной, ни лишней (не должно происходить, но на всякий случай)
                        bgColor = 'rgba(0, 240, 255, 0.3)';
                        textColor = 'var(--neon-cyan)';
                        fontWeight = 'bold';
                        displayComma = true;
                      }
                    } else {
                      // До проверки - обычная синяя подсветка
                      if (hasComma) {
                        bgColor = 'rgba(0, 240, 255, 0.3)';
                        textColor = 'var(--neon-cyan)';
                        fontWeight = 'bold';
                        displayComma = true;
                      }
                    }
                    
                    return (
                      <span
                        key={`space-${task.id}-${spaceIndex}-${idx}`}
                        className={`task17-space ${hasComma ? 'task17-space-with-comma' : ''} ${isCorrect ? 'task17-space-correct' : ''} ${isExtra ? 'task17-space-extra' : ''}`}
                        data-space-index={spaceIndex}
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          handleSpaceClick(spaceIndex);
                        }}
                        title="Кликните, чтобы поставить запятую"
                        style={{
                          backgroundColor: bgColor,
                          color: textColor,
                          fontWeight: fontWeight
                        }}
                      >
                        {displayComma ? ',' : ' '}
                      </span>
                    );
                  }
                  // Текстовые части отображаем как есть, без добавления запятых
                  // ВАЖНО: проверяем, что part существует и part.text определен
                  if (!part) {
                    console.error('[task17.ejs] Отсутствует part (commas):', 'idx:', idx);
                    return null;
                  }
                  // ВАЖНО: part.text может быть пустой строкой (хотя не должно), но мы все равно отображаем
                  const textToDisplay = part.text !== undefined && part.text !== null ? part.text : '';
                  if (textToDisplay === '' && idx > 0) {
                    // Пустая текстовая часть в середине - это подозрительно, но не критично
                    console.warn('[task17.ejs] Пустая текстовая часть (commas):', part, 'idx:', idx);
                  }
                  return <span key={`text-${task.id}-${idx}`}>{textToDisplay}</span>;
                })
              )}
            </div>
          </div>

          <div className="task-controls">
            {currentMode === 'digits' && (
              <input
                ref={inputRef}
                className="task-input"
                type="text"
                value={answerInput}
                onChange={handleInputChange}
                placeholder="Введите свой ответ"
                inputMode="numeric"
                onKeyPress={(e) => {
                  if (e.key === 'Enter') {
                    handleCheck();
                  }
                }}
              />
            )}
            <button
              className="task-send"
              onClick={handleCheck}
              disabled={loading}
            >
              <span>{loading ? 'Проверка...' : 'Отправить'}</span>
            </button>
            <button
              className="task-solution"
              onClick={() => setShowSolution(!showSolution)}
            >
              <span>Решение</span>
              <img src={showSolution ? "/images/eye on.svg" : "/images/eye off.svg"} alt="Глаз" width="16" height="16"/>
            </button>
            <button 
              className="task-like"
              onClick={() => setIsLiked(!isLiked)}
            >
              <img 
                src={isLiked ? "/images/heart on.svg" : "/images/heart off.svg"} 
                alt="Лайк" 
                width="16" 
                height="16"
              />
            </button>
          </div>

          {showSolution && taskData && taskData.explanation && (
            <div id={`task17-solution-block-${task.id}`} style={{marginTop: '24px'}}>
              {taskData.explanation.answer_text && (
                <div style={{marginBottom: '12px'}} className="solution-answer">
                  <strong>Ответ:</strong> {taskData.explanation.answer_text}
                </div>
              )}
              {taskData.explanation.explanation_md && (
                <div>
                  <h4 style={{marginTop: 0, marginBottom: '12px'}}>Объяснение:</h4>
                  <div
                    id={`task17-explanation-${task.id}`}
                    dangerouslySetInnerHTML={{
                      __html: taskData.explanation.explanation_md.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    }}
                    className="editor-content task17-explanation-content"
                    style={{
                      position: 'relative',
                      fontSize: '18px',
                      lineHeight: '1.8',
                      padding: '16px',
                      minHeight: '100px'
                    }}
                  />
                </div>
              )}
            </div>
          )}

          {checkResult && (
            <div className="task-solution-block" style={{marginTop: '24px'}}>
              <h3 style={{marginTop: 0, marginBottom: '16px'}}>Результат проверки</h3>
              
              {((currentMode === 'digits' && checkResult.digits && checkResult.digits.isCorrect) ||
                (currentMode === 'commas' && checkResult.commas && checkResult.commas.isCorrect)) ? (
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '12px',
                  padding: '16px',
                  background: 'rgba(34, 197, 94, 0.1)',
                  border: '2px solid rgba(34, 197, 94, 0.5)',
                  marginBottom: '16px'
                }}>
                  <div style={{
                    fontSize: '32px',
                    color: '#22c55e',
                    lineHeight: '1'
                  }}>
                    ✓
                  </div>
                  <div style={{
                    fontSize: '18px',
                    fontWeight: 'bold',
                    color: '#22c55e'
                  }}>
                    Все верно!
                  </div>
                </div>
              ) : (
                <div style={{marginBottom: '16px'}}>
                  <div style={{
                    fontWeight: 'bold',
                    color: '#f6b462',
                    marginBottom: '12px',
                    fontSize: '16px'
                  }}>
                    Ответ неверный
                  </div>
                  {checkResult.correctAnswer && (
                    <div style={{
                      padding: '12px',
                      background: 'rgba(239, 68, 68, 0.1)',
                      border: '1px solid rgba(239, 68, 68, 0.3)',
                      marginBottom: '12px'
                    }}>
                      <div style={{
                        color: 'var(--text-secondary)',
                        marginBottom: '4px',
                        fontSize: '14px'
                      }}>
                        Правильный ответ:
                      </div>
                      <div style={{
                        fontSize: '18px',
                        fontWeight: 'bold',
                        color: '#22c55e'
                      }}>
                        {checkResult.correctAnswer.join(', ')}
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    );
  }

  // Компонент для списка всех заданий
  function Task17List() {
    const [allTasks, setAllTasks] = useState([]);
    const [loading, setLoading] = useState(true);
    const [showDigits, setShowDigits] = useState(true);
    const [showToolbar, setShowToolbar] = useState(true);

    useEffect(() => {
      const loadAllTasks = async () => {
        try {
          const response = await fetch('/api/task17');
          if (!response.ok) throw new Error('Не удалось загрузить список заданий');
          const tasks = await response.json();
          setAllTasks(tasks);
        } catch (err) {
          console.error('Ошибка загрузки списка заданий:', err);
        } finally {
          setLoading(false);
        }
      };
      loadAllTasks();
    }, []);

    // Управление видимостью левой панели инструментов
    useEffect(() => {
      const toolbarLeft = document.getElementById('task17-toolbar-left');
      if (toolbarLeft) {
        toolbarLeft.style.display = showToolbar ? 'block' : 'none';
      }
    }, [showToolbar]);

    // Применяем скрытие цифр ко всем заданиям
    useEffect(() => {
      const allTextEditors = document.querySelectorAll('.task17-text-editable');
      allTextEditors.forEach(editor => {
        const digits = editor.querySelectorAll('.task17-digit');
        digits.forEach(digit => {
          digit.style.display = showDigits ? '' : 'none';
        });
      });
    }, [showDigits]);

    if (loading) {
      return (
        <div style={{padding: '20px'}}>
          <p>Загрузка заданий...</p>
        </div>
      );
    }

    if (allTasks.length === 0) {
      return (
        <div style={{padding: '20px'}}>
          <p>Заданий №17 пока нет.</p>
        </div>
      );
    }

    return (
      <div className="task17-wrapper">
        <div style={{flex: 1, maxWidth: '800px'}}>
          {allTasks.map((task, index) => (
            <Task17Item key={task.id} task={task} index={index} showDigits={showDigits} />
          ))}
        </div>
        {/* Правая панель с переключателями */}
        <div className="task17-control-panel">
          <div style={{
            marginBottom: '16px',
            color: 'var(--text-primary)',
            fontWeight: 600,
            fontSize: '14px'
          }}>
            Настройки отображения
          </div>
          
          <div style={{display: 'flex', flexDirection: 'column', gap: '16px'}}>
            <label style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              cursor: 'pointer',
              color: 'var(--text-primary)',
              fontSize: '14px'
            }}>
              <span>Показывать цифры</span>
              <div
                onClick={() => setShowDigits(!showDigits)}
                style={{
                  width: '48px',
                  height: '24px',
                  background: showDigits ? 'var(--neon-cyan)' : 'var(--text-disabled)',
                  position: 'relative',
                  cursor: 'pointer',
                  transition: 'all 0.3s ease',
                  boxShadow: showDigits ? '0 0 10px rgba(0, 240, 255, 0.5)' : 'none'
                }}
              >
                <div
                  style={{
                    width: '20px',
                    height: '20px',
                    borderRadius: '50%',
                    background: '#fff',
                    position: 'absolute',
                    top: '2px',
                    left: showDigits ? '26px' : '2px',
                    transition: 'all 0.3s ease',
                    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)'
                  }}
                />
              </div>
            </label>
            
            <label style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              cursor: 'pointer',
              color: 'var(--text-primary)',
              fontSize: '14px'
            }}>
              <span>Панель выделений</span>
              <div
                onClick={() => setShowToolbar(!showToolbar)}
                style={{
                  width: '48px',
                  height: '24px',
                  background: showToolbar ? 'var(--neon-cyan)' : 'var(--text-disabled)',
                  position: 'relative',
                  cursor: 'pointer',
                  transition: 'all 0.3s ease',
                  boxShadow: showToolbar ? '0 0 10px rgba(0, 240, 255, 0.5)' : 'none'
                }}
              >
                <div
                  style={{
                    width: '20px',
                    height: '20px',
                    borderRadius: '50%',
                    background: '#fff',
                    position: 'absolute',
                    top: '2px',
                    left: showToolbar ? '26px' : '2px',
                    transition: 'all 0.3s ease',
                    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)'
                  }}
                />
              </div>
            </label>
          </div>
        </div>
      </div>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('task17Container'));
  root.render(<Task17List />);
</script>

<script>
  // Инициализация панели инструментов для выделений
  // Выносим функцию applySpanClass в глобальную область для использования в плавающей панели
  function applySpanClass(className) {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;

      const range = selection.getRangeAt(0);
      const parent = range.commonAncestorContainer.nodeType === 3 
        ? range.commonAncestorContainer.parentElement 
        : range.commonAncestorContainer;

      let editor = parent;
      while (editor && !editor.classList.contains('task17-text-editable')) {
        editor = editor.parentElement;
      }

      if (!editor) {
        alert('Поместите курсор в текст задания');
        return;
      }

      const selectedText = selection.toString().trim();
      if (!selectedText) {
        alert('Выделите текст для отметки');
        return;
      }

      try {
        // Функция для расширения range до ближайших пробелов
        function expandRangeToSpaces(range) {
          const expandedRange = range.cloneRange();
          
          // Расширяем начало влево до пробела
          let startContainer = expandedRange.startContainer;
          let startOffset = expandedRange.startOffset;
          
          // Если начало в текстовом узле
          if (startContainer.nodeType === Node.TEXT_NODE) {
            const text = startContainer.textContent;
            let newOffset = startOffset;
            // Ищем пробел слева
            while (newOffset > 0 && text[newOffset - 1] !== ' ') {
              newOffset--;
            }
            expandedRange.setStart(startContainer, newOffset);
          } else {
            // Если начало в элементе, ищем первый текстовый узел внутри
            const walker = document.createTreeWalker(
              startContainer,
              NodeFilter.SHOW_TEXT,
              null
            );
            const firstTextNode = walker.nextNode();
            if (firstTextNode) {
              const text = firstTextNode.textContent;
              let spacePos = text.lastIndexOf(' ');
              if (spacePos >= 0) {
                expandedRange.setStart(firstTextNode, spacePos + 1);
              } else {
                expandedRange.setStart(firstTextNode, 0);
              }
            }
          }
          
          // Расширяем конец вправо до пробела
          let endContainer = expandedRange.endContainer;
          let endOffset = expandedRange.endOffset;
          
          // Если конец в текстовом узле
          if (endContainer.nodeType === Node.TEXT_NODE) {
            const text = endContainer.textContent;
            let newOffset = endOffset;
            // Ищем пробел справа
            while (newOffset < text.length && text[newOffset] !== ' ') {
              newOffset++;
            }
            // Включаем пробел, если он есть
            if (newOffset < text.length && text[newOffset] === ' ') {
              newOffset++;
            }
            expandedRange.setEnd(endContainer, newOffset);
          } else {
            // Если конец в элементе, ищем последний текстовый узел внутри
            const walker = document.createTreeWalker(
              endContainer,
              NodeFilter.SHOW_TEXT,
              null
            );
            let lastTextNode = null;
            let node;
            while (node = walker.nextNode()) {
              lastTextNode = node;
            }
            if (lastTextNode) {
              const text = lastTextNode.textContent;
              let spacePos = text.indexOf(' ');
              if (spacePos >= 0) {
                expandedRange.setEnd(lastTextNode, spacePos + 1);
              } else {
                expandedRange.setEnd(lastTextNode, text.length);
              }
            }
          }
          
          // Если range пересекает несколько узлов, расширяем границы
          // Расширяем начало, проходя по предыдущим узлам
          while (true) {
            const startContainer = expandedRange.startContainer;
            const startOffset = expandedRange.startOffset;
            
            if (startContainer.nodeType === Node.TEXT_NODE && startOffset === 0) {
              // Дошли до начала текстового узла, проверяем предыдущий узел
              const prevNode = startContainer.previousSibling;
              if (prevNode && prevNode.nodeType === Node.TEXT_NODE) {
                const text = prevNode.textContent;
                const spacePos = text.lastIndexOf(' ');
                if (spacePos >= 0) {
                  expandedRange.setStart(prevNode, spacePos + 1);
                  continue;
                } else {
                  expandedRange.setStart(prevNode, 0);
                  continue;
                }
              }
            }
            break;
          }
          
          // Расширяем конец, проходя по следующим узлам
          while (true) {
            const endContainer = expandedRange.endContainer;
            const endOffset = expandedRange.endOffset;
            
            if (endContainer.nodeType === Node.TEXT_NODE && 
                endOffset >= endContainer.textContent.length) {
              // Дошли до конца текстового узла, проверяем следующий узел
              const nextNode = endContainer.nextSibling;
              if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
                const text = nextNode.textContent;
                const spacePos = text.indexOf(' ');
                if (spacePos >= 0) {
                  expandedRange.setEnd(nextNode, spacePos + 1);
                  continue;
                } else {
                  expandedRange.setEnd(nextNode, text.length);
                  continue;
                }
              }
            }
            break;
          }
          
          return expandedRange;
        }

        // Всегда расширяем range до пробелов, даже для вложенных выделений
        let expandedRange;
        try {
          expandedRange = expandRangeToSpaces(range);
        } catch (e) {
          // Если не удалось расширить, используем исходный range
          expandedRange = range.cloneRange();
        }
        
        // Проверяем, что есть выделение
        const expandedText = expandedRange.toString();
        if (!expandedText || expandedText.trim() === '') {
          // Если расширенное выделение пустое, пробуем использовать исходный range
          const originalText = range.toString().trim();
          if (!originalText) {
            alert('Не удалось расширить выделение');
            return;
          }
          // Используем исходный range без расширения
          expandedRange = range.cloneRange();
        }

        const span = document.createElement('span');
        span.className = className;

        if (className === 'span-main-word') {
          // Автоматически назначаем цвет при создании главного слова
          const colorPalette = [
            { bg: 'rgba(59, 130, 246, 0.3)', border: 'rgba(59, 130, 246, 0.8)', text: 'rgba(59, 130, 246, 1)' }, // Синий
            { bg: 'rgba(34, 197, 94, 0.3)', border: 'rgba(34, 197, 94, 0.8)', text: 'rgba(34, 197, 94, 1)' }, // Зеленый
            { bg: 'rgba(236, 72, 153, 0.3)', border: 'rgba(236, 72, 153, 0.8)', text: 'rgba(236, 72, 153, 1)' }, // Розовый
            { bg: 'rgba(251, 191, 36, 0.3)', border: 'rgba(251, 191, 36, 0.8)', text: 'rgba(251, 191, 36, 1)' }, // Желтый
            { bg: 'rgba(168, 85, 247, 0.3)', border: 'rgba(168, 85, 247, 0.8)', text: 'rgba(168, 85, 247, 1)' }, // Фиолетовый
            { bg: 'rgba(239, 68, 68, 0.3)', border: 'rgba(239, 68, 68, 0.8)', text: 'rgba(239, 68, 68, 1)' }, // Красный
            { bg: 'rgba(14, 165, 233, 0.3)', border: 'rgba(14, 165, 233, 0.8)', text: 'rgba(14, 165, 233, 1)' }, // Голубой
            { bg: 'rgba(245, 158, 11, 0.3)', border: 'rgba(245, 158, 11, 0.8)', text: 'rgba(245, 158, 11, 1)' }, // Оранжевый
          ];
          
          // Находим следующий свободный цвет
          const usedColors = new Set();
          const textEditor = editor.closest('.task17-text-editable') || document.querySelector('.task17-text-editable');
          if (textEditor) {
            textEditor.querySelectorAll('.span-main-word[data-color-id]').forEach(el => {
              const id = el.getAttribute('data-color-id');
              if (id !== null && id !== '') {
                usedColors.add(parseInt(id));
              }
            });
          }
          
          let freeIndex = 0;
          while (usedColors.has(freeIndex) && freeIndex < colorPalette.length) {
            freeIndex++;
          }
          
          const color = colorPalette[freeIndex % colorPalette.length];
          span.setAttribute('data-color-id', freeIndex);
          span.style.backgroundColor = color.bg;
          span.style.borderColor = color.border;
          span.style.borderWidth = '2px';
          span.style.borderStyle = 'solid';
        }

        // Пытаемся использовать surroundContents для сохранения пробелов
        try {
          expandedRange.surroundContents(span);
        } catch (e) {
          // Если surroundContents не работает (range пересекает границы элементов),
          // используем extractContents с сохранением структуры
          const contents = expandedRange.extractContents();
          span.appendChild(contents);
          expandedRange.insertNode(span);
        }
        
        selection.removeAllRanges();
      } catch (err) {
        console.error('Ошибка при применении стиля:', err);
      }
    }

  // Выносим функцию удаления в глобальную область
  function removeMark() {
    const selection = window.getSelection();
    if (!selection.rangeCount) {
      alert('Выделите текст для удаления отметки');
      return;
    }

    const range = selection.getRangeAt(0);
    const parent = range.commonAncestorContainer.nodeType === 3 
      ? range.commonAncestorContainer.parentElement 
      : range.commonAncestorContainer;

    if (parent && (parent.classList.contains('span-participle') || 
                   parent.classList.contains('span-gerund') || 
                   parent.classList.contains('span-main-word') ||
                   parent.classList.contains('span-subject') ||
                   parent.classList.contains('span-predicate'))) {
      const textNode = document.createTextNode(parent.textContent);
      parent.parentNode.replaceChild(textNode, parent);
      selection.removeAllRanges();
    } else {
      alert('Выделите текст с отметкой для удаления');
    }
  }

  function initTextToolbar() {
    const markParticipleBtn = document.getElementById('task17-mark-participle-text');
    const markGerundBtn = document.getElementById('task17-mark-gerund-text');
    const markMainWordBtn = document.getElementById('task17-mark-main-word-text');
    const removeMarkBtn = document.getElementById('task17-remove-mark-text');

    if (!markParticipleBtn || !markGerundBtn || !markMainWordBtn || !removeMarkBtn) return;

    markParticipleBtn.addEventListener('click', () => applySpanClass('span-participle'));
    markGerundBtn.addEventListener('click', () => applySpanClass('span-gerund'));
    markMainWordBtn.addEventListener('click', () => applySpanClass('span-main-word'));
    removeMarkBtn.addEventListener('click', removeMark);
  }

  setTimeout(() => {
    initTextToolbar();
    initFloatingToolbar();
  }, 500);

  // Инициализация плавающей панели инструментов
  let floatingToolbar = null; // Делаем глобальной переменной
  function initFloatingToolbar() {
    floatingToolbar = document.getElementById('task17-floating-toolbar');
    if (!floatingToolbar) return;

    // Функция для подсчета слов в выделении
    function countWords(text) {
      return text.trim().split(/\s+/).filter(word => word.length > 0).length;
    }

    // Функция для показа панели
    function showToolbar(range) {
      if (!range || range.collapsed) {
        floatingToolbar.classList.remove('show');
        return;
      }

      // Получаем текст из range, а не из selection
      const selectedText = range.toString().trim();
      
      if (!selectedText) {
        floatingToolbar.classList.remove('show');
        return;
      }
      
      // Устанавливаем selection для корректной работы
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);

      // Проверяем, что выделение внутри текста задания
      const editor = range.commonAncestorContainer.nodeType === 3 
        ? range.commonAncestorContainer.parentElement 
        : range.commonAncestorContainer;
      
      // Игнорируем клики по цифрам
      if (editor.closest && editor.closest('.task17-digit')) {
        floatingToolbar.classList.remove('show');
        return;
      }
      
      let textEditor = editor;
      while (textEditor && !textEditor.classList.contains('task17-text-editable')) {
        textEditor = textEditor.parentElement;
      }

      if (!textEditor) {
        floatingToolbar.classList.remove('show');
        return;
      }

      // Очищаем панель
      floatingToolbar.innerHTML = '';

      // Сохраняем текущее выделение для использования в обработчиках
      const savedRange = range.cloneRange();

      // Всегда показываем все опции подчеркивания
      const buttons = [
        { 
          class: 'span-participle', 
          icon: '<svg width="24" height="8" viewBox="0 0 24 8" xmlns="http://www.w3.org/2000/svg"><path d="M 2 6 Q 4 4, 6 6 T 10 6 T 14 6 T 18 6 T 22 6" stroke="rgba(255, 255, 255, 0.9)" stroke-width="2" fill="none" stroke-linecap="round"/></svg>', 
          title: 'Причастный' 
        },
        { 
          class: 'span-gerund', 
          icon: '<svg width="24" height="8" viewBox="0 0 24 8" xmlns="http://www.w3.org/2000/svg"><line x1="2" y1="6" x2="8" y2="6" stroke="rgba(255, 255, 255, 0.9)" stroke-width="2" stroke-linecap="round"/><circle cx="12" cy="6" r="1.5" fill="rgba(255, 255, 255, 0.9)"/><line x1="16" y1="6" x2="22" y2="6" stroke="rgba(255, 255, 255, 0.9)" stroke-width="2" stroke-linecap="round"/></svg>', 
          title: 'Деепричастный' 
        },
        { 
          class: 'span-subject', 
          icon: '<svg width="24" height="8" viewBox="0 0 24 8" xmlns="http://www.w3.org/2000/svg"><line x1="2" y1="6" x2="22" y2="6" stroke="rgba(255, 255, 255, 0.9)" stroke-width="2" stroke-linecap="round"/></svg>', 
          title: 'Подлежащее' 
        },
        { 
          class: 'span-predicate', 
          icon: '<svg width="24" height="8" viewBox="0 0 24 8" xmlns="http://www.w3.org/2000/svg"><line x1="2" y1="5" x2="22" y2="5" stroke="rgba(255, 255, 255, 0.9)" stroke-width="2" stroke-linecap="round"/><line x1="2" y1="7" x2="22" y2="7" stroke="rgba(255, 255, 255, 0.9)" stroke-width="2" stroke-linecap="round"/></svg>', 
          title: 'Сказуемое' 
        },
        { 
          class: 'span-main-word', 
          icon: '<svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><line x1="2" y1="2" x2="14" y2="14" stroke="rgba(255, 255, 255, 0.9)" stroke-width="2" stroke-linecap="round"/><line x1="14" y1="2" x2="2" y2="14" stroke="rgba(255, 255, 255, 0.9)" stroke-width="2" stroke-linecap="round"/></svg>', 
          title: 'Главное слово' 
        }
      ];

      buttons.forEach(item => {
        const button = document.createElement('button');
        button.innerHTML = item.icon;
        button.title = item.title;
        button.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          floatingToolbar.classList.remove('show');
          
          // Восстанавливаем выделение перед применением
          try {
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(savedRange);
            
            // Проверяем, что выделение восстановлено
            if (sel.rangeCount > 0) {
              // Используем глобальную функцию applySpanClass
              applySpanClass(item.class);
            } else {
              console.error('Не удалось восстановить выделение');
            }
          } catch (err) {
            console.error('Ошибка при восстановлении выделения:', err);
            // Пытаемся восстановить выделение через текст
            const sel = window.getSelection();
            const textEditor = document.querySelector('.task17-text-editable');
            if (textEditor && savedRange.toString()) {
              const text = savedRange.toString();
              const walker = document.createTreeWalker(textEditor, NodeFilter.SHOW_TEXT);
              let node;
              while (node = walker.nextNode()) {
                const index = node.textContent.indexOf(text);
                if (index >= 0) {
                  const newRange = document.createRange();
                  newRange.setStart(node, index);
                  newRange.setEnd(node, index + text.length);
                  sel.removeAllRanges();
                  sel.addRange(newRange);
                  applySpanClass(item.class);
                  break;
                }
              }
            }
          }
        };
        floatingToolbar.appendChild(button);
      });

      // Добавляем кнопку удаления
      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove';
      removeBtn.innerHTML = '🗑';
      removeBtn.title = 'Удалить выделение';
      removeBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        floatingToolbar.classList.remove('show');
        
        // Восстанавливаем выделение перед удалением
        try {
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(savedRange);
          
          // Проверяем, что выделение восстановлено
          if (sel.rangeCount > 0) {
            // Используем глобальную функцию removeMark
            removeMark();
          } else {
            console.error('Не удалось восстановить выделение');
          }
        } catch (err) {
          console.error('Ошибка при восстановлении выделения:', err);
        }
      };
      floatingToolbar.appendChild(removeBtn);

      // Позиционируем панель прямо над выделением
      const rect = range.getBoundingClientRect();
      
      // Показываем панель, чтобы получить её размеры
      floatingToolbar.style.visibility = 'hidden';
      floatingToolbar.style.position = 'fixed'; // Используем fixed для позиционирования относительно viewport
      floatingToolbar.classList.add('show');
      
      // Ждем один кадр, чтобы панель отрисовалась
      requestAnimationFrame(() => {
        const toolbarRect = floatingToolbar.getBoundingClientRect();
        
        // Позиционируем панель прямо над выделением по центру
        let top = rect.top - toolbarRect.height - 10;
        let left = rect.left + (rect.width / 2) - (toolbarRect.width / 2);

        // Проверяем, не выходит ли панель за правую границу
        if (left + toolbarRect.width > window.innerWidth) {
          left = window.innerWidth - toolbarRect.width - 8;
        }

        // Проверяем, не выходит ли панель за левую границу
        if (left < 8) {
          left = 8;
        }

        // Если панель не помещается сверху, показываем снизу
        if (top < 8) {
          top = rect.bottom + 10;
        }

        floatingToolbar.style.top = top + 'px';
        floatingToolbar.style.left = left + 'px';
        floatingToolbar.style.visibility = 'visible';
      });
    }

    // Отслеживаем выделение текста
    document.addEventListener('mouseup', (e) => {
      // Не показываем панель, если клик был на самой панели
      if (floatingToolbar && floatingToolbar.contains(e.target)) {
        return;
      }
      
      // Проверяем выделение текста
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        if (!range.collapsed) {
          // Проверяем, что это действительно новое выделение, а не клик на уже выделенный элемент
          // Если выделение полностью внутри одного span элемента и совпадает с его содержимым - это клик, не выделение
          const clickedMark = e.target.closest('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word');
          if (clickedMark) {
            const markRange = document.createRange();
            markRange.selectNodeContents(clickedMark);
            const selectedText = range.toString().trim();
            const markText = clickedMark.textContent.trim();
            // Если выделение точно совпадает с содержимым span - это клик, не новое выделение
            if (selectedText === markText) {
              // Не обрабатываем здесь - обработчик клика на выделенные элементы покажет панель
              return;
            }
          }
          
          // Это новое выделение текста - показываем панель
          showToolbar(range);
        } else {
          if (floatingToolbar) floatingToolbar.classList.remove('show');
        }
      } else {
        if (floatingToolbar) floatingToolbar.classList.remove('show');
      }
    });

    // Обработчик клика на уже выделенные элементы - показывает панель
    function setupClickOnMarks() {
      document.querySelectorAll('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word').forEach(mark => {
        if (mark.dataset.clickSetup) return; // Уже настроено
        mark.dataset.clickSetup = 'true';
        
        // Используем click, но проверяем, не выделяется ли текст
        mark.addEventListener('click', function(e) {
          // Если режим связывания активен и клик по обороту - не показываем панель (обработает initMainWordColorSelection)
          if (typeof isLinkingMode !== 'undefined' && isLinkingMode && 
              (this.classList.contains('span-participle') || this.classList.contains('span-gerund'))) {
            // Не блокируем событие, чтобы initMainWordColorSelection мог обработать связывание
            return;
          }
          
          // Проверяем, есть ли выделение текста - если есть, значит пользователь выделял, а не кликал
          const selection = window.getSelection();
          if (selection.toString().trim().length > 0 && !selection.isCollapsed) {
            // Есть выделение - это не простой клик, не показываем панель
            return;
          }
          
          // Проверяем, не кликнули ли мы на вложенный элемент внутри другого выделенного элемента
          // Если клик был на вложенном элементе, не обрабатываем клик на внешнем
          const clickedElement = e.target.closest('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word');
          if (clickedElement && clickedElement !== this) {
            // Клик был на вложенном элементе, не обрабатываем внешний
            return;
          }
          
          // Если клик по главному слову - проверяем режим связывания
          if (this.classList.contains('span-main-word')) {
            // Если режим связывания активен - не показываем панель
            if (typeof isLinkingMode !== 'undefined' && isLinkingMode) {
              return;
            }
            
            const toolbar = document.getElementById('task17-floating-toolbar');
            const isToolbarVisible = toolbar && toolbar.classList.contains('show');
            
            // Если панель уже видна - это второй клик, включаем режим связывания
            if (isToolbarVisible) {
              // Не блокируем событие, чтобы initMainWordColorSelection мог обработать клик для режима связывания
              return;
            }
            
            // Если панель не видна - это первый клик, показываем панель
            e.preventDefault();
            e.stopPropagation();
            
            // Создаем range для выделенного элемента
            const range = document.createRange();
            range.selectNodeContents(this);
            
            // Показываем панель над этим элементом
            showToolbar(range);
            return;
          }
          
          // Для остальных элементов - показываем панель
          e.preventDefault();
          e.stopPropagation();
          
          // Создаем range для выделенного элемента (только для этого элемента, не для родительских)
          const range = document.createRange();
          range.selectNodeContents(this);
          
          // Показываем панель над этим элементом - вызываем функцию showToolbar
          showToolbar(range);
        }, true); // Используем capture phase, чтобы сработать раньше других обработчиков
      });
    }

    // Наблюдаем за появлением новых выделений
    const markClickObserver = new MutationObserver(() => {
      setupClickOnMarks();
    });

    markClickObserver.observe(document.body, {
      childList: true,
      subtree: true
    });

    // Устанавливаем для существующих элементов
    setupClickOnMarks();

    // Скрываем панель при клике вне выделения и панели
    document.addEventListener('mousedown', (e) => {
      // Не скрываем панель, если клик по выделенному элементу или панели
      if (e.target.closest('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word')) {
        return;
      }
      
      if (floatingToolbar && !floatingToolbar.contains(e.target)) {
        // Небольшая задержка, чтобы дать время onclick сработать
        setTimeout(() => {
          if (floatingToolbar && !floatingToolbar.contains(document.activeElement)) {
            floatingToolbar.classList.remove('show');
          }
        }, 200); // Увеличиваем задержку, чтобы дать время обработчику клика сработать
      }
    });
  }

  // Функция для применения цветов в объяснении
  function applyColorsInExplanation() {
    // Палитра цветов (та же, что в админке)
    const colorPalette = [
      { bg: 'rgba(59, 130, 246, 0.3)', border: 'rgba(59, 130, 246, 0.8)', text: 'rgba(59, 130, 246, 1)' }, // Синий
      { bg: 'rgba(34, 197, 94, 0.3)', border: 'rgba(34, 197, 94, 0.8)', text: 'rgba(34, 197, 94, 1)' }, // Зеленый
      { bg: 'rgba(236, 72, 153, 0.3)', border: 'rgba(236, 72, 153, 0.8)', text: 'rgba(236, 72, 153, 1)' }, // Розовый
      { bg: 'rgba(251, 191, 36, 0.3)', border: 'rgba(251, 191, 36, 0.8)', text: 'rgba(251, 191, 36, 1)' }, // Желтый
      { bg: 'rgba(168, 85, 247, 0.3)', border: 'rgba(168, 85, 247, 0.8)', text: 'rgba(168, 85, 247, 1)' }, // Фиолетовый
      { bg: 'rgba(239, 68, 68, 0.3)', border: 'rgba(239, 68, 68, 0.8)', text: 'rgba(239, 68, 68, 1)' }, // Красный
      { bg: 'rgba(14, 165, 233, 0.3)', border: 'rgba(14, 165, 233, 0.8)', text: 'rgba(14, 165, 233, 1)' }, // Голубой
      { bg: 'rgba(245, 158, 11, 0.3)', border: 'rgba(245, 158, 11, 0.8)', text: 'rgba(245, 158, 11, 1)' }, // Оранжевый
    ];
    
    // Применяем цвет к элементу
    function applyColor(element, color) {
      element.style.backgroundColor = color.bg;
      element.style.borderColor = color.border;
      if (element.classList.contains('span-main-word')) {
        element.style.borderWidth = '2px';
        element.style.borderStyle = 'solid';
      } else {
        // Для оборотов - только фон, текст остается белым
        element.style.color = 'var(--text-primary)';
      }
    }
    
    // Находим все объяснения на странице
    const allExplanations = document.querySelectorAll('.task17-explanation-content');
    
    allExplanations.forEach(explanationDiv => {
      // Находим все главные слова с data-color-id
      const mainWords = explanationDiv.querySelectorAll('.span-main-word[data-color-id]');
      
      mainWords.forEach((mainWord) => {
        const colorId = mainWord.getAttribute('data-color-id');
        if (!colorId || colorId === '') return;
        
        const colorIndex = parseInt(colorId);
        const color = colorPalette[colorIndex % colorPalette.length];
        
        // Применяем цвет к главному слову
        applyColor(mainWord, color);
        
        // Применяем цвет ко всем связанным оборотам
        const linkedTurns = explanationDiv.querySelectorAll(`[data-linked-to="${colorId}"]`);
        linkedTurns.forEach(turn => {
          applyColor(turn, color);
        });
      });
    });
  }
  
  // Делаем функцию доступной глобально
  window.applyColorsInExplanation = applyColorsInExplanation;

  // Глобальные переменные для режима связывания
  let selectedMainWord = null;
  let isLinkingMode = false;

  // Функционал для выбора цвета главного слова и связывания с оборотами
  function initMainWordColorSelection() {
    const colorPalette = [
      { bg: 'rgba(59, 130, 246, 0.3)', border: 'rgba(59, 130, 246, 0.8)', text: 'rgba(59, 130, 246, 1)' }, // Синий
      { bg: 'rgba(34, 197, 94, 0.3)', border: 'rgba(34, 197, 94, 0.8)', text: 'rgba(34, 197, 94, 1)' }, // Зеленый
      { bg: 'rgba(236, 72, 153, 0.3)', border: 'rgba(236, 72, 153, 0.8)', text: 'rgba(236, 72, 153, 1)' }, // Розовый
      { bg: 'rgba(251, 191, 36, 0.3)', border: 'rgba(251, 191, 36, 0.8)', text: 'rgba(251, 191, 36, 1)' }, // Желтый
      { bg: 'rgba(168, 85, 247, 0.3)', border: 'rgba(168, 85, 247, 0.8)', text: 'rgba(168, 85, 247, 1)' }, // Фиолетовый
      { bg: 'rgba(239, 68, 68, 0.3)', border: 'rgba(239, 68, 68, 0.8)', text: 'rgba(239, 68, 68, 1)' }, // Красный
      { bg: 'rgba(14, 165, 233, 0.3)', border: 'rgba(14, 165, 233, 0.8)', text: 'rgba(14, 165, 233, 1)' }, // Голубой
      { bg: 'rgba(245, 158, 11, 0.3)', border: 'rgba(245, 158, 11, 0.8)', text: 'rgba(245, 158, 11, 1)' }, // Оранжевый
    ];

    // Применяем цвет к элементу
    function applyColor(element, color) {
      element.style.backgroundColor = color.bg;
      if (element.classList.contains('span-main-word')) {
        element.style.borderColor = color.border;
        element.style.borderWidth = '2px';
        element.style.borderStyle = 'solid';
      } else {
        // Для оборотов - только фон, без обводки, текст остается белым
        element.style.color = 'var(--text-primary)'; // Оставляем белый цвет текста
        element.style.borderWidth = '0';
        element.style.borderStyle = 'none';
      }
    }

    // Удаляем цвет с элемента
    function removeColor(element) {
      element.style.backgroundColor = '';
      element.style.borderColor = '';
      element.style.color = '';
      if (element.classList.contains('span-main-word')) {
        element.style.borderWidth = '';
        element.style.borderStyle = '';
      }
    }

    // Получаем цвет для главного слова
    function getColorForMainWord(mainWord) {
      const colorId = mainWord.getAttribute('data-color-id');
      if (colorId !== null && colorId !== '') {
        const index = parseInt(colorId);
        return { index: index, color: colorPalette[index % colorPalette.length] };
      }
      // Если цвета нет, находим следующий свободный
      const usedColors = new Set();
      document.querySelectorAll('.task17-text-editable .span-main-word[data-color-id]').forEach(el => {
        const id = el.getAttribute('data-color-id');
        if (id !== null && id !== '') {
          usedColors.add(parseInt(id));
        }
      });
      
      let freeIndex = 0;
      while (usedColors.has(freeIndex) && freeIndex < colorPalette.length) {
        freeIndex++;
      }
      
      return { index: freeIndex, color: colorPalette[freeIndex % colorPalette.length] };
    }

    // Назначаем цвет главному слову автоматически
    function assignColorToMainWord(mainWord) {
      // Получаем или назначаем цвет
      const colorData = getColorForMainWord(mainWord);
      
      // Применяем цвет к главному слову
      mainWord.setAttribute('data-color-id', colorData.index);
      applyColor(mainWord, colorData.color);
      
      // Включаем режим связывания
      selectedMainWord = mainWord;
      isLinkingMode = true;
      mainWord.style.outline = '3px solid rgba(236, 72, 153, 0.8)';
      mainWord.style.outlineOffset = '2px';
    }

    // Связываем оборот с главным словом
    function linkTurnToMainWord(mainWord, turn) {
      const colorId = mainWord.getAttribute('data-color-id');
      if (!colorId || colorId === '') return;

      const colorIndex = parseInt(colorId);
      const color = colorPalette[colorIndex % colorPalette.length];

      // Применяем цвет к обороту
      applyColor(turn, color);
      turn.setAttribute('data-linked-to', colorId);
    }

    // Обработчик клика на главное слово для режима связывания
    document.addEventListener('click', (e) => {
      // Если режим связывания активен и клик по обороту
      if (isLinkingMode && selectedMainWord) {
        const turn = e.target.closest('.span-participle, .span-gerund');
        if (turn) {
          e.preventDefault();
          e.stopPropagation();
          linkTurnToMainWord(selectedMainWord, turn);
          selectedMainWord.style.outline = '';
          selectedMainWord.style.outlineOffset = '';
          selectedMainWord = null;
          isLinkingMode = false;
          return;
        }
      }

      // Проверяем, что клик по главному слову
      const mainWord = e.target.closest('.span-main-word');
      if (mainWord) {
        // Проверяем, есть ли выделение текста - если есть, не обрабатываем
        const selection = window.getSelection();
        if (selection.toString().trim().length > 0 && !selection.isCollapsed) {
          return;
        }
        
        // Если клик по главному слову и панель видна - это второй клик, включаем режим связывания
        const toolbar = document.getElementById('task17-floating-toolbar');
        if (toolbar && toolbar.classList.contains('show')) {
          // Включаем режим связывания (цвет уже назначен при создании)
          e.preventDefault();
          e.stopPropagation();
          selectedMainWord = mainWord;
          isLinkingMode = true;
          mainWord.style.outline = '3px solid rgba(236, 72, 153, 0.8)';
          mainWord.style.outlineOffset = '2px';
        }
      }
    }, false); // Используем bubble phase
  }

  // Устанавливаем подсветку при наведении в тон цвета главного слова
  function setupMainWordHoverGlow() {
    const processedElements = new WeakSet();

    function setupGlowForElement(mainWord) {
      if (processedElements.has(mainWord)) return;
      processedElements.add(mainWord);

      const borderColor = mainWord.style.borderColor;
      if (borderColor) {
        // Преобразуем цвет в rgba для свечения
        let glowColor = borderColor;
        if (glowColor.startsWith('rgb(')) {
          glowColor = glowColor.replace('rgb(', 'rgba(').replace(')', ', 0.6)');
        } else if (glowColor.startsWith('rgba(')) {
          glowColor = glowColor.replace(/,\s*[\d.]+\)$/, ', 0.6)');
        }

        let glowColorInner = borderColor;
        if (glowColorInner.startsWith('rgb(')) {
          glowColorInner = glowColorInner.replace('rgb(', 'rgba(').replace(')', ', 0.4)');
        } else if (glowColorInner.startsWith('rgba(')) {
          glowColorInner = glowColorInner.replace(/,\s*[\d.]+\)$/, ', 0.4)');
        }

        mainWord.addEventListener('mouseenter', function() {
          this.style.boxShadow = `0 0 12px ${glowColor}, 0 0 6px ${glowColorInner}`;
        });
        mainWord.addEventListener('mouseleave', function() {
          this.style.boxShadow = '';
        });
      }
    }

    const observer = new MutationObserver(() => {
      document.querySelectorAll('.span-main-word').forEach(setupGlowForElement);
    });

    // Наблюдаем за изменениями в DOM
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['style', 'data-color-id']
    });

    // Устанавливаем для существующих элементов
    setTimeout(() => {
      document.querySelectorAll('.span-main-word').forEach(setupGlowForElement);
    }, 100);
  }

  // Функционал для удаления выделений (отключен)
  /* function initMarkRemoval() {
    let deleteButton = null;
    let currentMark = null;

    // Создаем кнопку удаления
    function createDeleteButton() {
      if (deleteButton) return deleteButton;
      
      deleteButton = document.createElement('button');
      deleteButton.innerHTML = '🗑';
      deleteButton.className = 'task17-delete-mark-btn';
      deleteButton.style.cssText = `
        position: absolute;
        display: none;
        padding: 6px;
        font-size: 14px;
        border-radius: 6px;
        border: 1px solid rgba(239, 68, 68, 0.5);
        background: rgba(239, 68, 68, 0.2);
        color: #f87171;
        cursor: pointer;
        z-index: 10002;
        transition: all 0.2s;
        box-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
      `;
      deleteButton.onmouseenter = () => {
        deleteButton.style.background = 'rgba(239, 68, 68, 0.3)';
        deleteButton.style.borderColor = '#f87171';
      };
      deleteButton.onmouseleave = () => {
        deleteButton.style.background = 'rgba(239, 68, 68, 0.2)';
        deleteButton.style.borderColor = 'rgba(239, 68, 68, 0.5)';
      };
      deleteButton.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (currentMark) {
          // Удаляем выделение
          const textNode = document.createTextNode(currentMark.textContent);
          currentMark.parentNode.replaceChild(textNode, currentMark);
          hideDeleteButton();
        }
      };
      document.body.appendChild(deleteButton);
      return deleteButton;
    }

    // Показываем кнопку удаления
    function showDeleteButton(mark, event) {
      const button = createDeleteButton();
      currentMark = mark;
      
      const rect = mark.getBoundingClientRect();
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

      button.style.top = (rect.top + scrollTop - 35) + 'px';
      button.style.left = (rect.left + scrollLeft + rect.width / 2 - 15) + 'px';
      button.style.display = 'block';
      
      // Добавляем обработчики для кнопки, чтобы она не скрывалась при наведении
      button.addEventListener('mouseenter', () => {
        // Кнопка остается видимой
      });
      button.addEventListener('mouseleave', () => {
        hideDeleteButton();
      });
    }

    // Скрываем кнопку удаления
    function hideDeleteButton() {
      if (deleteButton && !deleteButton.matches(':hover')) {
        deleteButton.style.display = 'none';
        currentMark = null;
      }
    }

    // Устанавливаем обработчики наведения для всех выделений
    function setupHoverForMarks() {
      document.querySelectorAll('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word').forEach(mark => {
        if (mark.dataset.hoverSetup) return; // Уже настроено
        mark.dataset.hoverSetup = 'true';
        
        mark.addEventListener('mouseenter', (e) => {
          // Если наведение на главное слово и режим связывания активен - не показываем корзину
          if (mark.classList.contains('span-main-word') && isLinkingMode) {
            return;
          }
          showDeleteButton(mark, e);
        });
        
        mark.addEventListener('mouseleave', (e) => {
          // Небольшая задержка, чтобы можно было навести на кнопку
          setTimeout(() => {
            if (!deleteButton || (!deleteButton.matches(':hover') && e.relatedTarget !== deleteButton)) {
              hideDeleteButton();
            }
          }, 100);
        });
      });
    }

    // Наблюдаем за появлением новых выделений
    const markObserver = new MutationObserver(() => {
      setupHoverForMarks();
    });

    markObserver.observe(document.body, {
      childList: true,
      subtree: true
    });

    // Устанавливаем для существующих элементов
    setupHoverForMarks();

    // Скрываем кнопку при клике вне выделения
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word, .task17-delete-mark-btn')) {
        hideDeleteButton();
      }
    });

    // Скрываем кнопку при скролле
    window.addEventListener('scroll', hideDeleteButton);
  } */

  // Инициализируем после загрузки
  setTimeout(() => {
    initMainWordColorSelection();
    setupMainWordHoverGlow();
  }, 500);
</script>


