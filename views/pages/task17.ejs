<div class="task-page" id="task17App">
  <h2 class="task-page__title">Задание №17: Пунктуация</h2>
  
  <!-- Панель инструментов слева для выделений в предложении (sticky) -->
  <div id="task17-toolbar-left" class="task17-student-toolbar-left" style="
    position: fixed;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 200px;
    padding: 16px;
    background: var(--bg-tertiary);
    border-radius: var(--radius-lg);
    border: 1px solid var(--glass-border);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    display: block;
  ">
    <div style="margin-bottom: 12px; color: var(--text-primary); font-weight: 600; font-size: 14px;">
      Инструменты выделения
    </div>
    
    <div style="display: flex; flex-direction: column; gap: 8px;">
      <button type="button" class="btn btn-sm" id="task17-mark-participle-text" style="width: 100%; justify-content: flex-start;">
        <span style="text-decoration: underline wavy;">Причастный</span>
      </button>
      <button type="button" class="btn btn-sm" id="task17-mark-gerund-text" style="width: 100%; justify-content: flex-start;">
        Деепричастный
      </button>
      <button type="button" class="btn btn-sm" id="task17-mark-main-word-text" style="width: 100%; justify-content: flex-start; border: 1px solid rgba(236, 72, 153, 0.5);">
        Главное слово
      </button>
      <button type="button" class="btn btn-sm btn-secondary" id="task17-remove-mark-text" style="width: 100%; justify-content: flex-start;">
        Убрать выделение
      </button>
    </div>
    
    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--glass-border); font-size: 11px; color: var(--text-secondary); line-height: 1.6;">
      <div style="margin-bottom: 6px;"><span class="span-participle" style="display: inline-block;">Причастный</span></div>
      <div style="margin-bottom: 6px;"><span class="span-gerund" style="display: inline-block; position: relative; padding-bottom: 2px;">Деепричастный</span></div>
      <div><span class="span-main-word" style="display: inline-block; position: relative;">Главное слово</span></div>
    </div>
  </div>
  
  <div id="task17Container">
    <div style="padding: 20px;">
      <p>Загрузка заданий...</p>
    </div>
  </div>
</div>

<style>
  /* Стили для отображения объяснения с подчеркиваниями */
  .task-page .span-participle,
  .task-page .span-gerund {
    position: relative;
  }
  
  .task-page .span-participle {
    text-decoration: underline;
    text-decoration-style: wavy;
    text-decoration-color: rgba(168, 85, 247, 0.8);
  }
  
  /* Стили для кликабельных цифр в задании №17 */
  .task17-digit {
    cursor: pointer;
    padding: 2px 6px;
    margin: 0 2px;
    border-radius: 4px;
    transition: all 0.2s;
    display: inline-block;
    position: relative;
  }
  
  .task17-digit:hover:not(.selected) {
    background-color: rgba(0, 240, 255, 0.2);
    box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
  }
  
  .task17-digit.selected {
    background-color: var(--neon-cyan);
    color: var(--bg-primary);
    font-weight: bold;
  }

  /* Стили для кликабельных пробелов в режиме без цифр */
  .task17-space {
    cursor: pointer !important;
    display: inline !important;
    padding: 0 !important;
    margin: 0 !important;
    border-radius: 3px;
    transition: all 0.2s ease;
    position: relative;
    user-select: none !important;
    -webkit-user-select: none !important;
    pointer-events: auto !important;
    background-color: transparent !important;
    vertical-align: baseline;
    border: none !important;
    z-index: 10;
  }

  .task17-space:hover {
    background-color: rgba(0, 240, 255, 0.25) !important;
    box-shadow: 0 0 10px rgba(0, 240, 255, 0.5) !important;
    outline: 1px solid rgba(0, 240, 255, 0.7) !important;
    outline-offset: -1px;
    /* Не меняем padding и margin, чтобы не было дрожания */
  }

  .task17-space:active {
    background-color: rgba(0, 240, 255, 0.35) !important;
  }

  .task17-space-with-comma:hover {
    background-color: rgba(0, 240, 255, 0.4) !important;
    box-shadow: 0 0 12px rgba(0, 240, 255, 0.7) !important;
  }
</style>

<!-- React через CDN -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">
  const { useState, useEffect, useRef } = React;

  // Общая функция для парсинга текста с метками (1), (2)...
  function parseTextWithDigits(text) {
    const parts = [];
    const regex = /\((\d+)\)/g;
    let lastIndex = 0;
    let match;

    while ((match = regex.exec(text)) !== null) {
      if (match.index > lastIndex) {
        parts.push({ text: text.substring(lastIndex, match.index), digit: null });
      }
      const digitNum = parseInt(match[1], 10);
      parts.push({ text: match[0], digit: digitNum });
      lastIndex = match.index + match[0].length;
    }

    if (lastIndex < text.length) {
      parts.push({ text: text.substring(lastIndex), digit: null });
    }

    return parts;
  }

  // Функция для парсинга текста с пробелами (для режима без цифр)
  // Обрабатывает все пробелы, делая их кликабельными
  function parseTextWithSpaces(text, correctCommaPositions = null) {
    const parts = [];
    
    if (!text || text.length === 0) {
      return parts;
    }
    
    // Преобразуем correctCommaPositions в Set для быстрой проверки
    const correctCommasSet = correctCommaPositions ? new Set(correctCommaPositions.map(p => Number(p))) : null;
    
    // Разбиваем текст на слова и пробелы, сохраняя позиции
    let currentOffset = 0;
    
    for (let i = 0; i < text.length; i++) {
      if (text[i] === ' ') {
        // Добавляем текст до пробела (если есть)
        if (i > currentOffset) {
          const textPart = text.substring(currentOffset, i);
          if (textPart.length > 0) {
            parts.push({ 
              text: textPart, 
              isClickable: false,
              offset: null
            });
          }
        }
        
        // Проверяем, нужно ли показать правильную запятую после этого символа (до пробела)
        // Если i - это позиция пробела, то правильная запятая должна быть на позиции i-1 (после последнего символа слова)
        // Но так как запятые ставятся на позициях пробелов, проверяем позицию i
        const shouldShowCorrectComma = correctCommasSet && correctCommasSet.has(i);
        
        // Пробел - кликабельный элемент
        parts.push({ 
          text: ' ', 
          isClickable: true,
          offset: i,
          showCorrectComma: shouldShowCorrectComma
        });
        currentOffset = i + 1;
      }
    }
    
    // Добавляем оставшийся текст (если есть)
    if (currentOffset < text.length) {
      const textPart = text.substring(currentOffset);
      if (textPart.length > 0) {
        parts.push({ 
          text: textPart, 
          isClickable: false,
          offset: null
        });
      }
    }
    
    return parts;
  }

  // Компонент для одного задания
  function Task17Item({ task, index, showDigits }) {
    const [currentMode, setCurrentMode] = useState('digits');
    const [taskData, setTaskData] = useState(null);
    const [selectedDigits, setSelectedDigits] = useState(new Set());
    const [commaPositions, setCommaPositions] = useState(new Set()); // Позиции запятых в commaless_text
    const [answerInput, setAnswerInput] = useState('');
    const [checkResult, setCheckResult] = useState(null);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    const [isLiked, setIsLiked] = useState(false);
    const [showSolution, setShowSolution] = useState(false);
    const [correctDigits, setCorrectDigits] = useState(new Set());
    const [correctCommaPositions, setCorrectCommaPositions] = useState(new Set()); // Правильные позиции запятых
    const [extraCommaPositions, setExtraCommaPositions] = useState(new Set()); // Лишние позиции запятых
    const inputRef = useRef(null);

    // Обновляем режим при изменении showDigits
    useEffect(() => {
      setCurrentMode(showDigits ? 'digits' : 'commas');
      setCommaPositions(new Set()); // Сбрасываем позиции запятых при смене режима
      setSelectedDigits(new Set()); // Сбрасываем выбранные цифры
      setCorrectCommaPositions(new Set()); // Сбрасываем правильные позиции
      setExtraCommaPositions(new Set()); // Сбрасываем лишние позиции
      setAnswerInput('');
    }, [showDigits]);

    // Загружаем задание
    useEffect(() => {
      const loadTask = async () => {
        try {
          setLoading(true);
          setCorrectDigits(new Set()); // Сбрасываем правильные цифры при загрузке
          setCorrectCommaPositions(new Set()); // Сбрасываем правильные позиции запятых
          setExtraCommaPositions(new Set()); // Сбрасываем лишние позиции запятых
          setCheckResult(null); // Сбрасываем результат проверки при загрузке нового задания
          const response = await fetch(`/api/task17/${task.id}/play?mode=${currentMode}`);
          if (!response.ok) throw new Error('Не удалось загрузить задание');
          const data = await response.json();
          
          // Нормализация пробелов уже делается на сервере
          setTaskData(data);
          setError(null);
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Ошибка загрузки');
        } finally {
          setLoading(false);
        }
      };
      loadTask();
    }, [task.id, currentMode]);

    // Применяем цвета при показе решения
    useEffect(() => {
      if (showSolution && taskData && taskData.explanation && taskData.explanation.explanation_md) {
        setTimeout(() => {
          const explanationDiv = document.getElementById(`task17-explanation-${task.id}`);
          if (explanationDiv && typeof applyColorsInExplanation === 'function') {
            applyColorsInExplanation();
          }
        }, 300);
      }
    }, [showSolution, taskData, task.id]);

    const handleDigitClick = (digit) => {
      setSelectedDigits(prevSelected => {
        const newSet = new Set(prevSelected);
        if (newSet.has(digit)) {
          newSet.delete(digit);
        } else {
          newSet.add(digit);
        }
        return newSet;
      });
    };

    const handleSpaceClick = (offset) => {
      setCommaPositions(prevPositions => {
        const newSet = new Set(prevPositions);
        if (newSet.has(offset)) {
          newSet.delete(offset);
        } else {
          newSet.add(offset);
        }
        return newSet;
      });
    };

    useEffect(() => {
      if (currentMode === 'digits') {
        const sortedDigits = Array.from(selectedDigits).sort((a, b) => a - b);
        setAnswerInput(sortedDigits.join(''));
      } else {
        const sortedPositions = Array.from(commaPositions).sort((a, b) => a - b);
        setAnswerInput(sortedPositions.join(', '));
      }
    }, [selectedDigits, commaPositions, currentMode]);

    const handleInputChange = (e) => {
      const value = e.target.value;
      setAnswerInput(value);
      const digits = value.split('').map(char => parseInt(char, 10)).filter(n => !isNaN(n) && n > 0);
      setSelectedDigits(new Set(digits));
    };

    const handleCheck = async () => {
      if (!taskData) return;
      
      let payload = { mode: currentMode, spans: [] };
      
      if (currentMode === 'digits') {
        const currentDigits = Array.from(selectedDigits).sort((a, b) => a - b);
        if (currentDigits.length === 0) {
          alert('Введите ответ, выбрав цифры в тексте или введя их вручную');
          if (inputRef.current) {
            inputRef.current.focus();
          }
          return;
        }
        payload.digits = currentDigits;
      } else {
        const currentCommaPositions = Array.from(commaPositions).sort((a, b) => a - b);
        if (currentCommaPositions.length === 0) {
          alert('Введите ответ, нажав на пробелы в тексте, где должны быть запятые');
          return;
        }
        payload.comma_positions = currentCommaPositions;
      }

      try {
        setLoading(true);
        const response = await fetch(`/api/task17/${task.id}/check`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) throw new Error('Ошибка проверки');
        const result = await response.json();
        setCheckResult(result);
        
        // Сохраняем правильные и лишние цифры для режима с цифрами
        if (currentMode === 'digits') {
          if (result.correctAnswer && result.digits && !result.digits.isCorrect) {
            setCorrectDigits(new Set(result.correctAnswer));
          } else {
            setCorrectDigits(new Set());
          }
          // Сбрасываем позиции запятых в режиме цифр
          setCorrectCommaPositions(new Set());
          setExtraCommaPositions(new Set());
        } else {
          // Режим запятых - сохраняем правильные и лишние позиции запятых
          if (result.commas) {
            // Сохраняем правильные позиции (показываем ВСЕГДА после проверки)
            if (result.correctAnswer && Array.isArray(result.correctAnswer)) {
              // Преобразуем в числа для корректного сравнения
              const correctPositions = result.correctAnswer.map(p => Number(p));
              console.log('Сохраняем правильные позиции запятых:', correctPositions);
              setCorrectCommaPositions(new Set(correctPositions));
            } else {
              console.log('correctAnswer не найден или не массив:', result.correctAnswer);
              setCorrectCommaPositions(new Set());
            }
            // Сохраняем лишние позиции
            if (result.commas.extra && Array.isArray(result.commas.extra)) {
              const extraPositions = result.commas.extra.map(p => Number(p));
              setExtraCommaPositions(new Set(extraPositions));
            } else {
              setExtraCommaPositions(new Set());
            }
          } else {
            setCorrectCommaPositions(new Set());
            setExtraCommaPositions(new Set());
          }
          // Сбрасываем цифры в режиме запятых
          setCorrectDigits(new Set());
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Ошибка проверки');
      } finally {
        setLoading(false);
      }
    };

    if (loading && !taskData) {
      return (
        <div className="task-card">
          <div className="task-content">
            <p>Загрузка задания {index + 1}...</p>
          </div>
        </div>
      );
    }

    if (error) {
      return (
        <div className="task-card">
          <div className="task-content">
            <p style={{color: 'red'}}>Ошибка: {error}</p>
          </div>
        </div>
      );
    }

    if (!taskData) {
      return null;
    }

    return (
      <div className="task-card" style={{marginBottom: '32px'}}>
        <div className="task-meta">
          <span className="task-meta__number">№ {index + 1}</span>
          {task.source && <span className="task-meta__source">{task.source}</span>}
        </div>
        
        <div className="task-content">
          <div className="task-prompt" style={{position: 'relative'}}>
            <div>
              {currentMode === 'digits' 
                ? 'Укажите цифру(-ы), на месте которой(-ых) должна(-ы) стоять запятая(-ые).'
                : 'Нажмите на пробелы в тексте, где должны стоять запятые.'}
            </div>
            <div 
              className="task17-text-editable"
              id={`task17-text-${task.id}`}
              style={{
                fontSize: '18px',
                lineHeight: '1.8',
                minHeight: '80px',
                padding: '16px',
                border: '1px solid var(--glass-border)',
                background: 'var(--bg-secondary)',
                position: 'relative'
              }}
              contentEditable={false}
              suppressContentEditableWarning={true}
            >
              {currentMode === 'digits' ? (
                parseTextWithDigits(taskData.text).map((part, idx) => {
                  if (part.digit !== null) {
                    const isSelected = selectedDigits.has(part.digit);
                    const isCorrect = correctDigits.has(part.digit);
                    return (
                      <span
                        key={`digit-${task.id}-${part.digit}-${idx}`}
                        className={`task17-digit ${isSelected ? 'selected' : ''} ${isCorrect ? 'correct-highlight' : ''}`}
                        data-digit={part.digit}
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          handleDigitClick(part.digit);
                        }}
                        title={`Кликните, чтобы ${isSelected ? 'убрать' : 'добавить'} цифру ${part.digit} в ответ`}
                        style={{
                          userSelect: 'none',
                          WebkitUserSelect: 'none',
                          cursor: 'pointer',
                          contentEditable: 'false',
                          ...(isCorrect && {
                            backgroundColor: 'rgba(34, 197, 94, 0.3)',
                            border: '2px solid rgba(34, 197, 94, 0.8)',
                            padding: '2px 4px'
                          })
                        }}
                        contentEditable={false}
                        suppressContentEditableWarning={true}
                      >
                        {part.text}
                      </span>
                    );
                  }
                  return <span key={`text-${task.id}-${idx}`}>{part.text}</span>;
                })
              ) : (
                parseTextWithSpaces(
                  taskData.text, 
                  checkResult && correctCommaPositions.size > 0
                    ? Array.from(correctCommaPositions) 
                    : null
                ).map((part, idx) => {
                  if (part.isClickable && part.offset !== null) {
                    const offset = Number(part.offset); // Убеждаемся, что offset - число
                    // Проверяем с учетом преобразования типов
                    const hasComma = commaPositions.has(offset);
                    // Проверяем правильность и лишние позиции (используем явное сравнение чисел)
                    const isCorrect = correctCommaPositions.has(offset);
                    const isExtra = extraCommaPositions.has(offset);
                    
                    // Отладка для первых нескольких позиций
                    if (idx < 3 && checkResult) {
                      console.log(`Позиция ${offset}: hasComma=${hasComma}, isCorrect=${isCorrect}, correctCommaPositions=`, Array.from(correctCommaPositions));
                    }
                    // Определяем стиль в зависимости от статуса позиции
                    let bgColor = 'transparent';
                    let textColor = 'inherit';
                    let fontWeight = 'normal';
                    // Показываем запятую если: выбрана пользователем ИЛИ правильная позиция после проверки
                    let displayComma = hasComma || (checkResult && isCorrect);
                    
                    if (checkResult) {
                      // После проверки показываем правильные и неправильные позиции
                      // Показываем ВСЕ правильные запятые после проверки
                      if (hasComma && isExtra) {
                        // Неправильная позиция - красная
                        bgColor = 'rgba(239, 68, 68, 0.3)';
                        textColor = '#ef4444';
                        fontWeight = 'bold';
                        displayComma = true;
                      } else if (isCorrect) {
                        // Правильная позиция (выбранная или нет) - зеленая
                        // Показываем ВСЕ правильные запятые после проверки
                        bgColor = 'rgba(34, 197, 94, 0.3)';
                        textColor = '#22c55e';
                        fontWeight = 'bold';
                        displayComma = true;
                      } else if (hasComma) {
                        // Выбрана, но не является ни правильной, ни лишней (не должно происходить, но на всякий случай)
                        bgColor = 'rgba(0, 240, 255, 0.3)';
                        textColor = 'var(--neon-cyan)';
                        fontWeight = 'bold';
                        displayComma = true;
                      }
                    } else {
                      // До проверки - обычная синяя подсветка
                      if (hasComma) {
                        bgColor = 'rgba(0, 240, 255, 0.3)';
                        textColor = 'var(--neon-cyan)';
                        fontWeight = 'bold';
                        displayComma = true;
                      }
                    }
                    
                    return (
                      <span
                        key={`space-${task.id}-${offset}-${idx}`}
                        className={`task17-space ${hasComma ? 'task17-space-with-comma' : ''} ${isCorrect ? 'task17-space-correct' : ''} ${isExtra ? 'task17-space-extra' : ''}`}
                        data-offset={offset}
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          handleSpaceClick(offset);
                        }}
                        title="Кликните, чтобы поставить запятую"
                        style={{
                          backgroundColor: bgColor,
                          color: textColor,
                          fontWeight: fontWeight
                        }}
                      >
                        {displayComma ? ',' : ' '}
                      </span>
                    );
                  }
                  return <span key={`text-${task.id}-${idx}`}>{part.text}</span>;
                })
              )}
            </div>
          </div>

          <div className="task-controls">
            {currentMode === 'digits' && (
              <input
                ref={inputRef}
                className="task-input"
                type="text"
                value={answerInput}
                onChange={handleInputChange}
                placeholder="Введите свой ответ"
                inputMode="numeric"
                onKeyPress={(e) => {
                  if (e.key === 'Enter') {
                    handleCheck();
                  }
                }}
              />
            )}
            <button
              className="task-send"
              onClick={handleCheck}
              disabled={loading}
            >
              <span>{loading ? 'Проверка...' : 'Отправить'}</span>
            </button>
            <button
              className="task-solution"
              onClick={() => setShowSolution(!showSolution)}
            >
              <span>Решение</span>
              <img src={showSolution ? "/images/eye on.svg" : "/images/eye off.svg"} alt="Глаз" width="16" height="16"/>
            </button>
            <button 
              className="task-like"
              onClick={() => setIsLiked(!isLiked)}
            >
              <img 
                src={isLiked ? "/images/heart on.svg" : "/images/heart off.svg"} 
                alt="Лайк" 
                width="16" 
                height="16"
              />
            </button>
          </div>

          {showSolution && taskData && taskData.explanation && (
            <div id={`task17-solution-block-${task.id}`} style={{marginTop: '24px'}}>
              {taskData.explanation.answer_text && (
                <div style={{marginBottom: '12px'}} className="solution-answer">
                  <strong>Ответ:</strong> {taskData.explanation.answer_text}
                </div>
              )}
              {taskData.explanation.explanation_md && (
                <div>
                  <h4 style={{marginTop: 0, marginBottom: '12px'}}>Объяснение:</h4>
                  <div
                    id={`task17-explanation-${task.id}`}
                    dangerouslySetInnerHTML={{
                      __html: taskData.explanation.explanation_md.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    }}
                    className="editor-content task17-explanation-content"
                    style={{
                      position: 'relative',
                      fontSize: '18px',
                      lineHeight: '1.8',
                      padding: '16px',
                      minHeight: '100px'
                    }}
                  />
                </div>
              )}
            </div>
          )}

          {checkResult && (
            <div className="task-solution-block" style={{marginTop: '24px'}}>
              <h3 style={{marginTop: 0, marginBottom: '16px'}}>Результат проверки</h3>
              
              {((currentMode === 'digits' && checkResult.digits && checkResult.digits.isCorrect) ||
                (currentMode === 'commas' && checkResult.commas && checkResult.commas.isCorrect)) ? (
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '12px',
                  padding: '16px',
                  background: 'rgba(34, 197, 94, 0.1)',
                  border: '2px solid rgba(34, 197, 94, 0.5)',
                  marginBottom: '16px'
                }}>
                  <div style={{
                    fontSize: '32px',
                    color: '#22c55e',
                    lineHeight: '1'
                  }}>
                    ✓
                  </div>
                  <div style={{
                    fontSize: '18px',
                    fontWeight: 'bold',
                    color: '#22c55e'
                  }}>
                    Все верно!
                  </div>
                </div>
              ) : (
                <div style={{marginBottom: '16px'}}>
                  <div style={{
                    fontWeight: 'bold',
                    color: '#f6b462',
                    marginBottom: '12px',
                    fontSize: '16px'
                  }}>
                    Ответ неверный
                  </div>
                  {checkResult.correctAnswer && (
                    <div style={{
                      padding: '12px',
                      background: 'rgba(239, 68, 68, 0.1)',
                      border: '1px solid rgba(239, 68, 68, 0.3)',
                      marginBottom: '12px'
                    }}>
                      <div style={{
                        color: 'var(--text-secondary)',
                        marginBottom: '4px',
                        fontSize: '14px'
                      }}>
                        Правильный ответ:
                      </div>
                      <div style={{
                        fontSize: '18px',
                        fontWeight: 'bold',
                        color: '#22c55e'
                      }}>
                        {checkResult.correctAnswer.join(', ')}
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    );
  }

  // Компонент для списка всех заданий
  function Task17List() {
    const [allTasks, setAllTasks] = useState([]);
    const [loading, setLoading] = useState(true);
    const [showDigits, setShowDigits] = useState(true);
    const [showToolbar, setShowToolbar] = useState(true);

    useEffect(() => {
      const loadAllTasks = async () => {
        try {
          const response = await fetch('/api/task17');
          if (!response.ok) throw new Error('Не удалось загрузить список заданий');
          const tasks = await response.json();
          setAllTasks(tasks);
        } catch (err) {
          console.error('Ошибка загрузки списка заданий:', err);
        } finally {
          setLoading(false);
        }
      };
      loadAllTasks();
    }, []);

    // Управление видимостью левой панели инструментов
    useEffect(() => {
      const toolbarLeft = document.getElementById('task17-toolbar-left');
      if (toolbarLeft) {
        toolbarLeft.style.display = showToolbar ? 'block' : 'none';
      }
    }, [showToolbar]);

    // Применяем скрытие цифр ко всем заданиям
    useEffect(() => {
      const allTextEditors = document.querySelectorAll('.task17-text-editable');
      allTextEditors.forEach(editor => {
        const digits = editor.querySelectorAll('.task17-digit');
        digits.forEach(digit => {
          digit.style.display = showDigits ? '' : 'none';
        });
      });
    }, [showDigits]);

    if (loading) {
      return (
        <div style={{padding: '20px'}}>
          <p>Загрузка заданий...</p>
        </div>
      );
    }

    if (allTasks.length === 0) {
      return (
        <div style={{padding: '20px'}}>
          <p>Заданий №17 пока нет.</p>
        </div>
      );
    }

    return (
      <div className="task17-wrapper">
        <div style={{flex: 1, maxWidth: '800px'}}>
          {allTasks.map((task, index) => (
            <Task17Item key={task.id} task={task} index={index} showDigits={showDigits} />
          ))}
        </div>
        {/* Правая панель с переключателями */}
        <div className="task17-control-panel">
          <div style={{
            marginBottom: '16px',
            color: 'var(--text-primary)',
            fontWeight: 600,
            fontSize: '14px'
          }}>
            Настройки отображения
          </div>
          
          <div style={{display: 'flex', flexDirection: 'column', gap: '16px'}}>
            <label style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              cursor: 'pointer',
              color: 'var(--text-primary)',
              fontSize: '14px'
            }}>
              <span>Показывать цифры</span>
              <div
                onClick={() => setShowDigits(!showDigits)}
                style={{
                  width: '48px',
                  height: '24px',
                  background: showDigits ? 'var(--neon-cyan)' : 'var(--text-disabled)',
                  position: 'relative',
                  cursor: 'pointer',
                  transition: 'all 0.3s ease',
                  boxShadow: showDigits ? '0 0 10px rgba(0, 240, 255, 0.5)' : 'none'
                }}
              >
                <div
                  style={{
                    width: '20px',
                    height: '20px',
                    borderRadius: '50%',
                    background: '#fff',
                    position: 'absolute',
                    top: '2px',
                    left: showDigits ? '26px' : '2px',
                    transition: 'all 0.3s ease',
                    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)'
                  }}
                />
              </div>
            </label>
            
            <label style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              cursor: 'pointer',
              color: 'var(--text-primary)',
              fontSize: '14px'
            }}>
              <span>Панель выделений</span>
              <div
                onClick={() => setShowToolbar(!showToolbar)}
                style={{
                  width: '48px',
                  height: '24px',
                  background: showToolbar ? 'var(--neon-cyan)' : 'var(--text-disabled)',
                  position: 'relative',
                  cursor: 'pointer',
                  transition: 'all 0.3s ease',
                  boxShadow: showToolbar ? '0 0 10px rgba(0, 240, 255, 0.5)' : 'none'
                }}
              >
                <div
                  style={{
                    width: '20px',
                    height: '20px',
                    borderRadius: '50%',
                    background: '#fff',
                    position: 'absolute',
                    top: '2px',
                    left: showToolbar ? '26px' : '2px',
                    transition: 'all 0.3s ease',
                    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)'
                  }}
                />
              </div>
            </label>
          </div>
        </div>
      </div>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('task17Container'));
  root.render(<Task17List />);
</script>

<script>
  // Инициализация панели инструментов для выделений
  function initTextToolbar() {
    const markParticipleBtn = document.getElementById('task17-mark-participle-text');
    const markGerundBtn = document.getElementById('task17-mark-gerund-text');
    const markMainWordBtn = document.getElementById('task17-mark-main-word-text');
    const removeMarkBtn = document.getElementById('task17-remove-mark-text');

    if (!markParticipleBtn || !markGerundBtn || !markMainWordBtn || !removeMarkBtn) return;

    function applySpanClass(className) {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;

      const range = selection.getRangeAt(0);
      const parent = range.commonAncestorContainer.nodeType === 3 
        ? range.commonAncestorContainer.parentElement 
        : range.commonAncestorContainer;

      let editor = parent;
      while (editor && !editor.classList.contains('task17-text-editable')) {
        editor = editor.parentElement;
      }

      if (!editor) {
        alert('Поместите курсор в текст задания');
        return;
      }

      const selectedText = selection.toString().trim();
      if (!selectedText) {
        alert('Выделите текст для отметки');
        return;
      }

      try {
        // Функция для расширения range до ближайших пробелов
        function expandRangeToSpaces(range) {
          const expandedRange = range.cloneRange();
          
          // Расширяем начало влево до пробела
          let startContainer = expandedRange.startContainer;
          let startOffset = expandedRange.startOffset;
          
          // Если начало в текстовом узле
          if (startContainer.nodeType === Node.TEXT_NODE) {
            const text = startContainer.textContent;
            let newOffset = startOffset;
            // Ищем пробел слева
            while (newOffset > 0 && text[newOffset - 1] !== ' ') {
              newOffset--;
            }
            expandedRange.setStart(startContainer, newOffset);
          } else {
            // Если начало в элементе, ищем первый текстовый узел внутри
            const walker = document.createTreeWalker(
              startContainer,
              NodeFilter.SHOW_TEXT,
              null
            );
            const firstTextNode = walker.nextNode();
            if (firstTextNode) {
              const text = firstTextNode.textContent;
              let spacePos = text.lastIndexOf(' ');
              if (spacePos >= 0) {
                expandedRange.setStart(firstTextNode, spacePos + 1);
              } else {
                expandedRange.setStart(firstTextNode, 0);
              }
            }
          }
          
          // Расширяем конец вправо до пробела
          let endContainer = expandedRange.endContainer;
          let endOffset = expandedRange.endOffset;
          
          // Если конец в текстовом узле
          if (endContainer.nodeType === Node.TEXT_NODE) {
            const text = endContainer.textContent;
            let newOffset = endOffset;
            // Ищем пробел справа
            while (newOffset < text.length && text[newOffset] !== ' ') {
              newOffset++;
            }
            // Включаем пробел, если он есть
            if (newOffset < text.length && text[newOffset] === ' ') {
              newOffset++;
            }
            expandedRange.setEnd(endContainer, newOffset);
          } else {
            // Если конец в элементе, ищем последний текстовый узел внутри
            const walker = document.createTreeWalker(
              endContainer,
              NodeFilter.SHOW_TEXT,
              null
            );
            let lastTextNode = null;
            let node;
            while (node = walker.nextNode()) {
              lastTextNode = node;
            }
            if (lastTextNode) {
              const text = lastTextNode.textContent;
              let spacePos = text.indexOf(' ');
              if (spacePos >= 0) {
                expandedRange.setEnd(lastTextNode, spacePos + 1);
              } else {
                expandedRange.setEnd(lastTextNode, text.length);
              }
            }
          }
          
          // Если range пересекает несколько узлов, расширяем границы
          // Расширяем начало, проходя по предыдущим узлам
          while (true) {
            const startContainer = expandedRange.startContainer;
            const startOffset = expandedRange.startOffset;
            
            if (startContainer.nodeType === Node.TEXT_NODE && startOffset === 0) {
              // Дошли до начала текстового узла, проверяем предыдущий узел
              const prevNode = startContainer.previousSibling;
              if (prevNode && prevNode.nodeType === Node.TEXT_NODE) {
                const text = prevNode.textContent;
                const spacePos = text.lastIndexOf(' ');
                if (spacePos >= 0) {
                  expandedRange.setStart(prevNode, spacePos + 1);
                  continue;
                } else {
                  expandedRange.setStart(prevNode, 0);
                  continue;
                }
              }
            }
            break;
          }
          
          // Расширяем конец, проходя по следующим узлам
          while (true) {
            const endContainer = expandedRange.endContainer;
            const endOffset = expandedRange.endOffset;
            
            if (endContainer.nodeType === Node.TEXT_NODE && 
                endOffset >= endContainer.textContent.length) {
              // Дошли до конца текстового узла, проверяем следующий узел
              const nextNode = endContainer.nextSibling;
              if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
                const text = nextNode.textContent;
                const spacePos = text.indexOf(' ');
                if (spacePos >= 0) {
                  expandedRange.setEnd(nextNode, spacePos + 1);
                  continue;
                } else {
                  expandedRange.setEnd(nextNode, text.length);
                  continue;
                }
              }
            }
            break;
          }
          
          return expandedRange;
        }

        // Расширяем range до пробелов
        const expandedRange = expandRangeToSpaces(range);
        
        // Проверяем, что есть выделение
        const expandedText = expandedRange.toString();
        if (!expandedText || expandedText.trim() === '') {
          alert('Не удалось расширить выделение');
          return;
        }

        const span = document.createElement('span');
        span.className = className;

        if (className === 'span-main-word') {
          span.setAttribute('data-color-id', '');
        }

        // Пытаемся использовать surroundContents для сохранения пробелов
        try {
          expandedRange.surroundContents(span);
        } catch (e) {
          // Если surroundContents не работает (range пересекает границы элементов),
          // используем extractContents с сохранением структуры
          const contents = expandedRange.extractContents();
          span.appendChild(contents);
          expandedRange.insertNode(span);
        }
        
        selection.removeAllRanges();
      } catch (err) {
        console.error('Ошибка при применении стиля:', err);
      }
    }

    markParticipleBtn.addEventListener('click', () => applySpanClass('span-participle'));
    markGerundBtn.addEventListener('click', () => applySpanClass('span-gerund'));
    markMainWordBtn.addEventListener('click', () => applySpanClass('span-main-word'));

    removeMarkBtn.addEventListener('click', () => {
      const selection = window.getSelection();
      if (!selection.rangeCount) {
        alert('Выделите текст для удаления отметки');
        return;
      }

      const range = selection.getRangeAt(0);
      const parent = range.commonAncestorContainer.nodeType === 3 
        ? range.commonAncestorContainer.parentElement 
        : range.commonAncestorContainer;

      if (parent && (parent.classList.contains('span-participle') || 
                     parent.classList.contains('span-gerund') || 
                     parent.classList.contains('span-main-word'))) {
        const textNode = document.createTextNode(parent.textContent);
        parent.parentNode.replaceChild(textNode, parent);
        selection.removeAllRanges();
      } else {
        alert('Выделите текст с отметкой для удаления');
      }
    });
  }

  setTimeout(() => {
    initTextToolbar();
  }, 500);

  // Функция для применения цветов в объяснении
  function applyColorsInExplanation() {
    // Палитра цветов (та же, что в админке)
    const colorPalette = [
      { bg: 'rgba(59, 130, 246, 0.3)', border: 'rgba(59, 130, 246, 0.8)', text: 'rgba(59, 130, 246, 1)' }, // Синий
      { bg: 'rgba(34, 197, 94, 0.3)', border: 'rgba(34, 197, 94, 0.8)', text: 'rgba(34, 197, 94, 1)' }, // Зеленый
      { bg: 'rgba(236, 72, 153, 0.3)', border: 'rgba(236, 72, 153, 0.8)', text: 'rgba(236, 72, 153, 1)' }, // Розовый
      { bg: 'rgba(251, 191, 36, 0.3)', border: 'rgba(251, 191, 36, 0.8)', text: 'rgba(251, 191, 36, 1)' }, // Желтый
      { bg: 'rgba(168, 85, 247, 0.3)', border: 'rgba(168, 85, 247, 0.8)', text: 'rgba(168, 85, 247, 1)' }, // Фиолетовый
      { bg: 'rgba(239, 68, 68, 0.3)', border: 'rgba(239, 68, 68, 0.8)', text: 'rgba(239, 68, 68, 1)' }, // Красный
      { bg: 'rgba(14, 165, 233, 0.3)', border: 'rgba(14, 165, 233, 0.8)', text: 'rgba(14, 165, 233, 1)' }, // Голубой
      { bg: 'rgba(245, 158, 11, 0.3)', border: 'rgba(245, 158, 11, 0.8)', text: 'rgba(245, 158, 11, 1)' }, // Оранжевый
    ];
    
    // Применяем цвет к элементу
    function applyColor(element, color) {
      element.style.backgroundColor = color.bg;
      element.style.borderColor = color.border;
      if (element.classList.contains('span-main-word')) {
        element.style.borderWidth = '2px';
        element.style.borderStyle = 'solid';
      } else {
        element.style.color = color.text;
      }
    }
    
    // Находим все объяснения на странице
    const allExplanations = document.querySelectorAll('.task17-explanation-content');
    
    allExplanations.forEach(explanationDiv => {
      // Находим все главные слова с data-color-id
      const mainWords = explanationDiv.querySelectorAll('.span-main-word[data-color-id]');
      
      mainWords.forEach((mainWord) => {
        const colorId = mainWord.getAttribute('data-color-id');
        if (!colorId || colorId === '') return;
        
        const colorIndex = parseInt(colorId);
        const color = colorPalette[colorIndex % colorPalette.length];
        
        // Применяем цвет к главному слову
        applyColor(mainWord, color);
        
        // Применяем цвет ко всем связанным оборотам
        const linkedTurns = explanationDiv.querySelectorAll(`[data-linked-to="${colorId}"]`);
        linkedTurns.forEach(turn => {
          applyColor(turn, color);
        });
      });
    });
  }
  
  // Делаем функцию доступной глобально
  window.applyColorsInExplanation = applyColorsInExplanation;
</script>


