        <div class="admin-page">
          <h2 class="admin-page__title">Администрирование</h2>
          
          <!-- Хлебные крошки -->
          <nav class="breadcrumbs" id="breadcrumbs">
            <a href="#" class="breadcrumb-link" onclick="showSection('type-selection'); return false;">Админка</a>
          </nav>

          <!-- Выбор типа задания -->
          <div id="type-selection-tab" class="admin-tab-content active">
            <div class="admin-section">
              <h3>Управление типами заданий</h3>
              
              <!-- Форма редактирования типа задания -->
              <div id="edit-task-type-form" class="admin-form" style="display: none;">
                <h4>Редактировать тип задания</h4>
                <form id="task-type-form">
                  <input type="hidden" id="task-type-id" name="id" value="">
                  <div class="form-group">
                    <label for="task-type-title">Название:</label>
                    <input type="text" id="task-type-title" name="title" placeholder="Название типа задания" required>
                  </div>
                  <div class="form-group">
                    <label for="task-type-description">Описание:</label>
                    <textarea id="task-type-description" name="description" rows="2" placeholder="Описание типа задания"></textarea>
                  </div>
                  <div class="form-group">
                    <label for="task-type-form-config">Конфигурация формы (JSON):</label>
                    <textarea id="task-type-form-config" name="form_config" rows="3" placeholder='{"fields": ["prompt", "context", "answer"]}'></textarea>
                  </div>
                  <div class="form-actions">
                    <button type="submit" class="btn">Сохранить</button>
                    <button type="button" class="btn btn-secondary" onclick="cancelEditTaskType()">Отмена</button>
                  </div>
                </form>
              </div>
              
              <div class="task-types-grid" id="task-types-grid">
                <p>Загрузка типов заданий...</p>
              </div>
            </div>
          </div>

          <!-- Управление темами -->
          <div id="subtopics-tab" class="admin-tab-content" style="display: none;">
            <div class="admin-section">
              <h3>Добавить тему для типа задания</h3>
              <form id="add-subtopic-form" class="admin-form">
                <input type="hidden" id="subtopic-type" name="type_id" value="">
                <div class="form-group">
                  <label for="subtopic-title">Название темы:</label>
                  <input type="text" id="subtopic-title" name="title" placeholder="Название темы" required>
                </div>
                <button type="submit" class="btn">Добавить тему</button>
              </form>
            </div>
        
            <div class="admin-section">
              <h3>Существующие темы</h3>
              <div id="subtopics-list" class="admin-list">
                <!-- Темы будут загружены через JavaScript -->
              </div>
            </div>
          </div>

          <!-- Управление заданием №17 -->
          <div id="task17-tab" class="admin-tab-content" style="display: none;">
            <div class="admin-section">
              <h3>Задание №17: Пунктуация</h3>
              <form id="task17-form" class="admin-form">
                <input type="hidden" id="task17-id" name="id" value="">
                
                <div class="form-group">
                  <label for="task17-source">Источник:</label>
                  <select id="task17-source" name="source">
                    <option value="">Выберите источник</option>
                    <option value="__new__">+ Новый</option>
                    <!-- Источники будут загружены через JavaScript -->
                  </select>
                  <input type="text" id="task17-source-new" placeholder="Введите название нового источника" style="display: none; margin-top: 8px;">
                  <small>Выберите источник из списка или выберите "+ Новый" для добавления</small>
                </div>
                
                <div class="form-group">
                  <label for="task17-text">Задание (предложение с метками (1), (2)...):</label>
                  <textarea id="task17-text" name="text" rows="3" placeholder="Высокие, узкие клочья тумана (1) густые и белые (2) бродили над рекой (3) заслоняя (4) отражение звёзд (5) и (6) цепляясь (7) за ивы." required></textarea>
                  <small>Введите предложение с метками цифр в местах, где нужно расставить запятые</small>
                </div>

                <div class="form-group">
                  <label for="task17-answer">Ответ (цифры через запятую или пробел):</label>
                  <input type="text" id="task17-answer" name="answer" placeholder="1,2,3,4,5,6,7" required>
                  <small>Порядок цифр не важен. Можно ввести: 1,2,3,4,5,6,7 или 1234567 или 7 6 5 4 3 2 1</small>
                  <small style="display: block; margin-top: 4px; color: var(--text-secondary);">Позиции запятых вычисляются автоматически на основе правильных цифр</small>
                </div>

                <!-- Редактируемое объяснение (как у учеников) -->
                <div class="form-group" style="margin-top: 24px;">
                  <label style="margin-bottom: 12px; display: block;">Объяснение (предложение с запятыми вместо цифр из ответа, редактируйте и добавляйте подчеркивания):</label>
                  
                  <div style="display: flex; gap: 16px; align-items: flex-start;">
                    <!-- Редактор объяснения - редактируемое поле с предложением (как у учеников) -->
                    <div style="flex: 1; position: relative;">
                      <div 
                        id="task17-explanation-editor" 
                        class="task17-explanation-editor" 
                        contenteditable="true" 
                        data-placeholder="Высокие, узкие клочья тумана (1) густые и белые (2) бродили над рекой (3) заслоняя (4) отражение звёзд (5) и (6) цепляясь (7) за ивы."
                        style="
                          min-height: 300px; 
                          padding: 20px; 
                          border: 1px solid var(--glass-border); 
                          border-radius: var(--radius-lg); 
                          background: var(--glass-bg);
                          backdrop-filter: var(--glass-backdrop);
                          -webkit-backdrop-filter: var(--glass-backdrop);
                          box-shadow: var(--shadow-glass);
                          color: var(--text-primary); 
                          font-family: inherit; 
                          font-size: 18px; 
                          line-height: 1.8;
                          white-space: pre-wrap;
                        "
                      ></div>
                      <textarea id="task17-explanation" name="explanation" style="display: none;"></textarea>
                      <!-- Скрытое поле для сохранения исходного текста задания -->
                      <input type="hidden" id="task17-text" name="text">
                      
                    </div>
                  </div>
                  
                  <!-- Плавающая панель инструментов выделения -->
                  <div id="task17-admin-floating-toolbar" class="text-selection-toolbar">
                    <!-- Кнопки будут добавлены динамически -->
                  </div>
                  
                  <small style="display: block; margin-top: 12px;">Предложение автоматически обновляется из задания выше. Выделите текст и используйте плавающую панель для добавления подчеркиваний</small>
                </div>
                
                <div class="form-actions">
                  <button type="submit" class="btn">Сохранить задание</button>
                  <button type="button" class="btn btn-secondary" onclick="resetTask17Form()">Очистить</button>
                </div>
              </form>
            </div>
            
            <div class="admin-section">
              <h3>Существующие задания №17</h3>
              <div id="task17-list" class="admin-list">
                <!-- Задания будут загружены через JavaScript -->
              </div>
            </div>
          </div>

          <!-- Управление заданиями -->
          <div id="assignments-tab" class="admin-tab-content" style="display: none;">
            <div class="admin-section">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <h3 id="assignment-type-title" style="margin: 0;">Добавить новое задание</h3>
                <a href="#" class="admin-link-subtle" onclick="event.preventDefault(); switchToSubtopicsTab(); return false;" title="Управление темами (откроется в новой вкладке)">Управление темами</a>
              </div>
              <form id="add-assignment-form" class="admin-form">
                <input type="hidden" id="assignment-id" name="id" value="">
                <div class="form-group">
                  <label for="assignment-fipi-number">Номер ФИПИ (необязательно):</label>
                  <input type="text" id="assignment-fipi-number" name="fipi_number" placeholder="12345">
                </div>
                <div class="form-group">
                  <label for="assignment-source">Источник:</label>
                  <select id="assignment-source" name="source" required>
                    <option value="">Выберите источник</option>
                    <option value="ФИПИ">ФИПИ</option>
                    <option value="Другой источник">Другой источник</option>
                  </select>
                </div>
                <div class="form-group">
                  <label for="assignment-prompt">Условие задания:</label>
                  <div id="editor-prompt" class="editor-container"></div>
                  <textarea id="assignment-prompt" name="prompt" style="display: none;" required></textarea>
                </div>
                <div class="form-group">
                  <label for="assignment-subtopic">Тема (необязательно):</label>
                  <select id="assignment-subtopic" name="subtopic_id">
                    <option value="">Без темы</option>
                    <!-- Опции будут загружены через JavaScript -->
                  </select>
                </div>
                <div class="form-group">
                  <label for="assignment-context">Контекст (текст для задания):</label>
                  <div id="editor-context" class="editor-container editor-large"></div>
                  <textarea id="assignment-context" name="context" style="display: none;"></textarea>
                </div>
        <div class="form-group">
          <label for="assignment-answer">Правильный ответ:</label>
          <input type="text" id="assignment-answer" name="answer" placeholder="него" required>
        </div>
        <div class="form-group">
          <label for="assignment-explanation">Объяснение (необязательно):</label>
          <div id="editor-explanation" class="editor-container"></div>
          <textarea id="assignment-explanation" name="explanation" style="display: none;"></textarea>
        </div>
        <div class="form-group">
          <label for="assignment-rule-ref">Ссылка на правило (необязательно):</label>
          <input type="text" id="assignment-rule-ref" name="rule_ref" placeholder="§ 15.2">
        </div>
        <div class="form-group">
          <label for="assignment-alt-answers">Дополнительные ответы (через запятую):</label>
          <input type="text" id="assignment-alt-answers" name="alt_answers" placeholder="его, её, их">
        </div>
        <button type="submit" class="btn">Добавить задание</button>
      </form>
    </div>

    <div class="admin-section">
      <h3>Существующие задания</h3>
      <div id="assignments-list" class="admin-list">
        <!-- Задания будут загружены через JavaScript -->
      </div>
    </div>
  </div>
</div>

<script src="/js/text-selection-toolbar.js"></script>
<script>
  // Переключение секций
  function showSection(sectionId) {
    // Если возвращаемся к выбору типа, очищаем сохраненное состояние
    if (sectionId === 'type-selection') {
      localStorage.removeItem('adminCurrentSection');
      localStorage.removeItem('adminSelectedType');
      window.selectedTaskType = null;
    } else {
      // Сохраняем текущую секцию
      localStorage.setItem('adminCurrentSection', sectionId);
    }
    
    // Скрываем все секции
    document.querySelectorAll('.admin-tab-content').forEach(content => {
      content.style.display = 'none';
      content.classList.remove('active');
    });
    
    // Показываем нужную секцию
    const section = document.getElementById(`${sectionId}-tab`);
    if (section) {
      section.style.display = 'block';
      section.classList.add('active');
      
      // Загружаем данные для секции
      if (sectionId === 'type-selection') {
        loadTaskTypes();
        updateBreadcrumbs([]);
      } else if (sectionId === 'subtopics') {
        loadSubtopics();
      } else if (sectionId === 'assignments') {
        loadAssignments();
        loadSubtopicsForSelect('#assignment-subtopic');
        setTimeout(async () => {
          await ensureEditorsInitialized();
        }, 100);
      }
    }
  }
  window.showSection = showSection;

  // Обновление хлебных крошек
  function updateBreadcrumbs(paths) {
    const breadcrumbs = document.getElementById('breadcrumbs');
    if (!breadcrumbs) return;
    
    breadcrumbs.innerHTML = '<a href="#" class="breadcrumb-link" onclick="showSection(\'type-selection\'); return false;">Админка</a>';
    
    paths.forEach((path, index) => {
      const separator = document.createElement('span');
      separator.className = 'breadcrumb-separator';
      separator.textContent = '›';
      breadcrumbs.appendChild(separator);
      
      if (path.action && index < paths.length - 1) {
        // Кликабельная ссылка с действием
        const link = document.createElement('a');
        link.href = '#';
        link.className = 'breadcrumb-link';
        link.textContent = path.label;
        link.onclick = (e) => {
          e.preventDefault();
          if (path.action) {
            path.action();
          }
          return false;
        };
        breadcrumbs.appendChild(link);
      } else {
        // Текущий элемент (не кликабельный)
        const span = document.createElement('span');
        span.className = 'breadcrumb-current';
        span.textContent = path.label;
        breadcrumbs.appendChild(span);
      }
    });
  }

  // Навигация теперь только через хлебные крошки

          // Загрузка данных для вкладки
          async function loadTabData(tab) {
            if (tab === 'type-selection') {
              await loadTaskTypes();
            } else if (tab === 'subtopics') {
              await loadSubtopics();
            } else if (tab === 'assignments') {
              await loadAssignments();
              await loadSubtopicsForSelect('#assignment-subtopic');
              // Инициализируем редакторы при переключении на вкладку заданий
              // Ждем небольшую задержку, чтобы вкладка точно стала видимой
              setTimeout(async () => {
                await ensureEditorsInitialized();
              }, 100);
            }
          }
          
          // Убеждаемся, что редакторы инициализированы при переключении на вкладку
          async function ensureEditorsInitialized() {
            // Проверяем, что вкладка заданий видима
            const assignmentsTab = document.getElementById('assignments-tab');
            if (!assignmentsTab || !assignmentsTab.classList.contains('active')) {
              return;
            }
            
            // Функция проверки всех необходимых компонентов (List опционален)
            const allRequiredPluginsLoaded = () => {
              return typeof EditorJS !== 'undefined' &&
                     typeof Header !== 'undefined' &&
                     typeof Paragraph !== 'undefined' &&
                     typeof Quote !== 'undefined' &&
                     typeof CodeTool !== 'undefined' &&
                     typeof Delimiter !== 'undefined' &&
                     typeof Marker !== 'undefined' &&
                     typeof InlineCode !== 'undefined';
            };
            
            if (!allRequiredPluginsLoaded()) {
              let attempts = 0;
              const maxAttempts = 50;
              while (attempts < maxAttempts && !allRequiredPluginsLoaded()) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
              }
              
              if (!allRequiredPluginsLoaded()) {
                console.error('Не все обязательные плагины Editor.js загружены. Используем fallback режим.');
                enableFallbackMode();
                return;
              }
            }
            
            // Дополнительная задержка для гарантии видимости элементов
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Инициализируем редакторы
            initializeEditors();
          }

  // Загрузка типов заданий
  async function loadTaskTypes() {
    try {
      const response = await fetch('/api/admin/task-types');
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      const taskTypes = await response.json();
      
      const grid = document.getElementById('task-types-grid');
      if (taskTypes.length === 0) {
        grid.innerHTML = '<p>Типы заданий не найдены</p>';
        return;
      }
      
      grid.innerHTML = taskTypes.map(type => `
        <div class="task-type-card" data-type-id="${type.id}">
          <div class="task-type-content" onclick="selectTaskType(${type.id}, '${type.title}')">
            <div class="task-type-number">${type.id}</div>
            <div class="task-type-title">${type.title}</div>
            <div class="task-type-description">${type.description}</div>
          </div>
          <div class="task-type-actions">
            <button class="btn btn-sm btn-secondary" onclick="editTaskType(${type.id})">Редактировать</button>
          </div>
        </div>
      `).join('');
    } catch (error) {
      console.error('Ошибка загрузки типов заданий:', error);
      const grid = document.getElementById('task-types-grid');
      grid.innerHTML = '<p style="color: red;">Ошибка загрузки типов заданий. Проверьте консоль.</p>';
    }
  }

          // Выбор типа задания
          function selectTaskType(typeId, typeTitle) {
            // Если выбрано задание №17, показываем специальный интерфейс
            if (typeId === 17) {
              showTask17Admin();
              return;
            }
            
            // Сохраняем выбранный тип
            window.selectedTaskType = { id: typeId, title: typeTitle };
            
            // Сохраняем состояние в localStorage
            localStorage.setItem('adminSelectedType', JSON.stringify({ id: typeId, title: typeTitle }));
            localStorage.setItem('adminCurrentSection', 'assignments');
            
            // Устанавливаем type_id для формы тем
            const subtopicTypeInput = document.getElementById('subtopic-type');
            if (subtopicTypeInput) subtopicTypeInput.value = typeId;
            
            // Обновляем заголовок для заданий
            const assignmentTypeTitle = document.getElementById('assignment-type-title');
            if (assignmentTypeTitle) {
              assignmentTypeTitle.textContent = `Добавить задание для типа ${typeId}: ${typeTitle}`;
            }
            
            const assignmentTypeInput = document.getElementById('assignment-type');
            if (assignmentTypeInput) assignmentTypeInput.value = typeId;
            
            // Показываем секцию заданий
            showSection('assignments');
            
            // Обновляем хлебные крошки
            updateBreadcrumbs([
              { 
                label: `Тип ${typeId}: ${typeTitle}`,
                action: () => {
                  showSection('assignments');
                  updateBreadcrumbs([
                    { label: `Тип ${typeId}: ${typeTitle}` },
                    { label: 'Задания' }
                  ]);
                }
              },
              { label: 'Задания' }
            ]);
          }

  // Загрузка тем
  async function loadSubtopics() {
    try {
      const typeId = window.selectedTaskType ? window.selectedTaskType.id : null;
      const url = typeId ? `/api/admin/subtopics?typeId=${typeId}` : '/api/admin/subtopics';
      
      const response = await fetch(url);
      const subtopics = await response.json();
      
      const list = document.getElementById('subtopics-list');
      list.innerHTML = subtopics.map(subtopic => `
        <div class="admin-item">
          <div class="item-info">
            <strong>${subtopic.title}</strong>
          </div>
          <button class="btn btn-danger btn-sm" onclick="deleteSubtopic(${subtopic.id})">Удалить</button>
        </div>
      `).join('');
    } catch (error) {
      console.error('Ошибка загрузки тем:', error);
    }
  }

  // Загрузка заданий
  async function loadAssignments() {
    try {
      const typeId = window.selectedTaskType ? window.selectedTaskType.id : null;
      const url = typeId ? `/api/admin/assignments?typeId=${typeId}` : '/api/admin/assignments';
      
      const response = await fetch(url);
      const assignments = await response.json();
      
      const list = document.getElementById('assignments-list');
      list.innerHTML = assignments.map(assignment => {
        // Создаем превью для prompt
        let promptPreview = '';
        try {
          const promptData = typeof assignment.prompt === 'string' ? JSON.parse(assignment.prompt) : assignment.prompt;
          promptPreview = EditorRenderer.createPreview(promptData, 100);
        } catch (e) {
          promptPreview = assignment.prompt.substring(0, 100) + '...';
        }
        
        return `
        <div class="admin-item">
          <div class="item-info">
            <strong>ID ${assignment.id}:</strong> ${assignment.source} ${assignment.fipi_number ? `(ФИПИ №${assignment.fipi_number})` : ''}
            ${assignment.subtopic_title ? `<br><small>Тема: ${assignment.subtopic_title}</small>` : ''}
            <br><small>Условие: ${promptPreview}</small>
            <br><small>Ответ: ${assignment.answer}</small>
          </div>
          <div class="item-actions">
            <button class="btn btn-secondary btn-sm" onclick="window.open('/admin/assignment/${assignment.id}/edit', '_blank')">Редактировать</button>
            <button class="btn btn-danger btn-sm" onclick="deleteAssignment(${assignment.id})">Удалить</button>
          </div>
        </div>
      `;
      }).join('');
    } catch (error) {
      console.error('Ошибка загрузки заданий:', error);
    }
  }

  // Загрузка тем для селекта
  async function loadSubtopicsForSelect(selector) {
    try {
      const typeId = window.selectedTaskType ? window.selectedTaskType.id : null;
      const url = typeId ? `/api/admin/subtopics?typeId=${typeId}` : '/api/admin/subtopics';
      
      const response = await fetch(url);
      const subtopics = await response.json();
      
      const select = document.querySelector(selector);
      if (select) {
        select.innerHTML = '<option value="">Без темы</option>' + 
          subtopics.map(subtopic => 
            `<option value="${subtopic.id}">${subtopic.title}</option>`
          ).join('');
      }
    } catch (error) {
      console.error('Ошибка загрузки тем для селекта:', error);
    }
  }

  // Загрузка типов заданий для селекта
  async function loadTaskTypesForSelect(selector) {
    try {
      const response = await fetch('/api/admin/task-types');
      const taskTypes = await response.json();
      
      const select = document.querySelector(selector);
      if (select) {
        select.innerHTML = '<option value="">Выберите тип задания</option>' + 
          taskTypes.map(type => 
            `<option value="${type.id}">Тип ${type.id}: ${type.title}</option>`
          ).join('');
      } else {
        console.error('Селект не найден:', selector);
      }
    } catch (error) {
      console.error('Ошибка загрузки типов заданий:', error);
    }
  }

  // Загрузка заданий для селекта
  async function loadAssignmentsForSelect(selector) {
    try {
      const response = await fetch('/api/admin/assignments');
      const assignments = await response.json();
      
      const select = document.querySelector(selector);
      if (select) {
        select.innerHTML = '<option value="">Выберите задание</option>' + 
          assignments.map(assignment => 
            `<option value="${assignment.id}">${assignment.title}</option>`
          ).join('');
      } else {
        console.error('Селект не найден:', selector);
      }
    } catch (error) {
      console.error('Ошибка загрузки заданий:', error);
    }
  }

  // Общая функция отправки формы
  async function submitForm(form, endpoint, successMessage, reloadFunction) {
    try {
      const formData = new FormData(form);
      const data = Object.fromEntries(formData);
      
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      if (response.ok) {
        alert(successMessage);
        form.reset();
        if (reloadFunction) reloadFunction();
      } else {
        alert('Ошибка сохранения');
      }
    } catch (error) {
      console.error('Ошибка:', error);
      alert('Ошибка сохранения');
    }
  }

  // Обработчики форм
  document.getElementById('add-subtopic-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    await submitForm(e.target, '/api/admin/subtopics', 'Тема добавлена!', loadSubtopics);
  });

  document.getElementById('add-assignment-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    // Сохраняем данные из редакторов
    await saveEditorData();
    
    const formData = new FormData(e.target);
    const data = Object.fromEntries(formData);
    
    // Обрабатываем дополнительные ответы
    if (data.alt_answers) {
      data.alt_answers = data.alt_answers.split(',').map(s => s.trim()).filter(s => s);
    }
    
    const isEdit = data.id && data.id !== '';
    const url = isEdit ? `/api/admin/assignments/${data.id}` : '/api/admin/assignments';
    const method = isEdit ? 'PUT' : 'POST';
    const successMessage = isEdit ? 'Задание обновлено!' : 'Задание добавлено!';
    
    try {
      const response = await fetch(url, {
        method: method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      if (response.ok) {
        alert(successMessage);
        e.target.reset();
        document.getElementById('assignment-id').value = '';
        resetFormToAddMode();
        loadAssignments();
      } else {
        alert('Ошибка сохранения задания');
      }
    } catch (error) {
      console.error('Ошибка:', error);
      alert('Ошибка сохранения задания');
    }
  });

  // Общая функция удаления
  async function deleteItem(id, endpoint, successMessage, reloadFunction) {
    if (confirm('Удалить?')) {
      try {
        const response = await fetch(endpoint, { method: 'DELETE' });
        if (response.ok) {
          alert(successMessage);
          if (reloadFunction) reloadFunction();
        } else {
          alert('Ошибка удаления');
        }
      } catch (error) {
        console.error('Ошибка удаления:', error);
      }
    }
  }

  // Функции удаления
  window.deleteSubtopic = (id) => deleteItem(id, `/api/admin/subtopics/${id}`, 'Тема удалена!', loadSubtopics);
  window.deleteAssignment = (id) => deleteItem(id, `/api/admin/assignments/${id}`, 'Задание удалено!', loadAssignments);

  // Функция сброса формы к режиму добавления
  function resetFormToAddMode() {
    document.querySelector('#assignments-tab .admin-section h3').textContent = 'Добавить новое задание';
    document.querySelector('#add-assignment-form button').textContent = 'Добавить задание';
    
    // Обновляем хлебные крошки
    const selectedType = window.selectedTaskType;
    if (selectedType) {
      updateBreadcrumbs([
        { 
          label: `Тип ${selectedType.id}: ${selectedType.title}`,
          action: () => {
            showSection('assignments');
            updateBreadcrumbs([
              { label: `Тип ${selectedType.id}: ${selectedType.title}` },
              { label: 'Задания' }
            ]);
          }
        },
        { label: 'Задания' }
      ]);
    }
  }

  // Функция переключения на редактирование тем (открывает новую страницу)
  function switchToSubtopicsTab() {
    const selectedType = window.selectedTaskType;
    if (selectedType) {
      window.open(`/admin/subtopics/${selectedType.id}`, '_blank');
    }
  }
  window.switchToSubtopicsTab = switchToSubtopicsTab;

          // Функция редактирования типа задания
          window.editTaskType = async function(id) {
            try {
              const response = await fetch(`/api/admin/task-types/${id}`);
              const taskType = await response.json();
              
              // Заполняем форму
              document.getElementById('task-type-id').value = taskType.id;
              document.getElementById('task-type-title').value = taskType.title;
              document.getElementById('task-type-description').value = taskType.description || '';
              document.getElementById('task-type-form-config').value = taskType.form_config || '';
              
              // Показываем форму
              document.getElementById('edit-task-type-form').style.display = 'block';
              document.getElementById('task-type-form').scrollIntoView({ behavior: 'smooth' });
              
            } catch (error) {
              console.error('Ошибка загрузки типа задания:', error);
              alert('Ошибка загрузки типа задания');
            }
          };

          // Функция отмены редактирования
          window.cancelEditTaskType = function() {
            document.getElementById('edit-task-type-form').style.display = 'none';
            document.getElementById('task-type-form').reset();
          };

          // Обработчик формы редактирования типа задания
          document.getElementById('task-type-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            try {
              const formData = new FormData(e.target);
              const data = Object.fromEntries(formData);
              
              const response = await fetch(`/api/admin/task-types/${data.id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
              });
              
              if (response.ok) {
                alert('Тип задания обновлен!');
                document.getElementById('edit-task-type-form').style.display = 'none';
                e.target.reset();
                loadTaskTypes(); // Перезагружаем список
              } else {
                alert('Ошибка обновления типа задания');
              }
            } catch (error) {
              console.error('Ошибка:', error);
              alert('Ошибка обновления типа задания');
            }
          });

          // Восстановление состояния при загрузке страницы
          async function restoreAdminState() {
            try {
              // Проверяем сохраненное состояние
              const savedSection = localStorage.getItem('adminCurrentSection');
              const savedType = localStorage.getItem('adminSelectedType');
              
              if (savedType && savedSection && savedSection !== 'type-selection') {
                // Восстанавливаем выбранный тип
                const typeData = JSON.parse(savedType);
                window.selectedTaskType = typeData;
                
                // Устанавливаем type_id для формы тем
                const subtopicTypeInput = document.getElementById('subtopic-type');
                if (subtopicTypeInput) subtopicTypeInput.value = typeData.id;
                
                // Обновляем заголовок для заданий
                const assignmentTypeTitle = document.getElementById('assignment-type-title');
                if (assignmentTypeTitle) {
                  assignmentTypeTitle.textContent = `Добавить задание для типа ${typeData.id}: ${typeData.title}`;
                }
                
                const assignmentTypeInput = document.getElementById('assignment-type');
                if (assignmentTypeInput) assignmentTypeInput.value = typeData.id;
                
                // Восстанавливаем хлебные крошки
                if (savedSection === 'assignments') {
                  updateBreadcrumbs([
                    { 
                      label: `Тип ${typeData.id}: ${typeData.title}`,
                      action: () => {
                        showSection('assignments');
                        updateBreadcrumbs([
                          { label: `Тип ${typeData.id}: ${typeData.title}` },
                          { label: 'Задания' }
                        ]);
                      }
                    },
                    { label: 'Задания' }
                  ]);
                } else if (savedSection === 'subtopics') {
                  updateBreadcrumbs([
                    { 
                      label: `Тип ${typeData.id}: ${typeData.title}`,
                      action: () => {
                        showSection('subtopics');
                        updateBreadcrumbs([
                          { label: `Тип ${typeData.id}: ${typeData.title}` },
                          { label: 'Темы' }
                        ]);
                      }
                    },
                    { label: 'Темы' }
                  ]);
                }
                
                // Показываем сохраненную секцию
                showSection(savedSection);
              } else {
                // Показываем начальную секцию выбора типа
                showSection('type-selection');
                loadTaskTypes();
              }
            } catch (error) {
              console.error('Ошибка восстановления состояния:', error);
              // В случае ошибки показываем начальную секцию
              showSection('type-selection');
              loadTaskTypes();
            }
          }

          // Загружаем данные для активной вкладки при загрузке страницы
          document.addEventListener('DOMContentLoaded', () => {
            restoreAdminState();
          });
</script>

<!-- Editor.js CDN - загружаем последовательно для гарантии загрузки всех плагинов -->
<script>
  // Функция последовательной загрузки скриптов с проверкой
  function loadScript(src, expectedGlobal = null) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = src;
      script.onload = () => {
        // Даем время на инициализацию глобальных переменных
        setTimeout(() => {
          if (expectedGlobal) {
            const varNames = Array.isArray(expectedGlobal) ? expectedGlobal : [expectedGlobal];
            const allFound = varNames.every(name => typeof window[name] !== 'undefined');
            
            if (!allFound && expectedGlobal === 'List') {
              // Для List пробуем альтернативные пути
              if (typeof window.List === 'undefined' && typeof List !== 'undefined') {
                window.List = List;
              }
            }
          }
          resolve();
        }, 100);
      };
      script.onerror = () => {
        console.error('Ошибка загрузки:', src);
        reject(new Error(`Не удалось загрузить ${src}`));
      };
      document.head.appendChild(script);
    });
  }

  // Загружаем все скрипты Editor.js последовательно
  (async () => {
    try {
      await loadScript('https://cdn.jsdelivr.net/npm/@editorjs/editorjs@2.31.0', 'EditorJS');
      await loadScript('https://cdn.jsdelivr.net/npm/@editorjs/header@2.8.8', 'Header');
      // Пробуем загрузить List (опциональный плагин)
      try {
        await loadScript('https://cdn.jsdelivr.net/npm/@editorjs/list@2.0.8', 'List');
        await new Promise(resolve => setTimeout(resolve, 200));
        if (typeof List !== 'undefined' && typeof window.List === 'undefined') {
          window.List = List;
        }
      } catch (e) {
        // Пробуем альтернативный CDN
        try {
          await loadScript('https://unpkg.com/@editorjs/list@2.0.8', 'List');
          if (typeof List !== 'undefined' && typeof window.List === 'undefined') {
            window.List = List;
          }
        } catch (e2) {
          // List опционален, продолжаем без него
        }
      }
      await loadScript('https://cdn.jsdelivr.net/npm/@editorjs/paragraph@2.11.7', 'Paragraph');
      await loadScript('https://cdn.jsdelivr.net/npm/@editorjs/quote@2.7.6', 'Quote');
      await loadScript('https://cdn.jsdelivr.net/npm/@editorjs/code@2.9.3', 'CodeTool');
      await loadScript('https://cdn.jsdelivr.net/npm/@editorjs/delimiter@1.4.2', 'Delimiter');
      await loadScript('https://cdn.jsdelivr.net/npm/@editorjs/marker@1.4.0', 'Marker');
      await loadScript('https://cdn.jsdelivr.net/npm/@editorjs/inline-code@1.5.2', 'InlineCode');
      
      // Если List все еще не найден, пробуем альтернативный CDN
      if (typeof List === 'undefined' && typeof window.List === 'undefined') {
        try {
          await loadScript('https://unpkg.com/@editorjs/list@2.0.8', 'List');
        } catch (e) {
          // List опционален, продолжаем без него
        }
      }
      
      // Устанавливаем флаг готовности
      window.editorJSReady = true;
      
      // Если страница уже загружена, запускаем проверку
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(() => {
          if (window.onEditorJSLoad) {
            window.onEditorJSLoad();
          }
        }, 100);
      }
    } catch (error) {
      console.error('Ошибка загрузки Editor.js:', error);
      window.editorJSReady = false;
      if (window.onEditorJSError) {
        window.onEditorJSError(error);
      }
    }
  })();
</script>

<!-- Editor Renderer -->
<script src="/js/editor-renderer.js"></script>

<script>
  // Глобальные переменные для редакторов
  let editorPrompt = null;
  let editorContext = null;
  let editorExplanation = null;

  // Инициализация редакторов
  function initializeEditors() {
    // Проверяем наличие Editor.js и всех плагинов
    if (typeof EditorJS === 'undefined') {
      console.error('EditorJS не определен!');
      enableFallbackMode();
      return;
    }
    
    const requiredPlugins = ['Header', 'Paragraph', 'Quote', 'CodeTool', 'Delimiter', 'Marker', 'InlineCode'];
    const missingPlugins = requiredPlugins.filter(plugin => typeof window[plugin] === 'undefined');
    
    if (missingPlugins.length > 0) {
      console.error('Критические плагины не загружены:', missingPlugins);
      enableFallbackMode();
      return;
    }
    
    // Проверяем, что элементы существуют
    const promptEl = document.getElementById('editor-prompt');
    const contextEl = document.getElementById('editor-context');
    const explanationEl = document.getElementById('editor-explanation');
    
    if (!promptEl || !contextEl || !explanationEl) {
      console.error('Элементы редакторов не найдены!');
      enableFallbackMode();
      return;
    }

    // Проверяем, что вкладка заданий активна
    const assignmentsTab = document.getElementById('assignments-tab');
    if (!assignmentsTab || !assignmentsTab.classList.contains('active')) {
      return;
    }

    // Проверяем видимость элементов
    const stylePrompt = window.getComputedStyle(promptEl);
    const styleContext = window.getComputedStyle(contextEl);
    const styleExplanation = window.getComputedStyle(explanationEl);
    
    if (stylePrompt.display === 'none' || styleContext.display === 'none' || styleExplanation.display === 'none') {
      return;
    }

    // Уничтожаем старые редакторы, если они есть
    if (editorPrompt) {
      try {
        editorPrompt.destroy();
      } catch (e) {
        // Игнорируем ошибки уничтожения
      }
      editorPrompt = null;
    }
    if (editorContext) {
      try {
        editorContext.destroy();
      } catch (e) {
        // Игнорируем ошибки уничтожения
      }
      editorContext = null;
    }
    if (editorExplanation) {
      try {
        editorExplanation.destroy();
      } catch (e) {
        // Игнорируем ошибки уничтожения
      }
      editorExplanation = null;
    }
    
    // Редактор для условия задания
    try {
      editorPrompt = new EditorJS({
        holder: 'editor-prompt',
        placeholder: 'Введите условие задания...',
        data: { blocks: [] },
        tools: {
          header: {
            class: Header,
            config: {
              placeholder: 'Заголовок',
              levels: [1, 2, 3, 4, 5, 6],
              defaultLevel: 3
            }
          },
          // Добавляем list только если он доступен
          ...(typeof window.List !== 'undefined' || typeof List !== 'undefined' ? {
            list: {
              class: (typeof window.List !== 'undefined' ? window.List : List),
              inlineToolbar: true,
              config: {
                defaultStyle: 'unordered'
              }
            }
          } : {}),
          paragraph: {
            class: Paragraph,
            inlineToolbar: true
          },
          quote: {
            class: Quote,
            inlineToolbar: true,
            shortcut: 'CMD+SHIFT+O',
            config: {
              quotePlaceholder: 'Цитата',
              captionPlaceholder: 'Автор цитаты',
            }
          },
          code: {
            class: CodeTool,
            config: {
              placeholder: 'Введите код...'
            }
          },
          delimiter: Delimiter,
          marker: {
            class: Marker,
            shortcut: 'CMD+SHIFT+M'
          },
          inlineCode: {
            class: InlineCode,
            shortcut: 'CMD+SHIFT+C'
          }
        }
      });
    } catch (error) {
      console.error('Ошибка инициализации редактора prompt:', error);
    }

    // Редактор для контекста
    try {
      const ListClass = (typeof window.List !== 'undefined' ? window.List : (typeof List !== 'undefined' ? List : null));
      
      editorContext = new EditorJS({
      holder: 'editor-context',
      placeholder: 'Введите текст для задания...',
      data: { blocks: [] },
      tools: {
        header: {
          class: Header,
          config: {
            placeholder: 'Заголовок',
            levels: [1, 2, 3, 4, 5, 6],
            defaultLevel: 3
          }
        },
        // Добавляем list только если он доступен
        ...(ListClass ? {
          list: {
            class: ListClass,
            inlineToolbar: true,
            config: {
              defaultStyle: 'unordered'
            }
          }
        } : {}),
        paragraph: {
          class: Paragraph,
          inlineToolbar: true
        },
        quote: {
          class: Quote,
          inlineToolbar: true,
          shortcut: 'CMD+SHIFT+O',
          config: {
            quotePlaceholder: 'Цитата',
            captionPlaceholder: 'Автор цитаты',
          }
        },
        code: {
          class: CodeTool,
          config: {
            placeholder: 'Введите код...'
          }
        },
        delimiter: Delimiter,
        marker: {
          class: Marker,
          shortcut: 'CMD+SHIFT+M'
        },
        inlineCode: {
          class: InlineCode,
          shortcut: 'CMD+SHIFT+C'
        }
      }
    });
    } catch (error) {
      console.error('Ошибка инициализации редактора context:', error);
    }

    // Редактор для объяснения
    try {
      const ListClass = (typeof window.List !== 'undefined' ? window.List : (typeof List !== 'undefined' ? List : null));
      
      editorExplanation = new EditorJS({
      holder: 'editor-explanation',
      placeholder: 'Введите объяснение правила...',
      data: { blocks: [] },
      tools: {
        header: {
          class: Header,
          config: {
            placeholder: 'Заголовок',
            levels: [1, 2, 3, 4, 5, 6],
            defaultLevel: 3
          }
        },
        // Добавляем list только если он доступен
        ...(ListClass ? {
          list: {
            class: ListClass,
            inlineToolbar: true,
            config: {
              defaultStyle: 'unordered'
            }
          }
        } : {}),
        paragraph: {
          class: Paragraph,
          inlineToolbar: true
        },
        quote: {
          class: Quote,
          inlineToolbar: true,
          shortcut: 'CMD+SHIFT+O',
          config: {
            quotePlaceholder: 'Цитата',
            captionPlaceholder: 'Автор цитаты',
          }
        },
        code: {
          class: CodeTool,
          config: {
            placeholder: 'Введите код...'
          }
        },
        delimiter: Delimiter,
        marker: {
          class: Marker,
          shortcut: 'CMD+SHIFT+M'
        },
        inlineCode: {
          class: InlineCode,
          shortcut: 'CMD+SHIFT+C'
        }
      }
    });
    } catch (error) {
      console.error('Ошибка инициализации редактора explanation:', error);
    }
    
    // Проверяем успешность инициализации
    if (!editorPrompt || !editorContext || !editorExplanation) {
      console.error('Не все редакторы инициализированы:', {
        prompt: !!editorPrompt,
        context: !!editorContext,
        explanation: !!editorExplanation
      });
    }
  }

  // Функция для получения данных из редактора и сохранения в textarea
  async function saveEditorData() {
    try {
      // Проверяем, работаем ли мы в fallback режиме
      if (document.getElementById('assignment-prompt').style.display !== 'none') {
        return;
      }

      if (editorPrompt) {
        const promptData = await editorPrompt.save();
        document.getElementById('assignment-prompt').value = JSON.stringify(promptData);
      }
      
      if (editorContext) {
        const contextData = await editorContext.save();
        document.getElementById('assignment-context').value = JSON.stringify(contextData);
      }
      
      if (editorExplanation) {
        const explanationData = await editorExplanation.save();
        document.getElementById('assignment-explanation').value = JSON.stringify(explanationData);
      }
    } catch (error) {
      console.error('Ошибка сохранения данных редактора:', error);
    }
  }

  // Функция для загрузки данных в редактор из JSON
  async function loadEditorData(promptJson, contextJson, explanationJson) {
    try {
      // Функция преобразования данных в формат Editor.js
      const prepareData = (data) => {
        if (!data) return null;
        
        // Если уже объект Editor.js
        if (typeof data === 'object' && data !== null && data.blocks && Array.isArray(data.blocks)) {
          return data;
        }
        
        // Если строка - пытаемся парсить как JSON
        if (typeof data === 'string') {
          if (data.trim().startsWith('{')) {
            try {
              const parsed = JSON.parse(data);
              if (parsed && parsed.blocks && Array.isArray(parsed.blocks)) {
                return parsed;
              }
            } catch (e) {
              // Не JSON, создаем простой параграф
            }
          }
          // Простой текст - создаем параграф
          return {
            blocks: [{
              type: 'paragraph',
              data: { text: data }
            }]
          };
        }
        
        return null;
      };
      
      // Загружаем prompt
      if (editorPrompt) {
        const promptData = prepareData(promptJson);
        if (promptData) {
          await editorPrompt.render(promptData);
        }
      }
      
      // Загружаем context
      if (editorContext) {
        const contextData = prepareData(contextJson);
        if (contextData) {
          await editorContext.render(contextData);
        } else {
          // Очищаем редактор если данных нет
          await editorContext.render({ blocks: [] });
        }
      }
      
      // Загружаем explanation
      if (editorExplanation) {
        const explanationData = prepareData(explanationJson);
        if (explanationData) {
          await editorExplanation.render(explanationData);
        } else {
          // Очищаем редактор если данных нет
          await editorExplanation.render({ blocks: [] });
        }
      }
    } catch (error) {
      console.error('Ошибка загрузки данных в редакторы:', error);
    }
  }

  // Функция проверки всех необходимых компонентов (List опционален)
  const allPluginsLoaded = () => {
    return typeof EditorJS !== 'undefined' &&
           typeof Header !== 'undefined' &&
           typeof Paragraph !== 'undefined' &&
           typeof Quote !== 'undefined' &&
           typeof CodeTool !== 'undefined' &&
           typeof Delimiter !== 'undefined' &&
           typeof Marker !== 'undefined' &&
           typeof InlineCode !== 'undefined';
  };

  // Функция проверки и инициализации при готовности
  function checkAndInitEditors() {
    if (allPluginsLoaded()) {
      // Если вкладка заданий уже активна, инициализируем редакторы
      const assignmentsTab = document.getElementById('assignments-tab');
      if (assignmentsTab && assignmentsTab.classList.contains('active')) {
        setTimeout(async () => {
          await ensureEditorsInitialized();
        }, 300);
      }
    } else {
      // Продолжаем проверку
      let checkCount = 0;
      const checkInterval = setInterval(() => {
        checkCount++;
        if (allPluginsLoaded()) {
          clearInterval(checkInterval);
          checkAndInitEditors();
        } else if (checkCount > 50) {
          console.error('Editor.js не загрузился за 5 секунд');
          clearInterval(checkInterval);
          enableFallbackMode();
        }
      }, 100);
    }
  }

  // Обработчик успешной загрузки Editor.js
  window.onEditorJSLoad = checkAndInitEditors;
  
  // Обработчик ошибки загрузки Editor.js
  window.onEditorJSError = (error) => {
    console.error('Ошибка загрузки Editor.js:', error);
    enableFallbackMode();
  };

  // Инициализация редакторов после загрузки страницы
  window.addEventListener('load', () => {
    // Если Editor.js уже загружен, сразу проверяем
    if (window.editorJSReady) {
      checkAndInitEditors();
    } else {
      // Иначе ждем загрузки через интервал
      let checkCount = 0;
      const checkInterval = setInterval(() => {
        checkCount++;
        if (window.editorJSReady && allPluginsLoaded()) {
          clearInterval(checkInterval);
          checkAndInitEditors();
        } else if (checkCount > 50) {
          console.error('Editor.js не загрузился за 5 секунд');
          clearInterval(checkInterval);
          enableFallbackMode();
        }
      }, 100);
    }
  });

  // Fallback режим - показываем обычные textarea
  function enableFallbackMode() {
    // Показываем скрытые textarea
    const promptTextarea = document.getElementById('assignment-prompt');
    const contextTextarea = document.getElementById('assignment-context');
    const explanationTextarea = document.getElementById('assignment-explanation');
    
    if (promptTextarea) {
      promptTextarea.style.display = 'block';
      promptTextarea.required = true;
    }
    if (contextTextarea) {
      contextTextarea.style.display = 'block';
    }
    if (explanationTextarea) {
      explanationTextarea.style.display = 'block';
    }
    
    // Скрываем контейнеры редакторов
    const editorContainers = document.querySelectorAll('.editor-container');
    editorContainers.forEach(container => {
      container.style.display = 'none';
    });
  }

  // ===== КАСТОМНЫЙ DROPDOWN В СТИЛЕ САЙТА =====
  function initCustomDropdowns() {
    // Удаляем все существующие кастомные dropdown перед повторной инициализацией
    document.querySelectorAll('.custom-dropdown').forEach(dropdown => {
      const select = dropdown.querySelector('select');
      if (select) {
        // Восстанавливаем select в исходное положение
        const parent = dropdown.parentNode;
        if (parent) {
          parent.insertBefore(select, dropdown);
          select.style.position = '';
          select.style.opacity = '';
          select.style.pointerEvents = '';
          select.style.width = '';
          select.style.height = '';
          select.style.left = '';
          select.style.top = '';
          select.style.visibility = '';
          select.style.zIndex = '';
        }
        dropdown.remove();
      }
    });

    document.querySelectorAll('.admin-form select, .form-group select').forEach(select => {
      // Пропускаем если уже инициализирован
      if (select.closest('.custom-dropdown')) return;

      // Создаем обертку
      const wrapper = document.createElement('div');
      wrapper.className = 'custom-dropdown';
      select.parentNode.insertBefore(wrapper, select);
      
      // Перемещаем select в wrapper и полностью скрываем
      wrapper.appendChild(select);
      select.style.position = 'absolute';
      select.style.opacity = '0';
      select.style.pointerEvents = 'none';
      select.style.width = '1px';
      select.style.height = '1px';
      select.style.left = '-9999px';
      select.style.top = '-9999px';
      select.style.visibility = 'hidden';
      select.style.zIndex = '-1';

      // Создаем trigger
      const trigger = document.createElement('div');
      trigger.className = 'custom-dropdown__trigger';
      trigger.setAttribute('tabindex', '0');
      
      const triggerText = document.createElement('span');
      triggerText.className = 'custom-dropdown__trigger-text';
      trigger.appendChild(triggerText);
      
      const arrow = document.createElement('div');
      arrow.className = 'custom-dropdown__arrow';
      trigger.appendChild(arrow);
      
      // Вставляем trigger ПЕРЕД select внутри wrapper
      wrapper.insertBefore(trigger, select);
      
      // Убеждаемся что wrapper имеет правильную позицию
      wrapper.style.position = 'relative';
      wrapper.style.zIndex = '10';

      // Создаем меню
      const menu = document.createElement('div');
      menu.className = 'custom-dropdown__menu';
      
      // Обработчики событий (добавляем один раз) - объявляем заранее
      let scrollHandler = null;
      let resizeHandler = null;
      let scrollUpdateScheduled = false;

      // Функция позиционирования меню
      const positionMenu = (force = false) => {
        // Если меню закрыто и не принудительно - не позиционируем
        if (!force && !menu.classList.contains('open')) return;
        const rect = trigger.getBoundingClientRect();
        // Для position: fixed координаты должны быть относительно viewport, без учета скролла
        menu.style.top = (rect.bottom + 8) + 'px';
        menu.style.left = rect.left + 'px';
        menu.style.width = rect.width + 'px';
      };

      // Throttling для плавного обновления позиции при скролле
      const schedulePositionUpdate = () => {
        if (scrollUpdateScheduled) return;
        scrollUpdateScheduled = true;
        requestAnimationFrame(() => {
          if (menu.classList.contains('open')) {
            positionMenu();
          }
          scrollUpdateScheduled = false;
        });
      };

      // Функция закрытия меню с очисткой обработчиков
      const closeMenu = () => {
        trigger.classList.remove('active');
        menu.classList.remove('open');
        // Удаляем обработчики при закрытии
        if (scrollHandler) {
          window.removeEventListener('scroll', scrollHandler, true);
          scrollHandler = null;
        }
        if (resizeHandler) {
          window.removeEventListener('resize', resizeHandler);
          resizeHandler = null;
        }
      };

      // Функция обновления опций
      const updateOptions = () => {
        menu.innerHTML = '';
        let hasSelected = false;
        
        // Проверяем, является ли этот select для источников задания 17
        const isTask17Source = select.id === 'task17-source';
        
        Array.from(select.options).forEach((option, index) => {
          const menuOption = document.createElement('div');
          menuOption.className = 'custom-dropdown__option';
          menuOption.dataset.value = option.value;
          
          // Создаем контейнер для содержимого опции
          const optionContent = document.createElement('div');
          optionContent.className = 'custom-dropdown__option-content';
          optionContent.textContent = option.text;
          menuOption.appendChild(optionContent);
          
          // Для опций без actions, делаем контент кликабельным на всю ширину
          if (!isTask17Source || option.value === '' || option.value === '__new__' || !option.dataset.sourceId) {
            optionContent.style.flex = '1';
          }
          
          if (option.value === '') {
            menuOption.classList.add('placeholder');
          }
          
          if (option.value === select.value) {
            menuOption.classList.add('selected');
            triggerText.textContent = option.text;
            triggerText.classList.toggle('placeholder', option.value === '');
            hasSelected = true;
          }
          
          // Добавляем кнопки редактирования и удаления для источников (кроме placeholder и __new__)
          if (isTask17Source && option.value !== '' && option.value !== '__new__' && option.dataset.sourceId) {
            const actionsContainer = document.createElement('div');
            actionsContainer.className = 'custom-dropdown__option-actions';
            
            const editBtn = document.createElement('button');
            editBtn.className = 'custom-dropdown__action-btn custom-dropdown__action-btn--edit';
            editBtn.innerHTML = '✏️';
            editBtn.title = 'Редактировать источник';
            editBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              e.preventDefault();
              const sourceId = option.dataset.sourceId;
              const sourceName = option.text;
              editSource(sourceId, sourceName);
              closeMenu();
            });
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'custom-dropdown__action-btn custom-dropdown__action-btn--delete';
            deleteBtn.innerHTML = '🗑️';
            deleteBtn.title = 'Удалить источник';
            deleteBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              e.preventDefault();
              const sourceId = option.dataset.sourceId;
              const sourceName = option.text;
              deleteSource(sourceId, sourceName);
              closeMenu();
            });
            
            actionsContainer.appendChild(editBtn);
            actionsContainer.appendChild(deleteBtn);
            menuOption.appendChild(actionsContainer);
          }
          
          // Обработчик выбора - используем mousedown для более быстрого отклика
          const handleSelection = (e) => {
            // Не выбираем, если клик был по кнопке действия
            if (e.target.closest('.custom-dropdown__action-btn')) {
              return;
            }
            
            e.stopPropagation();
            e.preventDefault();
            e.cancelBubble = true;
            
            select.value = option.value;
            select.dispatchEvent(new Event('change', { bubbles: true }));
            
            // Обновляем UI
            menu.querySelectorAll('.custom-dropdown__option').forEach(opt => {
              opt.classList.remove('selected');
            });
            menuOption.classList.add('selected');
            
            triggerText.textContent = option.text;
            triggerText.classList.toggle('placeholder', option.value === '');
            closeMenu();
            
            trigger.blur();
            
            return false;
          };
          
          menuOption.addEventListener('mousedown', handleSelection);
          menuOption.addEventListener('click', handleSelection);
          
          menu.appendChild(menuOption);
        });
        
        // Если ничего не выбрано, показываем первую опцию
        if (!hasSelected && select.options.length > 0) {
          triggerText.textContent = select.options[0].text;
          triggerText.classList.toggle('placeholder', select.options[0].value === '');
        }
      };
      
      updateOptions();
      
      // Добавляем меню в body для fixed позиционирования
      document.body.appendChild(menu);

      // Открытие/закрытие меню
      trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        const isOpen = menu.classList.contains('open');
        
        // Закрываем все другие dropdown
        document.querySelectorAll('.custom-dropdown__menu').forEach(m => {
          if (m !== menu) m.classList.remove('open');
        });
        document.querySelectorAll('.custom-dropdown__trigger').forEach(t => {
          if (t !== trigger) t.classList.remove('active');
        });
        
        if (isOpen) {
          closeMenu();
        } else {
          // Устанавливаем позицию ДО открытия, чтобы меню сразу появилось в правильном месте
          positionMenu(true);
          
          trigger.classList.add('active');
          menu.classList.add('open');
          
          // Дополнительное обновление позиции после того как браузер применил стили и меню стало видимым
          requestAnimationFrame(() => {
            positionMenu();
          });
          
          // Добавляем обработчики только один раз
          if (!scrollHandler) {
            scrollHandler = schedulePositionUpdate;
            window.addEventListener('scroll', scrollHandler, true);
          }
          if (!resizeHandler) {
            resizeHandler = schedulePositionUpdate;
            window.addEventListener('resize', resizeHandler);
          }
        }
        
        return false;
      });

      // Закрытие при клике вне - используем отдельный обработчик с задержкой
      let clickOutsideTimeout;
      const handleOutsideClick = (e) => {
        // Проверяем что клик был вне wrapper и меню
        const clickedInside = wrapper.contains(e.target) || menu.contains(e.target) || trigger.contains(e.target);
        
        if (!clickedInside && menu.classList.contains('open')) {
          // Задержка чтобы клик на опцию успел сработать
          clearTimeout(clickOutsideTimeout);
          clickOutsideTimeout = setTimeout(() => {
            if (menu.classList.contains('open')) {
              closeMenu();
            }
          }, 150);
        }
      };
      
      document.addEventListener('mousedown', handleOutsideClick, false);
      document.addEventListener('click', handleOutsideClick, false);

      // Закрытие по Escape
      trigger.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeMenu();
        } else if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          trigger.click();
        }
      });

      // Обновление при изменении select программно
      select.addEventListener('change', () => {
        updateOptions();
      });
    });
  }

  // Инициализируем кастомные dropdown после загрузки DOM
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCustomDropdowns);
  } else {
    initCustomDropdowns();
  }

  // Переинициализация при динамической загрузке данных
  const originalLoadSubtopicsForSelect = window.loadSubtopicsForSelect;
  if (originalLoadSubtopicsForSelect) {
    window.loadSubtopicsForSelect = async function(selector) {
      await originalLoadSubtopicsForSelect.call(this, selector);
      setTimeout(initCustomDropdowns, 100);
    };
  }

  // ===== ЗАДАНИЕ №17 =====
  
  // Показать интерфейс для задания №17
  function showTask17Admin() {
    showSection('task17');
    loadTask17Sources(); // Загружаем список источников
    loadTask17List(); // Загружаем список заданий
    updateBreadcrumbs([
      { 
        label: 'Тип 17: Знаки препинания в предложениях со словами и конструкциями',
        action: () => {
          showTask17Admin();
        }
      },
      { label: 'Задание №17' }
    ]);
  }
  window.showTask17Admin = showTask17Admin;

  // Загрузка списка источников
  async function loadTask17Sources() {
    try {
      const response = await fetch('/api/sources');
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const sources = await response.json();
      
      const select = document.getElementById('task17-source');
      if (!select) return;
      
      // Сохраняем текущее значение
      const currentValue = select.value;
      
      // Очищаем и заполняем список (сохраняем опции "Выберите источник" и "+ Новый")
      const firstOption = select.querySelector('option[value=""]');
      const newOption = select.querySelector('option[value="__new__"]');
      
      select.innerHTML = '<option value="">Выберите источник</option><option value="__new__">+ Новый</option>';
      
      sources.forEach(source => {
        const option = document.createElement('option');
        option.value = source.name;
        option.textContent = source.name;
        option.dataset.sourceId = source.id; // Сохраняем id источника
        select.appendChild(option);
      });
      
      // Восстанавливаем значение, если оно было
      if (currentValue && currentValue !== '__new__') {
        select.value = currentValue;
      } else if (currentValue === '__new__') {
        select.value = '__new__';
        handleTask17SourceChange(); // Показываем поле для ввода
      }
      
      // Переинициализируем кастомный dropdown, чтобы отобразить новые опции
      // Используем небольшую задержку, чтобы убедиться, что DOM обновлен
      setTimeout(() => {
        if (typeof initCustomDropdowns === 'function') {
          initCustomDropdowns();
        }
      }, 50);
    } catch (error) {
      console.error('Ошибка загрузки источников:', error);
    }
  }

  // Обработка изменения выбора источника
  function handleTask17SourceChange() {
    const select = document.getElementById('task17-source');
    const newInput = document.getElementById('task17-source-new');
    
    if (select.value === '__new__') {
      // Показываем поле для нового источника
      newInput.style.display = 'block';
      newInput.value = '';
      newInput.focus();
    } else {
      // Скрываем поле для нового источника
      newInput.style.display = 'none';
      newInput.value = '';
    }
  }

  // Редактирование источника
  async function editSource(sourceId, currentName) {
    const newName = prompt('Введите новое название источника:', currentName);
    if (!newName || newName.trim() === '') {
      return;
    }
    
    try {
      const response = await fetch(`/api/sources/${sourceId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: newName.trim() })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Ошибка обновления источника');
      }
      
      // Обновляем список источников
      await loadTask17Sources();
      
      // Если этот источник был выбран, обновляем значение
      const select = document.getElementById('task17-source');
      if (select && select.value === currentName) {
        select.value = newName.trim();
        select.dispatchEvent(new Event('change', { bubbles: true }));
      }
    } catch (error) {
      console.error('Ошибка редактирования источника:', error);
      alert('Ошибка редактирования источника: ' + error.message);
    }
  }
  window.editSource = editSource;

  // Удаление источника
  async function deleteSource(sourceId, sourceName) {
    if (!confirm(`Вы уверены, что хотите удалить источник "${sourceName}"?`)) {
      return;
    }
    
    try {
      const response = await fetch(`/api/sources/${sourceId}`, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Ошибка удаления источника');
      }
      
      // Обновляем список источников
      await loadTask17Sources();
      
      // Если этот источник был выбран, сбрасываем выбор
      const select = document.getElementById('task17-source');
      if (select && select.value === sourceName) {
        select.value = '';
        select.dispatchEvent(new Event('change', { bubbles: true }));
      }
    } catch (error) {
      console.error('Ошибка удаления источника:', error);
      alert('Ошибка удаления источника: ' + error.message);
    }
  }
  window.deleteSource = deleteSource;

  // Инициализация обработчика изменения select при загрузке
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      const select = document.getElementById('task17-source');
      if (select) {
        select.addEventListener('change', handleTask17SourceChange);
      }
    });
  } else {
    const select = document.getElementById('task17-source');
    if (select) {
      select.addEventListener('change', handleTask17SourceChange);
    }
  }


  // Загрузка списка заданий №17
  async function loadTask17List() {
    try {
      const response = await fetch('/api/task17');
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const tasks = await response.json();
      
      const list = document.getElementById('task17-list');
      if (tasks.length === 0) {
        list.innerHTML = '<p>Задания №17 не найдены</p>';
        return;
      }
      
      list.innerHTML = tasks.map(task => {
        const preview = task.source_text ? (task.source_text.substring(0, 100) + (task.source_text.length > 100 ? '...' : '')) : 'Нет текста';
        return `
          <div class="admin-list-item">
            <div class="admin-list-item-content">
              <div class="admin-list-item-title">Задание #${task.id}</div>
              <div class="admin-list-item-description">${preview}</div>
              <div class="admin-list-item-meta">
                Создано: ${new Date(task.created_at).toLocaleString('ru-RU')}
              </div>
            </div>
            <div class="admin-list-item-actions">
              <button class="btn btn-sm" onclick="editTask17(${task.id})">Редактировать</button>
              <button class="btn btn-sm btn-danger" onclick="deleteTask17(${task.id})">Удалить</button>
            </div>
          </div>
        `;
      }).join('');
    } catch (error) {
      console.error('Ошибка загрузки заданий №17:', error);
      const list = document.getElementById('task17-list');
      list.innerHTML = '<p style="color: red;">Ошибка загрузки заданий</p>';
    }
  }

  // Редактирование задания №17
  async function editTask17(id) {
    try {
      const response = await fetch(`/api/task17/${id}`);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const task = await response.json();
      
      document.getElementById('task17-id').value = task.id;
      
      // Устанавливаем источник
      const sourceSelect = document.getElementById('task17-source');
      const newSourceInput = document.getElementById('task17-source-new');
      if (task.source) {
        sourceSelect.value = task.source;
        newSourceInput.style.display = 'none';
        newSourceInput.value = '';
      } else {
        sourceSelect.value = '';
        newSourceInput.style.display = 'none';
        newSourceInput.value = '';
      }
      
      // НОВАЯ ЛОГИКА: нормализуем текст при загрузке (на случай, если в БД старый формат)
      const normalizedText = normalizeSourceText(task.source_text || '');
      document.getElementById('task17-text').value = normalizedText;
      
      // Формируем ответ из digits
      const answerDigits = task.digits || [];
      document.getElementById('task17-answer').value = answerDigits.join(',');
      
      // Загружаем объяснение с поддержкой HTML
      const explanationEditor = document.getElementById('task17-explanation-editor');
      if (task.explanation_md) {
        explanationEditor.innerHTML = task.explanation_md;
      } else {
        // Если объяснения нет, генерируем из предложения и ответа
        updateExplanationFromTask();
      }
      
      // Прокрутка к форме
      document.getElementById('task17-form').scrollIntoView({ behavior: 'smooth', block: 'start' });
    } catch (error) {
      console.error('Ошибка загрузки задания:', error);
      alert('Ошибка загрузки задания');
    }
  }
  window.editTask17 = editTask17;

  // Удаление задания №17
  async function deleteTask17(id) {
    if (!confirm('Удалить задание №17 #' + id + '?')) return;
    
    try {
      const response = await fetch(`/api/task17/${id}`, { method: 'DELETE' });
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      
      loadTask17List();
      alert('Задание удалено');
    } catch (error) {
      console.error('Ошибка удаления задания:', error);
      alert('Ошибка удаления задания');
    }
  }
  window.deleteTask17 = deleteTask17;

  // Очистка формы задания №17
  function resetTask17Form() {
    document.getElementById('task17-form').reset();
    document.getElementById('task17-id').value = '';
    document.getElementById('task17-explanation-editor').innerHTML = '';
    // Скрываем поле для нового источника
    document.getElementById('task17-source-new').style.display = 'none';
    document.getElementById('task17-source-new').value = '';
    // Очищаем редактор объяснения
    const editor = document.getElementById('task17-explanation-editor');
    if (editor) {
      editor.innerHTML = '';
    }
  }
  window.resetTask17Form = resetTask17Form;

  // НОВАЯ ЛОГИКА: Нормализация текста - приводит все цифры к формату " (N) " (пробел слева, пробел справа)
  // Пользователь может вводить текст как угодно, но мы нормализуем его
  function normalizeSourceText(sourceText) {
    if (!sourceText) return '';
    
    let result = sourceText;
    const digitRegex = /\((\d+)\)/g;
    const replacements = [];
    let match;
    
    // Собираем все метки цифр
    while ((match = digitRegex.exec(sourceText)) !== null) {
      replacements.push({
        index: match.index,
        length: match[0].length,
        digit: match[1]
      });
    }
    
    // Применяем замены с конца, чтобы индексы не сдвигались
    for (let i = replacements.length - 1; i >= 0; i--) {
      const rep = replacements[i];
      const before = result.substring(0, rep.index);
      const after = result.substring(rep.index + rep.length);
      
      // Нормализуем: всегда " (N) " (пробел слева, пробел справа)
      // Убираем все пробелы вокруг метки и добавляем один пробел слева и один справа
      let beforeNormalized = before.trimEnd(); // Убираем пробелы в конце
      let afterNormalized = after.trimStart(); // Убираем пробелы в начале
      
      // Добавляем пробелы вокруг метки
      result = beforeNormalized + ' (' + rep.digit + ') ' + afterNormalized;
    }
    
    // Финальная нормализация: убираем множественные пробелы (но сохраняем пробелы вокруг цифр)
    // Заменяем множественные пробелы на одинарные, но не трогаем пробелы внутри " (N) "
    result = result.replace(/\s+/g, ' ').trim();
    
    return result;
  }

  // Функция для вычисления позиций запятых в commaless_text
  // НОВАЯ ЛОГИКА: все цифры уже нормализованы к формату " (N) " (пробел слева, пробел справа)
  // При клике на цифру берем её с двумя пробелами (один слева, один справа)
  // Если цифра правильная: заменяем " (N) " на ", " (запятая и пробел)
  // Если цифра неправильная: заменяем " (N) " на " " (один пробел)
  function calculateCommaPositions(sourceText, answerDigits) {
    // Сначала нормализуем исходный текст
    const normalizedSourceText = normalizeSourceText(sourceText);
    const correctDigitsSet = new Set(answerDigits.map(d => Number(d)));
    
    // НОВАЯ ЛОГИКА: в нормализованном тексте все цифры в формате " (N) " (пробел слева, пробел справа)
    // Находим все цифры в нормализованном тексте
    const digitRegex = /\((\d+)\)/g;
    const digits = [];
    let match;
    
    while ((match = digitRegex.exec(normalizedSourceText)) !== null) {
      const digit = parseInt(match[1], 10);
      const startIndex = match.index; // Начало "("
      const endIndex = match.index + match[0].length; // Конец ")"
      
      // В нормализованном тексте всегда есть пробел слева и справа
      // Проверяем, что это действительно так
      const hasSpaceBefore = startIndex > 0 && normalizedSourceText[startIndex - 1] === ' ';
      const hasSpaceAfter = endIndex < normalizedSourceText.length && normalizedSourceText[endIndex] === ' ';
      
      digits.push({
        digit: digit,
        start: startIndex,
        end: endIndex,
        hasSpaceBefore: hasSpaceBefore,
        hasSpaceAfter: hasSpaceAfter,
        isCorrect: correctDigitsSet.has(digit)
      });
    }
    
    // Сортируем по позиции
    digits.sort((a, b) => a.start - b.start);
    
    // Создаем base_text и commaless_text из нормализованного текста
    let baseText = normalizedSourceText;
    let commalessText = normalizedSourceText;
    
    // Применяем замены с конца, чтобы индексы не сдвигались
    for (let i = digits.length - 1; i >= 0; i--) {
      const d = digits[i];
      
      // НОВАЯ ЛОГИКА: элемент всегда " (N) " (пробел слева, пробел справа)
      // Границы элемента: пробел слева + " (N) " + пробел справа
      const elementStart = d.start - 1; // Начало пробела перед "("
      const elementEnd = d.end + 1; // Конец пробела после ")"
      
      let before = baseText.substring(0, elementStart);
      let after = baseText.substring(elementEnd);
      
      if (d.isCorrect) {
        // Правильная цифра: заменяем " (N) " на ", " (запятая и пробел)
        // Убираем пробел перед элементом (он был частью " (N) ")
        baseText = before + ', ' + after;
      } else {
        // Неправильная цифра: заменяем " (N) " на " " (один пробел)
        // Убираем пробел перед элементом, оставляем один пробел
        baseText = before + ' ' + after;
      }
      
      // Для commaless_text: всегда заменяем " (N) " на " " (один пробел)
      let beforeComma = commalessText.substring(0, elementStart);
      let afterComma = commalessText.substring(elementEnd);
      commalessText = beforeComma + ' ' + afterComma;
    }
    
    // НОРМАЛИЗАЦИЯ: убираем множественные пробелы (единая логика с сервером)
    // Важно: нормализация должна быть одинаковой в админке и на сервере
    // Сначала убираем все множественные пробелы
    baseText = baseText.replace(/\s+/g, ' ').trim();
    // Убираем пробелы перед запятыми
    baseText = baseText.replace(/\s+,/g, ',');
    // Убираем пробелы после запятых (оставляем только один)
    baseText = baseText.replace(/,\s+/g, ', ');
    // Убираем пробелы перед точкой и другими знаками препинания
    baseText = baseText.replace(/\s+\./g, '.');
    baseText = baseText.replace(/\s+,/g, ',');
    // Финальная нормализация - убираем все множественные пробелы еще раз
    baseText = baseText.replace(/\s{2,}/g, ' ').trim();
    // Нормализуем commaless_text (та же логика, что и normalizeText на сервере)
    commalessText = commalessText.replace(/\s+/g, ' ').trim();
    
    // НОВАЯ ЛОГИКА: вычисляем индексы пробелов (0, 1, 2...), где стоят запятые
    // Сравниваем base_text и commaless_text, чтобы найти, на каких пробелах стоят запятые
    // base_text: "Соня, побледневшая и дрожащая, старалась..."
    // commaless_text: "Соня побледневшая и дрожащая старалась..."
    // Запятая в base_text стоит после слова, перед пробелом: "слово, пробел"
    // В commaless_text это будет "слово пробел"
    // Нужно найти пробелы в commaless_text, которые соответствуют пробелам после запятых в base_text
    
    // Нормализуем оба текста для сравнения
    const normalizedBase = baseText.replace(/\s+/g, ' ').trim();
    const normalizedCommaless = commalessText.replace(/\s+/g, ' ').trim();
    
    // Вычисляем индексы пробелов, где стоят запятые
    // Проходим по base_text и для каждой запятой находим соответствующий пробел в commaless_text
    const spaceIndices = []; // Индексы пробелов (0, 1, 2...)
    let spaceIndex = 0; // Порядковый номер пробела в commaless_text
    let basePos = 0; // Позиция в base_text
    let commalessPos = 0; // Позиция в commaless_text
    
    // Проходим по base_text символ за символом
    while (basePos < normalizedBase.length) {
      if (normalizedBase[basePos] === ',') {
        // Нашли запятую в base_text
        // Пропускаем запятую и пробел после неё в base_text
        basePos++; // Пропускаем запятую
        if (basePos < normalizedBase.length && normalizedBase[basePos] === ' ') {
          basePos++; // Пропускаем пробел после запятой
        }
        
        // Теперь нужно найти соответствующий пробел в commaless_text
        // Продолжаем с текущей позиции commalessPos и ищем следующий пробел
        while (commalessPos < normalizedCommaless.length) {
          if (normalizedCommaless[commalessPos] === ' ') {
            // Нашли пробел - это тот, где должна быть запятая
            spaceIndices.push(spaceIndex);
            console.log(`[calculateCommaPositions] Найден пробел с индексом ${spaceIndex}, где стоит запятая`);
            spaceIndex++;
            commalessPos++;
            break;
          } else {
            // Не пробел - пропускаем символ
            commalessPos++;
          }
        }
      } else if (normalizedBase[basePos] === ' ') {
        // Пробел в base_text (без запятой)
        // Пропускаем пробел в commaless_text (он должен быть там же)
        if (commalessPos < normalizedCommaless.length && normalizedCommaless[commalessPos] === ' ') {
          spaceIndex++;
          commalessPos++;
        }
        basePos++;
      } else {
        // Обычный символ - синхронизируем
        if (commalessPos < normalizedCommaless.length && normalizedCommaless[commalessPos] === normalizedBase[basePos]) {
          basePos++;
          commalessPos++;
        } else {
          // Символы не совпадают - ошибка синхронизации
          console.error('[calculateCommaPositions] ОШИБКА: символы не совпадают!', {
            commalessPos,
            basePos,
            commalessChar: normalizedCommaless[commalessPos],
            baseChar: normalizedBase[basePos],
            commalessText: normalizedCommaless.substring(Math.max(0, commalessPos - 10), commalessPos + 10),
            baseText: normalizedBase.substring(Math.max(0, basePos - 10), basePos + 10)
          });
          break;
        }
      }
    }
    
    console.log('[calculateCommaPositions] Начало вычисления позиций');
    console.log('[calculateCommaPositions] sourceText:', sourceText);
    console.log('[calculateCommaPositions] answerDigits:', answerDigits);
    console.log('[calculateCommaPositions] digits:', digits);
    console.log('[calculateCommaPositions] baseText:', baseText);
    console.log('[calculateCommaPositions] commalessText:', commalessText);
    console.log('[calculateCommaPositions] Итоговые индексы пробелов:', spaceIndices);
    
    return {
      baseText: baseText,
      commalessText: commalessText,
      commaPositions: spaceIndices.sort((a, b) => a - b) // Теперь это индексы пробелов, а не позиции
    };
  }

  // Функция для обновления объяснения из задания и ответа
  // НОВАЯ ЛОГИКА: использует нормализованный текст
  function updateExplanationFromTask() {
    const textInput = document.getElementById('task17-text');
    const answerInput = document.getElementById('task17-answer');
    const editor = document.getElementById('task17-explanation-editor');
    
    if (!textInput || !answerInput || !editor) return;
    
    const sourceText = textInput.value.trim();
    const answerText = answerInput.value.trim();
    
    if (!sourceText) {
      editor.innerHTML = '';
      return;
    }
    
    // Проверяем, есть ли уже выделения - если есть, не перезаписываем полностью
    const hasHighlights = editor.querySelectorAll('.span-participle, .span-gerund, .span-main-word').length > 0;
    if (hasHighlights && editor.textContent.trim() !== '') {
      // Если есть выделения и текст не пустой, не обновляем автоматически
      return;
    }
    
    // НОВАЯ ЛОГИКА: нормализуем исходный текст
    const normalizedSourceText = normalizeSourceText(sourceText);
    
    // Парсим ответ - извлекаем цифры
    const answerDigits = answerText
      .split('')
      .map(char => parseInt(char, 10))
      .filter(n => !isNaN(n) && n > 0)
      .filter((value, index, self) => self.indexOf(value) === index);
    
    // НОВАЯ ЛОГИКА: используем calculateCommaPositions для получения baseText
    const { baseText } = calculateCommaPositions(sourceText, answerDigits);
    
    // Устанавливаем нормализованный baseText в редактор
    editor.textContent = baseText;
  }
  
  // Функция для форматирования цифр в редакторе (при вводе текста) - устаревшая, оставлена для совместимости
  function formatDigitsInEditor() {
    const editor = document.getElementById('task17-explanation-editor');
    if (!editor) return;
    
    // Получаем текстовое содержимое без HTML
    const text = editor.innerText || editor.textContent || '';
    
    // Проверяем, есть ли уже выделения
    const hasHighlights = editor.querySelectorAll('.span-participle, .span-gerund, .span-main-word').length > 0;
    
    // Если есть метки (1), (2)..., форматируем цифры (даже если есть выделения)
    if (/\(\d+\)/.test(text)) {
      // Парсим текст с метками (1), (2)...
      const regex = /\((\d+)\)/g;
      const parts = [];
      let lastIndex = 0;
      let match;
      
      while ((match = regex.exec(text)) !== null) {
        if (match.index > lastIndex) {
          parts.push({ text: text.substring(lastIndex, match.index), digit: null });
        }
        const digitNum = parseInt(match[1], 10);
        parts.push({ text: match[0], digit: digitNum });
        lastIndex = match.index + match[0].length;
      }
      
      if (lastIndex < text.length) {
        parts.push({ text: text.substring(lastIndex), digit: null });
      }
      
      // Формируем HTML для редактора
      let html = '';
      parts.forEach((part, idx) => {
        if (part.digit !== null) {
          html += `<span class="task17-editor-digit" style="
            cursor: default;
            padding: 2px 6px;
            margin: 0 2px;
            border-radius: 4px;
            display: inline-block;
            color: var(--neon-cyan);
            font-weight: 600;
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            user-select: none;
          ">${part.text}</span>`;
        } else {
          html += `<span>${part.text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>`;
        }
      });
      
      // Проверяем, есть ли уже выделения - если есть, нужно их сохранить
      if (hasHighlights) {
        // Если есть выделения, пытаемся форматировать только цифры, не затрагивая выделения
        // Находим все цифры, которые еще не отформатированы
        const existingDigits = editor.querySelectorAll('.task17-editor-digit');
        const allDigits = text.match(/\(\d+\)/g) || [];
        
        // Если не все цифры отформатированы, форматируем их
        if (existingDigits.length < allDigits.length) {
          // Сохраняем позицию курсора
          const selection = window.getSelection();
          let cursorOffset = 0;
          if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(editor);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            cursorOffset = preCaretRange.toString().length;
          }
          
          // Проходим по тексту и заменяем неотформатированные цифры
          const walker = document.createTreeWalker(
            editor,
            NodeFilter.SHOW_TEXT,
            null
          );
          
          let node;
          const nodesToProcess = [];
          while ((node = walker.nextNode())) {
            if (node.textContent.includes('(') && node.parentElement && !node.parentElement.classList.contains('task17-editor-digit')) {
              nodesToProcess.push(node);
            }
          }
          
          // Обрабатываем найденные узлы
          nodesToProcess.forEach(node => {
            const parent = node.parentElement;
            const textContent = node.textContent;
            const regex = /\((\d+)\)/g;
            let match;
            let lastIndex = 0;
            const fragments = [];
            
            while ((match = regex.exec(textContent)) !== null) {
              if (match.index > lastIndex) {
                fragments.push(document.createTextNode(textContent.substring(lastIndex, match.index)));
              }
              
              const digitSpan = document.createElement('span');
              digitSpan.className = 'task17-editor-digit';
              digitSpan.textContent = match[0];
              fragments.push(digitSpan);
              
              lastIndex = match.index + match[0].length;
            }
            
            if (lastIndex < textContent.length) {
              fragments.push(document.createTextNode(textContent.substring(lastIndex)));
            }
            
            if (fragments.length > 0) {
              fragments.forEach(frag => parent.insertBefore(frag, node));
              parent.removeChild(node);
            }
          });
          
          // Восстанавливаем позицию курсора
          if (cursorOffset > 0) {
            const walker2 = document.createTreeWalker(
              editor,
              NodeFilter.SHOW_TEXT,
              null
            );
            
            let currentOffset = 0;
            let node2;
            while ((node2 = walker2.nextNode())) {
              const nodeLength = node2.textContent.length;
              if (currentOffset + nodeLength >= cursorOffset) {
                const range = document.createRange();
                range.setStart(node2, cursorOffset - currentOffset);
                range.setEnd(node2, cursorOffset - currentOffset);
                selection.removeAllRanges();
                selection.addRange(range);
                break;
              }
              currentOffset += nodeLength;
            }
          }
        }
      } else {
        // Если нет выделений, просто заменяем HTML
        // Сохраняем позицию курсора
        const selection = window.getSelection();
        let cursorOffset = 0;
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const preCaretRange = range.cloneRange();
          preCaretRange.selectNodeContents(editor);
          preCaretRange.setEnd(range.endContainer, range.endOffset);
          cursorOffset = preCaretRange.toString().length;
        }
        
        editor.innerHTML = html;
        
        // Восстанавливаем позицию курсора
        if (cursorOffset > 0) {
          const walker = document.createTreeWalker(
            editor,
            NodeFilter.SHOW_TEXT,
            null
          );
          
          let currentOffset = 0;
          let node;
          while ((node = walker.nextNode())) {
            const nodeLength = node.textContent.length;
            if (currentOffset + nodeLength >= cursorOffset) {
              const range = document.createRange();
              range.setStart(node, cursorOffset - currentOffset);
              range.setEnd(node, cursorOffset - currentOffset);
              selection.removeAllRanges();
              selection.addRange(range);
              break;
            }
            currentOffset += nodeLength;
          }
        }
      }
    }
  }
  
  // Инициализация обновления объяснения при изменении задания или ответа
  const textInput = document.getElementById('task17-text');
  const answerInput = document.getElementById('task17-answer');
  
  if (textInput) {
    textInput.addEventListener('input', () => {
      setTimeout(updateExplanationFromTask, 100);
    });
    textInput.addEventListener('paste', () => {
      setTimeout(updateExplanationFromTask, 100);
    });
  }
  
  if (answerInput) {
    answerInput.addEventListener('input', () => {
      setTimeout(updateExplanationFromTask, 100);
    });
    answerInput.addEventListener('paste', () => {
      setTimeout(updateExplanationFromTask, 100);
    });
  }
  
  // Инициализация при загрузке (если форма уже заполнена)
  if (textInput && answerInput && textInput.value && answerInput.value) {
    setTimeout(updateExplanationFromTask, 100);
  }

  // Инициализация панели инструментов для выделения оборотов через переиспользуемый модуль
  let adminTextSelectionToolbar = null;
  
  function initTask17SpanToolbar() {
    const editor = document.getElementById('task17-explanation-editor');
    if (!editor) return;

    // Палитра цветов для главных слов (глобальная константа)
    const COLOR_PALETTE = [
      { bg: 'rgba(59, 130, 246, 0.3)', border: 'rgba(59, 130, 246, 0.8)', text: 'rgba(59, 130, 246, 1)' }, // Синий
      { bg: 'rgba(34, 197, 94, 0.3)', border: 'rgba(34, 197, 94, 0.8)', text: 'rgba(34, 197, 94, 1)' }, // Зеленый
      { bg: 'rgba(236, 72, 153, 0.3)', border: 'rgba(236, 72, 153, 0.8)', text: 'rgba(236, 72, 153, 1)' }, // Розовый
      { bg: 'rgba(251, 191, 36, 0.3)', border: 'rgba(251, 191, 36, 0.8)', text: 'rgba(251, 191, 36, 1)' }, // Желтый
      { bg: 'rgba(168, 85, 247, 0.3)', border: 'rgba(168, 85, 247, 0.8)', text: 'rgba(168, 85, 247, 1)' }, // Фиолетовый
      { bg: 'rgba(239, 68, 68, 0.3)', border: 'rgba(239, 68, 68, 0.8)', text: 'rgba(239, 68, 68, 1)' }, // Красный
      { bg: 'rgba(14, 165, 233, 0.3)', border: 'rgba(14, 165, 233, 0.8)', text: 'rgba(14, 165, 233, 1)' }, // Голубой
      { bg: 'rgba(245, 158, 11, 0.3)', border: 'rgba(245, 158, 11, 0.8)', text: 'rgba(245, 158, 11, 1)' }, // Оранжевый
    ];

    // Функция для применения стиля к выделенному тексту (с поддержкой вложенных оборотов)
    function applySpanClass(className) {
      const selection = window.getSelection();
      if (selection.rangeCount === 0 || selection.toString().trim() === '') {
        alert('Выделите текст в объяснении');
        return;
      }

      let range = selection.getRangeAt(0);
      
      if (range.collapsed) {
        alert('Выделите текст');
        return;
      }

      // Функция для расширения range до ближайших пробелов
      function expandRangeToSpaces(range) {
        const expandedRange = range.cloneRange();
        
        // Расширяем начало влево до пробела
        let startContainer = expandedRange.startContainer;
        let startOffset = expandedRange.startOffset;
        
        if (startContainer.nodeType === Node.TEXT_NODE) {
          const text = startContainer.textContent;
          let newOffset = startOffset;
          while (newOffset > 0 && text[newOffset - 1] !== ' ') {
            newOffset--;
          }
          expandedRange.setStart(startContainer, newOffset);
        } else {
          // Если начало в элементе, ищем первый текстовый узел внутри
          const walker = document.createTreeWalker(
            startContainer,
            NodeFilter.SHOW_TEXT,
            null
          );
          const firstTextNode = walker.nextNode();
          if (firstTextNode) {
            const text = firstTextNode.textContent;
            let spacePos = text.lastIndexOf(' ');
            if (spacePos >= 0) {
              expandedRange.setStart(firstTextNode, spacePos + 1);
            } else {
              expandedRange.setStart(firstTextNode, 0);
            }
          }
        }
        
        // Расширяем конец вправо до пробела (не включая пробел)
        let endContainer = expandedRange.endContainer;
        let endOffset = expandedRange.endOffset;
        
        if (endContainer.nodeType === Node.TEXT_NODE) {
          const text = endContainer.textContent;
          let newOffset = endOffset;
          while (newOffset < text.length && text[newOffset] !== ' ') {
            newOffset++;
          }
          expandedRange.setEnd(endContainer, newOffset);
        } else {
          // Если конец в элементе, ищем последний текстовый узел внутри
          const walker = document.createTreeWalker(
            endContainer,
            NodeFilter.SHOW_TEXT,
            null
          );
          let lastTextNode = null;
          let node;
          while (node = walker.nextNode()) {
            lastTextNode = node;
          }
          if (lastTextNode) {
            const text = lastTextNode.textContent;
            let spacePos = text.indexOf(' ');
            if (spacePos >= 0) {
              expandedRange.setEnd(lastTextNode, spacePos);
            } else {
              expandedRange.setEnd(lastTextNode, text.length);
            }
          }
        }
        
        // Расширяем начало, проходя по предыдущим узлам
        while (true) {
          const startContainer = expandedRange.startContainer;
          const startOffset = expandedRange.startOffset;
          
          if (startContainer.nodeType === Node.TEXT_NODE && startOffset === 0) {
            const prevNode = startContainer.previousSibling;
            if (prevNode && prevNode.nodeType === Node.TEXT_NODE) {
              const text = prevNode.textContent;
              const spacePos = text.lastIndexOf(' ');
              if (spacePos >= 0) {
                expandedRange.setStart(prevNode, spacePos + 1);
                continue;
              } else {
                expandedRange.setStart(prevNode, 0);
                continue;
              }
            }
          }
          break;
        }
        
        // Расширяем конец, проходя по следующим узлам
        while (true) {
          const endContainer = expandedRange.endContainer;
          const endOffset = expandedRange.endOffset;
          
          if (endContainer.nodeType === Node.TEXT_NODE && 
              endOffset >= endContainer.textContent.length) {
            const nextNode = endContainer.nextSibling;
            if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
              const text = nextNode.textContent;
              const spacePos = text.indexOf(' ');
              if (spacePos >= 0) {
                expandedRange.setEnd(nextNode, spacePos);
                continue;
              } else {
                expandedRange.setEnd(nextNode, text.length);
                continue;
              }
            }
          }
          break;
        }
        
        return expandedRange;
      }

      // Расширяем range до ближайших пробелов (не включая пробелы) для всех типов
      range = expandRangeToSpaces(range);

      // Проверяем ограничения на вложенные обороты и замену выделений
      // Разрешенные комбинации: причастный в деепричастном, деепричастный в причастном, 
      // причастный в причастном, деепричастный в деепричастном
      const underlineClasses = ['span-participle', 'span-gerund', 'span-subject', 'span-predicate'];
      const isUnderlineClass = underlineClasses.includes(className);
      
      if (isUnderlineClass) {
        // Проверяем, находится ли выделение полностью внутри существующего span с подчеркиванием
        const startContainer = range.startContainer;
        const endContainer = range.endContainer;
        
        // Ищем ближайший родительский span с подчеркиванием для начала
        let startParent = startContainer.nodeType === 1 ? startContainer : startContainer.parentElement;
        let parentUnderlineSpan = null;
        while (startParent && startParent !== editor) {
          if (startParent.classList) {
            for (const cls of underlineClasses) {
              if (startParent.classList.contains(cls)) {
                parentUnderlineSpan = startParent;
                break;
              }
            }
            if (parentUnderlineSpan) break;
          }
          startParent = startParent.parentElement;
        }
        
        // Если выделение находится внутри существующего span с подчеркиванием
        if (parentUnderlineSpan) {
          // Проверяем, является ли выделение строго вложенным (не совпадает с родителем)
          // Если выделение совпадает с родителем или покрывает его полностью - заменяем
          const parentText = parentUnderlineSpan.textContent.trim();
          const rangeText = range.toString().trim();
          
          // Проверяем, совпадают ли границы выделения с границами родительского span
          const spanRange = document.createRange();
          spanRange.selectNodeContents(parentUnderlineSpan);
          
          // Если тексты совпадают или выделение покрывает весь родительский span - заменяем
          const isExactMatch = range.compareBoundaryPoints(Range.START_TO_START, spanRange) === 0 &&
                               range.compareBoundaryPoints(Range.END_TO_END, spanRange) === 0;
          const isAlmostMatch = rangeText === parentText || 
                                (rangeText.length >= parentText.length * 0.95 && rangeText.length <= parentText.length * 1.05);
          
          if (isExactMatch || isAlmostMatch) {
            // Заменяем старое выделение на новое
            const grandParent = parentUnderlineSpan.parentNode;
            if (grandParent) {
              // Удаляем старый span
              while (parentUnderlineSpan.firstChild) {
                grandParent.insertBefore(parentUnderlineSpan.firstChild, parentUnderlineSpan);
              }
              grandParent.removeChild(parentUnderlineSpan);
            }
            
            // Продолжаем создание нового span (код ниже)
          } else {
            // Это вложенное выделение (меньше родителя), проверяем правила
            const parentClass = parentUnderlineSpan.classList.contains('span-participle') ? 'span-participle' :
                               parentUnderlineSpan.classList.contains('span-gerund') ? 'span-gerund' :
                               parentUnderlineSpan.classList.contains('span-subject') ? 'span-subject' :
                               parentUnderlineSpan.classList.contains('span-predicate') ? 'span-predicate' : null;
            
            // Проверяем, разрешена ли эта комбинация
            const allowedCombinations = {
              'span-participle': ['span-gerund', 'span-participle'], // причастный может содержать деепричастный или причастный
              'span-gerund': ['span-participle', 'span-gerund'] // деепричастный может содержать причастный или деепричастный
            };
            
            // Если родитель - причастный или деепричастный, проверяем разрешенные комбинации
            if (parentClass === 'span-participle' || parentClass === 'span-gerund') {
              if (!allowedCombinations[parentClass].includes(className)) {
                alert('Невозможно создать вложенный оборот: разрешены только комбинации причастный/деепричастный внутри причастного/деепричастного');
                selection.removeAllRanges();
                editor.focus();
                return;
              }
            } else {
              // Если родитель - подлежащее или сказуемое, вложенные обороты не разрешены
              alert('Невозможно создать вложенный оборот внутри подлежащего или сказуемого');
              selection.removeAllRanges();
              editor.focus();
              return;
            }
          }
        } else {
          // Если выделение не внутри существующего span, проверяем, содержит ли оно span с подчеркиванием
          // Проверяем, пересекается ли выделение с существующим span
          const tempRange = range.cloneRange();
          const tempDiv = document.createElement('div');
          tempDiv.appendChild(tempRange.cloneContents());
          const existingSpans = tempDiv.querySelectorAll('.span-participle, .span-gerund, .span-subject, .span-predicate');
          
          // Если внутри выделения есть span с подчеркиванием - заменяем его
          if (existingSpans.length > 0) {
            // Находим span, который полностью находится внутри выделения
            // Проверяем все span в редакторе, которые пересекаются с выделением
            const allUnderlineSpans = editor.querySelectorAll('.span-participle, .span-gerund, .span-subject, .span-predicate');
            for (const realSpan of allUnderlineSpans) {
              // Проверяем, находится ли span полностью внутри выделения
              const spanRange = document.createRange();
              spanRange.selectNodeContents(realSpan);
              
              // Проверяем, что начало и конец span находятся внутри range
              if (range.compareBoundaryPoints(Range.START_TO_START, spanRange) <= 0 &&
                  range.compareBoundaryPoints(Range.END_TO_END, spanRange) >= 0) {
                // Span полностью внутри выделения - заменяем его
                const grandParent = realSpan.parentNode;
                if (grandParent) {
                  while (realSpan.firstChild) {
                    grandParent.insertBefore(realSpan.firstChild, realSpan);
                  }
                  grandParent.removeChild(realSpan);
                }
                break;
              }
            }
            // Продолжаем создание нового span (код ниже)
          }
        }
      }

      // Создаем новый span с нужным классом (может быть вложенным)
      const span = document.createElement('span');
      span.className = className;
      
      // Если создаем главное слово - автоматически назначаем цвет
      if (className === 'span-main-word') {
        // Находим следующий свободный цвет
        const usedColors = new Set();
        editor.querySelectorAll('.span-main-word[data-color-id]').forEach(el => {
          const id = el.getAttribute('data-color-id');
          if (id !== null && id !== '') {
            usedColors.add(parseInt(id));
          }
        });
        
        let freeIndex = 0;
        while (usedColors.has(freeIndex) && freeIndex < COLOR_PALETTE.length) {
          freeIndex++;
        }
        
        const color = COLOR_PALETTE[freeIndex % COLOR_PALETTE.length];
        span.setAttribute('data-color-id', freeIndex);
        span.style.backgroundColor = color.bg;
        // Используем обычный border для обводки главного слова
        span.style.border = `2px solid ${color.border}`;
        span.style.borderStyle = 'solid';
        span.style.borderWidth = '2px';
        span.style.borderColor = color.border;
      }
      
      try {
        // Проверяем, что range не пустой и валидный
        if (range.collapsed || !range.toString().trim()) {
          alert('Не удалось создать выделение: пустое выделение');
          selection.removeAllRanges();
          editor.focus();
          return;
        }
        range.surroundContents(span);
      } catch (e) {
        // Если surroundContents не работает (выделение пересекает границы элементов),
        // используем другой метод
        try {
          const contents = range.extractContents();
          if (!contents || contents.childNodes.length === 0) {
            alert('Не удалось создать выделение: пустое содержимое');
            selection.removeAllRanges();
            editor.focus();
            return;
          }
          span.appendChild(contents);
          range.insertNode(span);
        } catch (extractError) {
          console.error('Ошибка при создании выделения:', extractError);
          alert('Не удалось создать выделение. Попробуйте выделить текст заново.');
          selection.removeAllRanges();
          editor.focus();
          return;
        }
      }
      
      // Восстанавливаем цвет после вставки в DOM
      if (className === 'span-main-word') {
        requestAnimationFrame(() => {
          const colorId = span.getAttribute('data-color-id');
          if (colorId !== null && colorId !== '') {
            const colorIndex = parseInt(colorId);
            const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
            span.style.backgroundColor = color.bg;
            span.style.border = `2px solid ${color.border}`;
            span.style.borderStyle = 'solid';
            span.style.borderWidth = '2px';
            span.style.borderColor = color.border;
          }
        });
      }

      selection.removeAllRanges();
      editor.focus();
    }

    // Функция для удаления выделения
    function removeMark() {
      const selection = window.getSelection();
      if (!selection.rangeCount) {
        alert('Выделите текст для удаления отметки');
        return;
      }

      const range = selection.getRangeAt(0);
      const parent = range.commonAncestorContainer.nodeType === 3 
        ? range.commonAncestorContainer.parentElement 
        : range.commonAncestorContainer;

      if (parent && (parent.classList.contains('span-participle') || 
                     parent.classList.contains('span-gerund') || 
                     parent.classList.contains('span-main-word') ||
                     parent.classList.contains('span-subject') ||
                     parent.classList.contains('span-predicate'))) {
        const grandParent = parent.parentNode;
        if (grandParent) {
          const textNode = document.createTextNode(parent.textContent);
          grandParent.replaceChild(textNode, parent);
          selection.removeAllRanges();
          editor.focus();
        } else {
          alert('Ошибка: не удалось найти родительский элемент');
        }
      } else {
        alert('Выделите текст с отметкой для удаления');
      }
    }

    // Делаем функции доступными глобально для модуля
    window.applySpanClass = applySpanClass;
    window.removeMark = removeMark;

    // Инициализация цветового кодирования для главных слов (как на сайте)
    const colorPalette = [
      { bg: 'rgba(59, 130, 246, 0.3)', border: 'rgba(59, 130, 246, 0.8)', text: 'rgba(59, 130, 246, 1)' }, // Синий
      { bg: 'rgba(34, 197, 94, 0.3)', border: 'rgba(34, 197, 94, 0.8)', text: 'rgba(34, 197, 94, 1)' }, // Зеленый
      { bg: 'rgba(236, 72, 153, 0.3)', border: 'rgba(236, 72, 153, 0.8)', text: 'rgba(236, 72, 153, 1)' }, // Розовый
      { bg: 'rgba(251, 191, 36, 0.3)', border: 'rgba(251, 191, 36, 0.8)', text: 'rgba(251, 191, 36, 1)' }, // Желтый
      { bg: 'rgba(168, 85, 247, 0.3)', border: 'rgba(168, 85, 247, 0.8)', text: 'rgba(168, 85, 247, 1)' }, // Фиолетовый
      { bg: 'rgba(239, 68, 68, 0.3)', border: 'rgba(239, 68, 68, 0.8)', text: 'rgba(239, 68, 68, 1)' }, // Красный
      { bg: 'rgba(14, 165, 233, 0.3)', border: 'rgba(14, 165, 233, 0.8)', text: 'rgba(14, 165, 233, 1)' }, // Голубой
      { bg: 'rgba(245, 158, 11, 0.3)', border: 'rgba(245, 158, 11, 0.8)', text: 'rgba(245, 158, 11, 1)' }, // Оранжевый
    ];

    // Применяем цвет к элементу
    function applyColor(element, color) {
      element.style.backgroundColor = color.bg;
      if (element.classList.contains('span-main-word')) {
        // Используем обычный border для обводки главного слова
        element.style.border = `2px solid ${color.border}`;
        element.style.borderStyle = 'solid';
        element.style.borderWidth = '2px';
        element.style.borderColor = color.border;
      } else {
        // Для оборотов - только фон, текст остается белым
        element.style.color = 'var(--text-primary)';
        element.style.borderWidth = '0';
        element.style.borderStyle = 'none';
      }
    }

    // Глобальные переменные для режима связывания
    let selectedMainWord = null;
    let isLinkingMode = false;

    // Активируем режим связывания для главного слова
    function activateLinkingMode(mainWord) {
      // Убеждаемся, что у главного слова есть цвет
      let colorId = mainWord.getAttribute('data-color-id');
      if (!colorId || colorId === '') {
        // Назначаем цвет, если его нет
        const usedColors = new Set();
        editor.querySelectorAll('.span-main-word[data-color-id]').forEach(el => {
          const id = el.getAttribute('data-color-id');
          if (id !== null && id !== '') {
            usedColors.add(parseInt(id));
          }
        });
        
        let freeIndex = 0;
        while (usedColors.has(freeIndex) && freeIndex < COLOR_PALETTE.length) {
          freeIndex++;
        }
        
        const color = COLOR_PALETTE[freeIndex % COLOR_PALETTE.length];
        mainWord.setAttribute('data-color-id', freeIndex);
        applyColor(mainWord, color);
        colorId = freeIndex.toString();
      } else {
        // ВСЕГДА восстанавливаем цвет явно
        const colorIndex = parseInt(colorId);
        const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
        applyColor(mainWord, color);
      }
      
      // Если уже был активен режим для другого слова - отменяем его
      if (isLinkingMode && selectedMainWord && selectedMainWord !== mainWord) {
        cancelLinkingMode();
      }
      
      // Включаем режим связывания
      selectedMainWord = mainWord;
      isLinkingMode = true;
      mainWord.style.outline = '3px solid rgba(236, 72, 153, 0.8)';
      mainWord.style.outlineOffset = '2px';
      
      // Настраиваем подсветку оборотов при наведении
      setTimeout(() => {
        if (typeof setupLinkingModeHover === 'function') {
          setupLinkingModeHover();
        }
      }, 100);
    }

    // Отменяем режим связывания
    function cancelLinkingMode() {
      if (selectedMainWord) {
        const mainWordRef = selectedMainWord;
        const colorId = mainWordRef.getAttribute('data-color-id');
        
        selectedMainWord.style.outline = '';
        selectedMainWord.style.outlineOffset = '';
        
        if (colorId && colorId !== '') {
          const colorIndex = parseInt(colorId);
          const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
          applyColor(mainWordRef, color);
          
          requestAnimationFrame(() => {
            if (mainWordRef.getAttribute('data-color-id') === colorId) {
              applyColor(mainWordRef, color);
            }
          });
        }
        selectedMainWord = null;
      }
      isLinkingMode = false;
      
      // Удаляем hover эффекты
      if (typeof removeLinkingModeHover === 'function') {
        removeLinkingModeHover();
      }
    }

    // Связываем оборот с главным словом
    function linkTurnToMainWord(mainWord, turn) {
      const colorId = mainWord.getAttribute('data-color-id');
      if (!colorId || colorId === '') return;

      const colorIndex = parseInt(colorId);
      const color = colorPalette[colorIndex % colorPalette.length];

      applyColor(turn, color);
      turn.setAttribute('data-linked-to', colorId);
      
      // Визуальная обратная связь
      turn.style.transform = 'scale(1.05)';
      turn.style.transition = 'transform 0.2s ease';
      setTimeout(() => {
        turn.style.transform = '';
      }, 200);
      
      requestAnimationFrame(() => {
        if (turn.getAttribute('data-linked-to') === colorId) {
          applyColor(turn, color);
        }
      });
      
      // Автоматически выключаем режим связывания
      cancelLinkingMode();
    }

    // Подсветка оборотов при наведении в режиме связывания
    let hoverHandlers = new WeakMap();
    function setupLinkingModeHover() {
      if (!isLinkingMode || !selectedMainWord) return;
      
      const colorId = selectedMainWord.getAttribute('data-color-id');
      if (!colorId) return;
      
      const colorIndex = parseInt(colorId);
      const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
      
      editor.querySelectorAll('.span-participle, .span-gerund').forEach(turn => {
        // Пропускаем уже связанные обороты
        if (turn.getAttribute('data-linked-to') === colorId) {
          return;
        }
        
        // Удаляем старые обработчики, если есть
        const existingHandlers = hoverHandlers.get(turn);
        if (existingHandlers) {
          turn.removeEventListener('mouseenter', existingHandlers.enter);
          turn.removeEventListener('mouseleave', existingHandlers.leave);
        }
        
        turn.style.cursor = 'pointer';
        turn.style.transition = 'all 0.2s ease';
        
        const enterHandler = function() {
          if (isLinkingMode && this.getAttribute('data-linked-to') !== colorId) {
            this.style.backgroundColor = color.bg;
            this.style.opacity = '0.8';
          }
        };
        
        const leaveHandler = function() {
          if (this.getAttribute('data-linked-to') !== colorId) {
            this.style.backgroundColor = '';
            this.style.opacity = '';
          }
        };
        
        turn.addEventListener('mouseenter', enterHandler);
        turn.addEventListener('mouseleave', leaveHandler);
        
        // Сохраняем обработчики для последующего удаления
        hoverHandlers.set(turn, { enter: enterHandler, leave: leaveHandler });
      });
    }
    
    // Удаляем обработчики при выходе из режима связывания
    function removeLinkingModeHover() {
      editor.querySelectorAll('.span-participle, .span-gerund').forEach(turn => {
        const handlers = hoverHandlers.get(turn);
        if (handlers) {
          turn.removeEventListener('mouseenter', handlers.enter);
          turn.removeEventListener('mouseleave', handlers.leave);
          hoverHandlers.delete(turn);
        }
        turn.style.cursor = '';
        turn.style.opacity = '';
        
        // НЕ удаляем цвет у уже связанных оборотов (которые имеют data-linked-to)
        // Удаляем только временную подсветку при наведении
        const linkedTo = turn.getAttribute('data-linked-to');
        if (!linkedTo || linkedTo === '') {
          // Если оборот не связан, убираем временную подсветку
          turn.style.backgroundColor = '';
        } else {
          // Если оборот связан, восстанавливаем его цвет из главного слова
          const colorId = linkedTo;
          const colorIndex = parseInt(colorId);
          const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
          applyColor(turn, color);
        }
      });
    }

    // Делаем функции доступными глобально
    window.activateLinkingMode = activateLinkingMode;
    window.cancelLinkingMode = cancelLinkingMode;

    // Загружаем цвета из HTML при загрузке
    function loadColorsFromHTML() {
      // Обрабатываем главные слова с data-color-id
      const mainWords = editor.querySelectorAll('.span-main-word[data-color-id]');
      mainWords.forEach(mainWord => {
        const colorId = mainWord.getAttribute('data-color-id');
        if (!colorId || colorId === '') return;
        
        const colorIndex = parseInt(colorId);
        const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
        applyColor(mainWord, color);
      });
      
      // Обрабатываем главные слова без data-color-id (назначаем цвет)
      const mainWordsWithoutColor = editor.querySelectorAll('.span-main-word:not([data-color-id])');
      mainWordsWithoutColor.forEach(mainWord => {
        const usedColors = new Set();
        editor.querySelectorAll('.span-main-word[data-color-id]').forEach(el => {
          const id = el.getAttribute('data-color-id');
          if (id !== null && id !== '') {
            usedColors.add(parseInt(id));
          }
        });
        
        let freeIndex = 0;
        while (usedColors.has(freeIndex) && freeIndex < COLOR_PALETTE.length) {
          freeIndex++;
        }
        
        const color = COLOR_PALETTE[freeIndex % COLOR_PALETTE.length];
        mainWord.setAttribute('data-color-id', freeIndex);
        applyColor(mainWord, color);
      });
      
      // Применяем цвета ко всем связанным оборотам
      editor.querySelectorAll('.span-main-word[data-color-id]').forEach(mainWord => {
        const colorId = mainWord.getAttribute('data-color-id');
        if (!colorId || colorId === '') return;
        
        const colorIndex = parseInt(colorId);
        const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
        
        const linkedTurns = editor.querySelectorAll(`[data-linked-to="${colorId}"]`);
        linkedTurns.forEach(turn => {
          applyColor(turn, color);
        });
      });
    }

    // Загружаем цвета при загрузке страницы
    setTimeout(loadColorsFromHTML, 500);

    // Обновление цветов при изменении содержимого редактора
    const colorObserver = new MutationObserver(() => {
      setTimeout(() => {
        loadColorsFromHTML();
      }, 100);
    });
    
    colorObserver.observe(editor, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['data-color-id', 'data-linked-to']
    });

    // Инициализируем переиспользуемый модуль панели инструментов
    adminTextSelectionToolbar = new TextSelectionToolbar({
      containerId: 'task17-admin-floating-toolbar',
      editorSelector: '#task17-explanation-editor',
      ignoreSelectors: [],
      defaultButtons: true,
      onButtonClick: (buttonConfig, savedRange, selection) => {
        // Используем локальную функцию applySpanClass
        if (buttonConfig.class) {
          applySpanClass(buttonConfig.class);
        }
      },
      onRemoveClick: (savedRange, selection) => {
        // Используем локальную функцию removeMark
        removeMark();
      }
    });

    // Настраиваем автоматический показ панели при выделении текста
    adminTextSelectionToolbar.setupAutoShow();

    // Функция для показа панели (аналог showToolbar из основного задания)
    const showToolbar = (range) => {
      if (!adminTextSelectionToolbar) return;
      adminTextSelectionToolbar.show(range, {
        showRemoveButton: true
      });
    };
    
    // Делаем функцию доступной глобально
    window.showToolbar = showToolbar;

    // Обработчик клика на уже выделенные элементы - показывает панель (как в основном задании)
    function setupClickOnMarks() {
      const marks = editor.querySelectorAll('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word');
      marks.forEach(mark => {
        if (mark.dataset.clickSetup) return; // Уже настроено
        mark.dataset.clickSetup = 'true';
        
        // Используем click, но проверяем, не выделяется ли текст
        mark.addEventListener('click', function(e) {
          // Проверяем, есть ли выделение текста - если есть, значит пользователь выделял, а не кликал
          const selection = window.getSelection();
          if (selection.toString().trim().length > 0 && !selection.isCollapsed) {
            // Есть выделение - это не простой клик, не показываем панель
            return;
          }
          
          // Проверяем, не кликнули ли мы на вложенный элемент внутри другого выделенного элемента
          // Если клик был на вложенном элементе, не обрабатываем клик на внешнем
          const clickedElement = e.target.closest('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word');
          if (clickedElement && clickedElement !== this) {
            // Клик был на вложенном элементе, не обрабатываем внешний
            return;
          }
          
          // Если клик по главному слову
          if (this.classList.contains('span-main-word')) {
            // Если режим связывания уже активен для этого слова - второй клик показывает панель
            if (isLinkingMode && selectedMainWord === this) {
              e.preventDefault();
              e.stopPropagation();
              
              const range = document.createRange();
              range.selectNodeContents(this);
              showToolbar(range);
              return;
            }
            
            // Если режим связывания не активен - первый клик открывает режим связывания
            e.preventDefault();
            e.stopPropagation();
            
            // Закрываем панель, если она открыта
            if (adminTextSelectionToolbar) {
              adminTextSelectionToolbar.hide();
            }
            
            // Включаем режим связывания
            activateLinkingMode(this);
            return;
          }
          
          // Для остальных элементов - показываем панель
          e.preventDefault();
          e.stopPropagation();
          
          // Создаем range для выделенного элемента
          const range = document.createRange();
          range.selectNodeContents(this);
          
          // Показываем панель над этим элементом
          showToolbar(range);
        }, true); // Используем capture phase, чтобы сработать раньше других обработчиков
      });
    }

    // Наблюдаем за появлением новых выделений
    const markClickObserver = new MutationObserver(() => {
      setupClickOnMarks();
    });

    markClickObserver.observe(editor, {
      childList: true,
      subtree: true
    });

    // Устанавливаем для существующих элементов
    setupClickOnMarks();

    // Обработчик клика на главное слово для режима связывания
    document.addEventListener('click', (e) => {
      // Если режим связывания активен и клик по обороту
      if (isLinkingMode && selectedMainWord) {
        const turn = e.target.closest('.span-participle, .span-gerund');
        if (turn) {
          e.preventDefault();
          e.stopPropagation();
          linkTurnToMainWord(selectedMainWord, turn);
          return;
        }
      }

      // Проверяем, что клик по главному слову
      const mainWord = e.target.closest('.span-main-word');
      if (mainWord) {
        // Проверяем, есть ли выделение текста - если есть, не обрабатываем
        const selection = window.getSelection();
        if (selection.toString().trim().length > 0 && !selection.isCollapsed) {
          return;
        }
        
        // Если режим связывания активен и клик по другому главному слову - переключаем режим
        if (isLinkingMode && selectedMainWord && mainWord !== selectedMainWord) {
          e.preventDefault();
          e.stopPropagation();
          activateLinkingMode(mainWord);
          return;
        }
      }
    }, false);

    // Обработчик ESC для отмены режима связывания
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && isLinkingMode) {
        cancelLinkingMode();
      }
    });

    // Скрываем панель при клике вне выделения и панели
    document.addEventListener('mousedown', (e) => {
      // Не скрываем панель, если клик по выделенному элементу или панели
      if (e.target.closest('.span-participle, .span-gerund, .span-subject, .span-predicate, .span-main-word')) {
        return;
      }
      
      if (adminTextSelectionToolbar && adminTextSelectionToolbar.toolbar && adminTextSelectionToolbar.toolbar.contains(e.target)) {
        return;
      }
      
      // Скрываем панель
      if (adminTextSelectionToolbar) {
        adminTextSelectionToolbar.hide();
      }
    });

    // Синхронизация содержимого редактора с скрытым textarea перед отправкой формы
    const form = document.getElementById('task17-form');
    form.addEventListener('submit', () => {
      const explanationHtml = editor.innerHTML;
      document.getElementById('task17-explanation').value = explanationHtml;
    });
  }

  // Инициализация при загрузке страницы
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTask17SpanToolbar);
  } else {
    initTask17SpanToolbar();
  }

  // Обработчик отправки формы задания №17
  document.getElementById('task17-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const explanationEditor = document.getElementById('task17-explanation-editor');
    const explanationHtml = explanationEditor.innerHTML;
    
    // Исходный текст берем из поля task17-text (с метками), а не из редактора объяснения
    const textInput = document.getElementById('task17-text');
    const text = textInput ? textInput.value.trim() : '';
    
    if (!text) {
      alert('Введите предложение с метками (1), (2)...');
      return;
    }
    
    const answerInput = document.getElementById('task17-answer').value.trim();
    
    // Получаем источник
    const select = document.getElementById('task17-source');
    const newSourceInput = document.getElementById('task17-source-new');
    let source = select.value;
    
    // Если выбран "+ Новый", проверяем поле ввода
    if (source === '__new__') {
      const newSourceName = newSourceInput.value.trim();
      if (!newSourceName) {
        alert('Введите название нового источника');
        return;
      }
      
      // Добавляем новый источник в БД
      try {
        const response = await fetch('/api/sources', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: newSourceName })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Ошибка добавления источника');
        }
        
        // Обновляем список источников и выбираем новый источник
        await loadTask17Sources();
        source = newSourceName;
      } catch (error) {
        console.error('Ошибка добавления источника:', error);
        alert('Ошибка добавления источника: ' + error.message);
        return;
      }
    }
    
    if (!source || source.trim() === '' || source === '__new__') {
      alert('Выберите источник');
      return;
    }
    
    // Парсим ответ - извлекаем каждую отдельную цифру из строки
    // Например: "478" -> [4, 7, 8], "1,2,3" -> [1, 2, 3], "1 2 3" -> [1, 2, 3]
    const answerDigits = answerInput
      .split('') // Разбиваем на отдельные символы
      .map(char => parseInt(char, 10))
      .filter(n => !isNaN(n) && n > 0)
      .filter((value, index, self) => self.indexOf(value) === index); // Убираем дубликаты
    
    if (answerDigits.length === 0) {
      alert('Введите хотя бы одну цифру в ответе');
      return;
    }

    // Автоматически вычисляем base_text, commaless_text и позиции запятых
    // Учитываем сдвиг индексов при удалении цифр (N) и пробела после них
    const { baseText, commalessText, commaPositions } = calculateCommaPositions(text, answerDigits);
    
    console.log('[ADMIN] Вычисленные данные:');
    console.log('[ADMIN] baseText:', baseText);
    console.log('[ADMIN] commalessText:', commalessText);
    console.log('[ADMIN] commaPositions:', commaPositions);
    console.log('[ADMIN] commaPositions.length:', commaPositions?.length);
    console.log('[ADMIN] answerDigits:', answerDigits);

    // Извлекаем все цифры из исходного текста для проверки
    const allDigitsInText = [];
    const digitRegex = /\((\d+)\)/g;
    let match;
    while ((match = digitRegex.exec(text)) !== null) {
      allDigitsInText.push(parseInt(match[1], 10));
    }

    // Извлекаем спаны из объяснения (обороты с классами span-participle и span-gerund)
    // Спаны в объяснении сохраняются как HTML, без индексов
    // Они не требуются для проверки задания, только для отображения
    
    // НОВАЯ ЛОГИКА: нормализуем source_text перед сохранением
    const normalizedSourceText = normalizeSourceText(text);
    
    const formData = {
      source_text: normalizedSourceText, // Сохраняем нормализованный текст
      base_text: baseText,
      commaless_text: commalessText,
      digits: answerDigits, // Правильные цифры из ответа
      comma_positions: commaPositions, // Позиции запятых из интерактивного редактора или вычисленные
      spans: [], // Пустой массив - обороты только в объяснении (HTML)
      answer_text: null,
      explanation_md: explanationHtml,
      source: source,
      reveal_policy: 'after_correct'
    };
    
    console.log('[ADMIN] Отправляем на сервер:');
    console.log('[ADMIN] formData.comma_positions:', formData.comma_positions);
    console.log('[ADMIN] formData.comma_positions.length:', formData.comma_positions?.length);
    
    const taskId = document.getElementById('task17-id').value;
    const url = taskId ? `/api/task17/${taskId}` : '/api/task17';
    const method = taskId ? 'PUT' : 'POST';
    
    try {
      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        const errorMessage = errorData.details ? `${errorData.error}: ${errorData.details}` : (errorData.error || 'Ошибка сохранения');
        throw new Error(errorMessage);
      }
      
      const result = await response.json();
      alert(taskId ? 'Задание обновлено' : 'Задание создано (ID: ' + result.id + ')');
      
      resetTask17Form();
      loadTask17List();
    } catch (error) {
      console.error('Ошибка сохранения задания:', error);
      console.error('Form data:', formData);
      alert('Ошибка сохранения: ' + error.message);
    }
  });
</script>

